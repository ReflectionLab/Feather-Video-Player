import { unref as M, getCurrentScope as Cu, onScopeDispose as Ru, getCurrentInstance as qr, onMounted as ht, nextTick as ct, watch as Re, ref as q, openBlock as X, createElementBlock as le, createElementVNode as se, warn as wu, computed as J, inject as $e, isRef as ku, shallowRef as ni, onBeforeUnmount as qt, onBeforeMount as Du, provide as ir, defineComponent as De, mergeProps as hr, renderSlot as it, toRef as Ar, onUnmounted as Ba, useAttrs as Ou, useSlots as Pu, withDirectives as jt, createCommentVNode as ye, Fragment as Wt, normalizeClass as Ee, createBlock as ke, withCtx as Ce, resolveDynamicComponent as _r, withModifiers as Ur, createVNode as Ze, toDisplayString as gt, normalizeStyle as Nt, vShow as Er, cloneVNode as Mu, Text as Bu, Comment as Fu, Teleport as Nu, Transition as Fa, readonly as Uu, onDeactivated as Ku, reactive as ci, onUpdated as Gu, withKeys as ri, createTextVNode as Vu, toRefs as zn, h as Na, renderList as si, createApp as Hu, pushScopeId as ju, popScopeId as Wu } from "vue";
const $t = (i, e, { checkForDefaultPrevented: t = !0 } = {}) => (n) => {
  const s = i == null ? void 0 : i(n);
  if (t === !1 || !s)
    return e == null ? void 0 : e(n);
};
var Zs;
const Rt = typeof window < "u", Qu = (i) => typeof i == "string", Ua = () => {
}, Ju = Rt && ((Zs = window == null ? void 0 : window.navigator) == null ? void 0 : Zs.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Ka(i) {
  return typeof i == "function" ? i() : M(i);
}
function Yu(i) {
  return i;
}
function us(i) {
  return Cu() ? (Ru(i), !0) : !1;
}
function zu(i, e = !0) {
  qr() ? ht(i) : e ? i() : ct(i);
}
function cr(i) {
  var e;
  const t = Ka(i);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const cs = Rt ? window : void 0;
function Ni(...i) {
  let e, t, r, n;
  if (Qu(i[0]) || Array.isArray(i[0]) ? ([t, r, n] = i, e = cs) : [e, t, r, n] = i, !e)
    return Ua;
  Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]);
  const s = [], o = () => {
    s.forEach((c) => c()), s.length = 0;
  }, a = (c, d, h, p) => (c.addEventListener(d, h, p), () => c.removeEventListener(d, h, p)), l = Re(() => [cr(e), Ka(n)], ([c, d]) => {
    o(), c && s.push(...t.flatMap((h) => r.map((p) => a(c, h, p, d))));
  }, { immediate: !0, flush: "post" }), u = () => {
    l(), o();
  };
  return us(u), u;
}
let Xs = !1;
function qu(i, e, t = {}) {
  const { window: r = cs, ignore: n = [], capture: s = !0, detectIframe: o = !1 } = t;
  if (!r)
    return;
  Ju && !Xs && (Xs = !0, Array.from(r.document.body.children).forEach((h) => h.addEventListener("click", Ua)));
  let a = !0;
  const l = (h) => n.some((p) => {
    if (typeof p == "string")
      return Array.from(r.document.querySelectorAll(p)).some((f) => f === h.target || h.composedPath().includes(f));
    {
      const f = cr(p);
      return f && (h.target === f || h.composedPath().includes(f));
    }
  }), c = [
    Ni(r, "click", (h) => {
      const p = cr(i);
      if (!(!p || p === h.target || h.composedPath().includes(p))) {
        if (h.detail === 0 && (a = !l(h)), !a) {
          a = !0;
          return;
        }
        e(h);
      }
    }, { passive: !0, capture: s }),
    Ni(r, "pointerdown", (h) => {
      const p = cr(i);
      p && (a = !h.composedPath().includes(p) && !l(h));
    }, { passive: !0 }),
    o && Ni(r, "blur", (h) => {
      var p;
      const f = cr(i);
      ((p = r.document.activeElement) == null ? void 0 : p.tagName) === "IFRAME" && !(f != null && f.contains(r.document.activeElement)) && e(h);
    })
  ].filter(Boolean);
  return () => c.forEach((h) => h());
}
function Zu(i, e = !1) {
  const t = q(), r = () => t.value = !!i();
  return r(), zu(r, e), t;
}
const $s = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, eo = "__vueuse_ssr_handlers__";
$s[eo] = $s[eo] || {};
var to = Object.getOwnPropertySymbols, Xu = Object.prototype.hasOwnProperty, $u = Object.prototype.propertyIsEnumerable, ec = (i, e) => {
  var t = {};
  for (var r in i)
    Xu.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
  if (i != null && to)
    for (var r of to(i))
      e.indexOf(r) < 0 && $u.call(i, r) && (t[r] = i[r]);
  return t;
};
function tc(i, e, t = {}) {
  const r = t, { window: n = cs } = r, s = ec(r, ["window"]);
  let o;
  const a = Zu(() => n && "ResizeObserver" in n), l = () => {
    o && (o.disconnect(), o = void 0);
  }, u = Re(() => cr(i), (d) => {
    l(), a.value && n && d && (o = new ResizeObserver(e), o.observe(d, s));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), u();
  };
  return us(c), {
    isSupported: a,
    stop: c
  };
}
var ro;
(function(i) {
  i.UP = "UP", i.RIGHT = "RIGHT", i.DOWN = "DOWN", i.LEFT = "LEFT", i.NONE = "NONE";
})(ro || (ro = {}));
var rc = Object.defineProperty, io = Object.getOwnPropertySymbols, ic = Object.prototype.hasOwnProperty, nc = Object.prototype.propertyIsEnumerable, no = (i, e, t) => e in i ? rc(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, sc = (i, e) => {
  for (var t in e || (e = {}))
    ic.call(e, t) && no(i, t, e[t]);
  if (io)
    for (var t of io(e))
      nc.call(e, t) && no(i, t, e[t]);
  return i;
};
const oc = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
sc({
  linear: Yu
}, oc);
const ac = () => Rt && /firefox/i.test(window.navigator.userAgent);
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const Vi = () => {
}, lc = Object.prototype.hasOwnProperty, so = (i, e) => lc.call(i, e), Ga = Array.isArray, dr = (i) => typeof i == "function", It = (i) => typeof i == "string", Hr = (i) => i !== null && typeof i == "object", oo = (i) => Hr(i) && dr(i.then) && dr(i.catch);
var uc = typeof global == "object" && global && global.Object === Object && global;
const cc = uc;
var dc = typeof self == "object" && self && self.Object === Object && self, hc = cc || dc || Function("return this")();
const en = hc;
var fc = en.Symbol;
const jr = fc;
var Va = Object.prototype, pc = Va.hasOwnProperty, gc = Va.toString, $r = jr ? jr.toStringTag : void 0;
function mc(i) {
  var e = pc.call(i, $r), t = i[$r];
  try {
    i[$r] = void 0;
    var r = !0;
  } catch {
  }
  var n = gc.call(i);
  return r && (e ? i[$r] = t : delete i[$r]), n;
}
var vc = Object.prototype, yc = vc.toString;
function Ec(i) {
  return yc.call(i);
}
var Ac = "[object Null]", _c = "[object Undefined]", ao = jr ? jr.toStringTag : void 0;
function Ha(i) {
  return i == null ? i === void 0 ? _c : Ac : ao && ao in Object(i) ? mc(i) : Ec(i);
}
function xc(i) {
  return i != null && typeof i == "object";
}
var Sc = "[object Symbol]";
function tn(i) {
  return typeof i == "symbol" || xc(i) && Ha(i) == Sc;
}
function Tc(i, e) {
  for (var t = -1, r = i == null ? 0 : i.length, n = Array(r); ++t < r; )
    n[t] = e(i[t], t, i);
  return n;
}
var Ic = Array.isArray;
const ds = Ic;
var bc = 1 / 0, lo = jr ? jr.prototype : void 0, uo = lo ? lo.toString : void 0;
function ja(i) {
  if (typeof i == "string")
    return i;
  if (ds(i))
    return Tc(i, ja) + "";
  if (tn(i))
    return uo ? uo.call(i) : "";
  var e = i + "";
  return e == "0" && 1 / i == -bc ? "-0" : e;
}
var Lc = /\s/;
function Cc(i) {
  for (var e = i.length; e-- && Lc.test(i.charAt(e)); )
    ;
  return e;
}
var Rc = /^\s+/;
function wc(i) {
  return i && i.slice(0, Cc(i) + 1).replace(Rc, "");
}
function di(i) {
  var e = typeof i;
  return i != null && (e == "object" || e == "function");
}
var co = 0 / 0, kc = /^[-+]0x[0-9a-f]+$/i, Dc = /^0b[01]+$/i, Oc = /^0o[0-7]+$/i, Pc = parseInt;
function ho(i) {
  if (typeof i == "number")
    return i;
  if (tn(i))
    return co;
  if (di(i)) {
    var e = typeof i.valueOf == "function" ? i.valueOf() : i;
    i = di(e) ? e + "" : e;
  }
  if (typeof i != "string")
    return i === 0 ? i : +i;
  i = wc(i);
  var t = Dc.test(i);
  return t || Oc.test(i) ? Pc(i.slice(2), t ? 2 : 8) : kc.test(i) ? co : +i;
}
var Mc = "[object AsyncFunction]", Bc = "[object Function]", Fc = "[object GeneratorFunction]", Nc = "[object Proxy]";
function Uc(i) {
  if (!di(i))
    return !1;
  var e = Ha(i);
  return e == Bc || e == Fc || e == Mc || e == Nc;
}
var Kc = en["__core-js_shared__"];
const yn = Kc;
var fo = function() {
  var i = /[^.]+$/.exec(yn && yn.keys && yn.keys.IE_PROTO || "");
  return i ? "Symbol(src)_1." + i : "";
}();
function Gc(i) {
  return !!fo && fo in i;
}
var Vc = Function.prototype, Hc = Vc.toString;
function jc(i) {
  if (i != null) {
    try {
      return Hc.call(i);
    } catch {
    }
    try {
      return i + "";
    } catch {
    }
  }
  return "";
}
var Wc = /[\\^$.*+?()[\]{}|]/g, Qc = /^\[object .+?Constructor\]$/, Jc = Function.prototype, Yc = Object.prototype, zc = Jc.toString, qc = Yc.hasOwnProperty, Zc = RegExp(
  "^" + zc.call(qc).replace(Wc, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Xc(i) {
  if (!di(i) || Gc(i))
    return !1;
  var e = Uc(i) ? Zc : Qc;
  return e.test(jc(i));
}
function $c(i, e) {
  return i == null ? void 0 : i[e];
}
function Wa(i, e) {
  var t = $c(i, e);
  return Xc(t) ? t : void 0;
}
function ed(i, e) {
  return i === e || i !== i && e !== e;
}
var td = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, rd = /^\w*$/;
function id(i, e) {
  if (ds(i))
    return !1;
  var t = typeof i;
  return t == "number" || t == "symbol" || t == "boolean" || i == null || tn(i) ? !0 : rd.test(i) || !td.test(i) || e != null && i in Object(e);
}
var nd = Wa(Object, "create");
const hi = nd;
function sd() {
  this.__data__ = hi ? hi(null) : {}, this.size = 0;
}
function od(i) {
  var e = this.has(i) && delete this.__data__[i];
  return this.size -= e ? 1 : 0, e;
}
var ad = "__lodash_hash_undefined__", ld = Object.prototype, ud = ld.hasOwnProperty;
function cd(i) {
  var e = this.__data__;
  if (hi) {
    var t = e[i];
    return t === ad ? void 0 : t;
  }
  return ud.call(e, i) ? e[i] : void 0;
}
var dd = Object.prototype, hd = dd.hasOwnProperty;
function fd(i) {
  var e = this.__data__;
  return hi ? e[i] !== void 0 : hd.call(e, i);
}
var pd = "__lodash_hash_undefined__";
function gd(i, e) {
  var t = this.__data__;
  return this.size += this.has(i) ? 0 : 1, t[i] = hi && e === void 0 ? pd : e, this;
}
function Ir(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var r = i[e];
    this.set(r[0], r[1]);
  }
}
Ir.prototype.clear = sd;
Ir.prototype.delete = od;
Ir.prototype.get = cd;
Ir.prototype.has = fd;
Ir.prototype.set = gd;
function md() {
  this.__data__ = [], this.size = 0;
}
function rn(i, e) {
  for (var t = i.length; t--; )
    if (ed(i[t][0], e))
      return t;
  return -1;
}
var vd = Array.prototype, yd = vd.splice;
function Ed(i) {
  var e = this.__data__, t = rn(e, i);
  if (t < 0)
    return !1;
  var r = e.length - 1;
  return t == r ? e.pop() : yd.call(e, t, 1), --this.size, !0;
}
function Ad(i) {
  var e = this.__data__, t = rn(e, i);
  return t < 0 ? void 0 : e[t][1];
}
function _d(i) {
  return rn(this.__data__, i) > -1;
}
function xd(i, e) {
  var t = this.__data__, r = rn(t, i);
  return r < 0 ? (++this.size, t.push([i, e])) : t[r][1] = e, this;
}
function Zr(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var r = i[e];
    this.set(r[0], r[1]);
  }
}
Zr.prototype.clear = md;
Zr.prototype.delete = Ed;
Zr.prototype.get = Ad;
Zr.prototype.has = _d;
Zr.prototype.set = xd;
var Sd = Wa(en, "Map");
const Td = Sd;
function Id() {
  this.size = 0, this.__data__ = {
    hash: new Ir(),
    map: new (Td || Zr)(),
    string: new Ir()
  };
}
function bd(i) {
  var e = typeof i;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? i !== "__proto__" : i === null;
}
function nn(i, e) {
  var t = i.__data__;
  return bd(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function Ld(i) {
  var e = nn(this, i).delete(i);
  return this.size -= e ? 1 : 0, e;
}
function Cd(i) {
  return nn(this, i).get(i);
}
function Rd(i) {
  return nn(this, i).has(i);
}
function wd(i, e) {
  var t = nn(this, i), r = t.size;
  return t.set(i, e), this.size += t.size == r ? 0 : 1, this;
}
function Cr(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var r = i[e];
    this.set(r[0], r[1]);
  }
}
Cr.prototype.clear = Id;
Cr.prototype.delete = Ld;
Cr.prototype.get = Cd;
Cr.prototype.has = Rd;
Cr.prototype.set = wd;
var kd = "Expected a function";
function hs(i, e) {
  if (typeof i != "function" || e != null && typeof e != "function")
    throw new TypeError(kd);
  var t = function() {
    var r = arguments, n = e ? e.apply(this, r) : r[0], s = t.cache;
    if (s.has(n))
      return s.get(n);
    var o = i.apply(this, r);
    return t.cache = s.set(n, o) || s, o;
  };
  return t.cache = new (hs.Cache || Cr)(), t;
}
hs.Cache = Cr;
var Dd = 500;
function Od(i) {
  var e = hs(i, function(r) {
    return t.size === Dd && t.clear(), r;
  }), t = e.cache;
  return e;
}
var Pd = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Md = /\\(\\)?/g, Bd = Od(function(i) {
  var e = [];
  return i.charCodeAt(0) === 46 && e.push(""), i.replace(Pd, function(t, r, n, s) {
    e.push(n ? s.replace(Md, "$1") : r || t);
  }), e;
});
const Fd = Bd;
function Nd(i) {
  return i == null ? "" : ja(i);
}
function Ud(i, e) {
  return ds(i) ? i : id(i, e) ? [i] : Fd(Nd(i));
}
var Kd = 1 / 0;
function Gd(i) {
  if (typeof i == "string" || tn(i))
    return i;
  var e = i + "";
  return e == "0" && 1 / i == -Kd ? "-0" : e;
}
function Vd(i, e) {
  e = Ud(e, i);
  for (var t = 0, r = e.length; i != null && t < r; )
    i = i[Gd(e[t++])];
  return t && t == r ? i : void 0;
}
function Hd(i, e, t) {
  var r = i == null ? void 0 : Vd(i, e);
  return r === void 0 ? t : r;
}
var jd = function() {
  return en.Date.now();
};
const En = jd;
var Wd = "Expected a function", Qd = Math.max, Jd = Math.min;
function po(i, e, t) {
  var r, n, s, o, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof i != "function")
    throw new TypeError(Wd);
  e = ho(e) || 0, di(t) && (c = !!t.leading, d = "maxWait" in t, s = d ? Qd(ho(t.maxWait) || 0, e) : s, h = "trailing" in t ? !!t.trailing : h);
  function p(S) {
    var b = r, w = n;
    return r = n = void 0, u = S, o = i.apply(w, b), o;
  }
  function f(S) {
    return u = S, a = setTimeout(v, e), c ? p(S) : o;
  }
  function g(S) {
    var b = S - l, w = S - u, P = e - b;
    return d ? Jd(P, s - w) : P;
  }
  function m(S) {
    var b = S - l, w = S - u;
    return l === void 0 || b >= e || b < 0 || d && w >= s;
  }
  function v() {
    var S = En();
    if (m(S))
      return E(S);
    a = setTimeout(v, g(S));
  }
  function E(S) {
    return a = void 0, h && r ? p(S) : (r = n = void 0, o);
  }
  function A() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = n = a = void 0;
  }
  function _() {
    return a === void 0 ? o : E(En());
  }
  function y() {
    var S = En(), b = m(S);
    if (r = arguments, n = this, l = S, b) {
      if (a === void 0)
        return f(l);
      if (d)
        return clearTimeout(a), a = setTimeout(v, e), p(l);
    }
    return a === void 0 && (a = setTimeout(v, e)), o;
  }
  return y.cancel = A, y.flush = _, y;
}
function Hi(i) {
  for (var e = -1, t = i == null ? 0 : i.length, r = {}; ++e < t; ) {
    var n = i[e];
    r[n[0]] = n[1];
  }
  return r;
}
function rr(i) {
  return i == null;
}
function Yd(i) {
  return i === void 0;
}
const ii = (i) => i === void 0, xr = (i) => typeof i == "boolean", ze = (i) => typeof i == "number", ji = (i) => typeof Element > "u" ? !1 : i instanceof Element, zd = (i) => It(i) ? !Number.isNaN(Number(i)) : !1;
class Qa extends Error {
  constructor(e) {
    super(e), this.name = "ElementPlusError";
  }
}
function Ja(i, e) {
  throw new Qa(`[${i}] ${e}`);
}
function lt(i, e) {
  if (process.env.NODE_ENV !== "production") {
    const t = It(i) ? new Qa(`[${i}] ${e}`) : i;
    console.warn(t);
  }
}
const qd = "utils/dom/style";
function fs(i, e = "px") {
  if (!i)
    return "";
  if (ze(i) || zd(i))
    return `${i}${e}`;
  if (It(i))
    return i;
  lt(qd, "binding value must be a string or number");
}
/*! Element Plus Icons Vue v2.1.0 */
var sr = (i, e) => {
  let t = i.__vccOpts || i;
  for (let [r, n] of e)
    t[r] = n;
  return t;
}, Zd = {
  name: "ArrowDown"
}, Xd = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, $d = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
  },
  null,
  -1
  /* HOISTED */
), eh = [
  $d
];
function th(i, e, t, r, n, s) {
  return X(), le("svg", Xd, eh);
}
var rh = /* @__PURE__ */ sr(Zd, [["render", th], ["__file", "arrow-down.vue"]]), ih = {
  name: "ArrowUp"
}, nh = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, sh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
  },
  null,
  -1
  /* HOISTED */
), oh = [
  sh
];
function ah(i, e, t, r, n, s) {
  return X(), le("svg", nh, oh);
}
var lh = /* @__PURE__ */ sr(ih, [["render", ah], ["__file", "arrow-up.vue"]]), uh = {
  name: "CircleCheck"
}, ch = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, dh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
  },
  null,
  -1
  /* HOISTED */
), hh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
  },
  null,
  -1
  /* HOISTED */
), fh = [
  dh,
  hh
];
function ph(i, e, t, r, n, s) {
  return X(), le("svg", ch, fh);
}
var gh = /* @__PURE__ */ sr(uh, [["render", ph], ["__file", "circle-check.vue"]]), mh = {
  name: "CircleClose"
}, vh = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, yh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
  },
  null,
  -1
  /* HOISTED */
), Eh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
  },
  null,
  -1
  /* HOISTED */
), Ah = [
  yh,
  Eh
];
function _h(i, e, t, r, n, s) {
  return X(), le("svg", vh, Ah);
}
var Ya = /* @__PURE__ */ sr(mh, [["render", _h], ["__file", "circle-close.vue"]]), xh = {
  name: "Hide"
}, Sh = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Th = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
  },
  null,
  -1
  /* HOISTED */
), Ih = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
  },
  null,
  -1
  /* HOISTED */
), bh = [
  Th,
  Ih
];
function Lh(i, e, t, r, n, s) {
  return X(), le("svg", Sh, bh);
}
var Ch = /* @__PURE__ */ sr(xh, [["render", Lh], ["__file", "hide.vue"]]), Rh = {
  name: "Loading"
}, wh = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, kh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
  },
  null,
  -1
  /* HOISTED */
), Dh = [
  kh
];
function Oh(i, e, t, r, n, s) {
  return X(), le("svg", wh, Dh);
}
var za = /* @__PURE__ */ sr(Rh, [["render", Oh], ["__file", "loading.vue"]]), Ph = {
  name: "Minus"
}, Mh = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Bh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
  },
  null,
  -1
  /* HOISTED */
), Fh = [
  Bh
];
function Nh(i, e, t, r, n, s) {
  return X(), le("svg", Mh, Fh);
}
var Uh = /* @__PURE__ */ sr(Ph, [["render", Nh], ["__file", "minus.vue"]]), Kh = {
  name: "Plus"
}, Gh = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Vh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
  },
  null,
  -1
  /* HOISTED */
), Hh = [
  Vh
];
function jh(i, e, t, r, n, s) {
  return X(), le("svg", Gh, Hh);
}
var Wh = /* @__PURE__ */ sr(Kh, [["render", jh], ["__file", "plus.vue"]]), Qh = {
  name: "View"
}, Jh = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Yh = /* @__PURE__ */ se(
  "path",
  {
    fill: "currentColor",
    d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
  },
  null,
  -1
  /* HOISTED */
), zh = [
  Yh
];
function qh(i, e, t, r, n, s) {
  return X(), le("svg", Jh, zh);
}
var Zh = /* @__PURE__ */ sr(Qh, [["render", qh], ["__file", "view.vue"]]);
const qa = "__epPropKey", Te = (i) => i, Xh = (i) => Hr(i) && !!i[qa], sn = (i, e) => {
  if (!Hr(i) || Xh(i))
    return i;
  const { values: t, required: r, default: n, type: s, validator: o } = i, l = {
    type: s,
    required: !!r,
    validator: t || o ? (u) => {
      let c = !1, d = [];
      if (t && (d = Array.from(t), so(i, "default") && d.push(n), c || (c = d.includes(u))), o && (c || (c = o(u))), !c && d.length > 0) {
        const h = [...new Set(d)].map((p) => JSON.stringify(p)).join(", ");
        wu(`Invalid prop: validation failed${e ? ` for prop "${e}"` : ""}. Expected one of [${h}], got value ${JSON.stringify(u)}.`);
      }
      return c;
    } : void 0,
    [qa]: !0
  };
  return so(i, "default") && (l.default = n), l;
}, Xe = (i) => Hi(Object.entries(i).map(([e, t]) => [
  e,
  sn(t, e)
])), fi = Te([
  String,
  Object,
  Function
]), $h = {
  validating: za,
  success: gh,
  error: Ya
}, fr = (i, e) => {
  if (i.install = (t) => {
    for (const r of [i, ...Object.values(e ?? {})])
      t.component(r.name, r);
  }, e)
    for (const [t, r] of Object.entries(e))
      i[t] = r;
  return i;
}, ef = (i, e) => (i.install = (t) => {
  t.directive(e, i);
}, i), pi = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, dt = "update:modelValue", br = "change", Qt = "input", Za = ["", "default", "small", "large"], tf = (i) => ["", ...Za].includes(i), rf = (i) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(i), nf = (i) => i, sf = ["class", "style"], of = /^on[A-Z]/, af = (i = {}) => {
  const { excludeListeners: e = !1, excludeKeys: t } = i, r = J(() => ((t == null ? void 0 : t.value) || []).concat(sf)), n = qr();
  return n ? J(() => {
    var s;
    return Hi(Object.entries((s = n.proxy) == null ? void 0 : s.$attrs).filter(([o]) => !r.value.includes(o) && !(e && of.test(o))));
  }) : (lt("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), J(() => ({})));
}, lf = ({ from: i, replacement: e, scope: t, version: r, ref: n, type: s = "API" }, o) => {
  Re(() => M(o), (a) => {
    a && lt(t, `[${s}] ${i} is about to be deprecated in version ${r}, please use ${e} instead.
For more detail, please visit: ${n}
`);
  }, {
    immediate: !0
  });
};
var uf = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const cf = (i) => (e, t) => df(e, t, M(i)), df = (i, e, t) => Hd(t, i, i).replace(/\{(\w+)\}/g, (r, n) => {
  var s;
  return `${(s = e == null ? void 0 : e[n]) != null ? s : `{${n}}`}`;
}), hf = (i) => {
  const e = J(() => M(i).name), t = ku(i) ? i : q(i);
  return {
    lang: e,
    locale: t,
    t: cf(i)
  };
}, ff = Symbol("localeContextKey"), Xa = (i) => {
  const e = i || $e(ff, q());
  return hf(J(() => e.value || uf));
}, go = "el", pf = "is-", mr = (i, e, t, r, n) => {
  let s = `${i}-${e}`;
  return t && (s += `-${t}`), r && (s += `__${r}`), n && (s += `--${n}`), s;
}, gf = Symbol("namespaceContextKey"), ps = (i) => {
  const e = i || $e(gf, q(go));
  return J(() => M(e) || go);
}, St = (i, e) => {
  const t = ps(e);
  return {
    namespace: t,
    b: (g = "") => mr(t.value, i, g, "", ""),
    e: (g) => g ? mr(t.value, i, "", g, "") : "",
    m: (g) => g ? mr(t.value, i, "", "", g) : "",
    be: (g, m) => g && m ? mr(t.value, i, g, m, "") : "",
    em: (g, m) => g && m ? mr(t.value, i, "", g, m) : "",
    bm: (g, m) => g && m ? mr(t.value, i, g, "", m) : "",
    bem: (g, m, v) => g && m && v ? mr(t.value, i, g, m, v) : "",
    is: (g, ...m) => {
      const v = m.length >= 1 ? m[0] : !0;
      return g && v ? `${pf}${g}` : "";
    },
    cssVar: (g) => {
      const m = {};
      for (const v in g)
        g[v] && (m[`--${t.value}-${v}`] = g[v]);
      return m;
    },
    cssVarName: (g) => `--${t.value}-${g}`,
    cssVarBlock: (g) => {
      const m = {};
      for (const v in g)
        g[v] && (m[`--${t.value}-${i}-${v}`] = g[v]);
      return m;
    },
    cssVarBlockName: (g) => `--${t.value}-${i}-${g}`
  };
}, mf = sn({
  type: Te(Boolean),
  default: null
}), vf = sn({
  type: Te(Function)
}), $a = (i) => {
  const e = `update:${i}`, t = `onUpdate:${i}`, r = [e], n = {
    [i]: mf,
    [t]: vf
  };
  return {
    useModelToggle: ({
      indicator: o,
      toggleReason: a,
      shouldHideWhenRouteChanges: l,
      shouldProceed: u,
      onShow: c,
      onHide: d
    }) => {
      const h = qr(), { emit: p } = h, f = h.props, g = J(() => dr(f[t])), m = J(() => f[i] === null), v = (b) => {
        o.value !== !0 && (o.value = !0, a && (a.value = b), dr(c) && c(b));
      }, E = (b) => {
        o.value !== !1 && (o.value = !1, a && (a.value = b), dr(d) && d(b));
      }, A = (b) => {
        if (f.disabled === !0 || dr(u) && !u())
          return;
        const w = g.value && Rt;
        w && p(e, !0), (m.value || !w) && v(b);
      }, _ = (b) => {
        if (f.disabled === !0 || !Rt)
          return;
        const w = g.value && Rt;
        w && p(e, !1), (m.value || !w) && E(b);
      }, y = (b) => {
        xr(b) && (f.disabled && b ? g.value && p(e, !1) : o.value !== b && (b ? v() : E()));
      }, S = () => {
        o.value ? _() : A();
      };
      return Re(() => f[i], y), l && h.appContext.config.globalProperties.$route !== void 0 && Re(() => ({
        ...h.proxy.$route
      }), () => {
        l.value && o.value && _();
      }), ht(() => {
        y(f[i]);
      }), {
        hide: _,
        show: A,
        toggle: S,
        hasUpdateHandler: g
      };
    },
    useModelToggleProps: n,
    useModelToggleEmits: r
  };
};
$a("modelValue");
const el = (i) => {
  const e = qr();
  return J(() => {
    var t, r;
    return (r = (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$props) == null ? void 0 : r[i];
  });
};
var _t = "top", kt = "bottom", Dt = "right", xt = "left", gs = "auto", _i = [_t, kt, Dt, xt], Wr = "start", gi = "end", yf = "clippingParents", tl = "viewport", ei = "popper", Ef = "reference", mo = _i.reduce(function(i, e) {
  return i.concat([e + "-" + Wr, e + "-" + gi]);
}, []), xi = [].concat(_i, [gs]).reduce(function(i, e) {
  return i.concat([e, e + "-" + Wr, e + "-" + gi]);
}, []), Af = "beforeRead", _f = "read", xf = "afterRead", Sf = "beforeMain", Tf = "main", If = "afterMain", bf = "beforeWrite", Lf = "write", Cf = "afterWrite", Rf = [Af, _f, xf, Sf, Tf, If, bf, Lf, Cf];
function zt(i) {
  return i ? (i.nodeName || "").toLowerCase() : null;
}
function Gt(i) {
  if (i == null)
    return window;
  if (i.toString() !== "[object Window]") {
    var e = i.ownerDocument;
    return e && e.defaultView || window;
  }
  return i;
}
function Qr(i) {
  var e = Gt(i).Element;
  return i instanceof e || i instanceof Element;
}
function wt(i) {
  var e = Gt(i).HTMLElement;
  return i instanceof e || i instanceof HTMLElement;
}
function ms(i) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Gt(i).ShadowRoot;
  return i instanceof e || i instanceof ShadowRoot;
}
function wf(i) {
  var e = i.state;
  Object.keys(e.elements).forEach(function(t) {
    var r = e.styles[t] || {}, n = e.attributes[t] || {}, s = e.elements[t];
    !wt(s) || !zt(s) || (Object.assign(s.style, r), Object.keys(n).forEach(function(o) {
      var a = n[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function kf(i) {
  var e = i.state, t = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var n = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : t[r]), a = o.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !wt(n) || !zt(n) || (Object.assign(n.style, a), Object.keys(s).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
var rl = { name: "applyStyles", enabled: !0, phase: "write", fn: wf, effect: kf, requires: ["computeStyles"] };
function Jt(i) {
  return i.split("-")[0];
}
var Sr = Math.max, Wi = Math.min, Jr = Math.round;
function Yr(i, e) {
  e === void 0 && (e = !1);
  var t = i.getBoundingClientRect(), r = 1, n = 1;
  if (wt(i) && e) {
    var s = i.offsetHeight, o = i.offsetWidth;
    o > 0 && (r = Jr(t.width) / o || 1), s > 0 && (n = Jr(t.height) / s || 1);
  }
  return { width: t.width / r, height: t.height / n, top: t.top / n, right: t.right / r, bottom: t.bottom / n, left: t.left / r, x: t.left / r, y: t.top / n };
}
function vs(i) {
  var e = Yr(i), t = i.offsetWidth, r = i.offsetHeight;
  return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: i.offsetLeft, y: i.offsetTop, width: t, height: r };
}
function il(i, e) {
  var t = e.getRootNode && e.getRootNode();
  if (i.contains(e))
    return !0;
  if (t && ms(t)) {
    var r = e;
    do {
      if (r && i.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function nr(i) {
  return Gt(i).getComputedStyle(i);
}
function Df(i) {
  return ["table", "td", "th"].indexOf(zt(i)) >= 0;
}
function pr(i) {
  return ((Qr(i) ? i.ownerDocument : i.document) || window.document).documentElement;
}
function on(i) {
  return zt(i) === "html" ? i : i.assignedSlot || i.parentNode || (ms(i) ? i.host : null) || pr(i);
}
function vo(i) {
  return !wt(i) || nr(i).position === "fixed" ? null : i.offsetParent;
}
function Of(i) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, t = navigator.userAgent.indexOf("Trident") !== -1;
  if (t && wt(i)) {
    var r = nr(i);
    if (r.position === "fixed")
      return null;
  }
  var n = on(i);
  for (ms(n) && (n = n.host); wt(n) && ["html", "body"].indexOf(zt(n)) < 0; ) {
    var s = nr(n);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Si(i) {
  for (var e = Gt(i), t = vo(i); t && Df(t) && nr(t).position === "static"; )
    t = vo(t);
  return t && (zt(t) === "html" || zt(t) === "body" && nr(t).position === "static") ? e : t || Of(i) || e;
}
function ys(i) {
  return ["top", "bottom"].indexOf(i) >= 0 ? "x" : "y";
}
function oi(i, e, t) {
  return Sr(i, Wi(e, t));
}
function Pf(i, e, t) {
  var r = oi(i, e, t);
  return r > t ? t : r;
}
function nl() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function sl(i) {
  return Object.assign({}, nl(), i);
}
function ol(i, e) {
  return e.reduce(function(t, r) {
    return t[r] = i, t;
  }, {});
}
var Mf = function(i, e) {
  return i = typeof i == "function" ? i(Object.assign({}, e.rects, { placement: e.placement })) : i, sl(typeof i != "number" ? i : ol(i, _i));
};
function Bf(i) {
  var e, t = i.state, r = i.name, n = i.options, s = t.elements.arrow, o = t.modifiersData.popperOffsets, a = Jt(t.placement), l = ys(a), u = [xt, Dt].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!s || !o)) {
    var d = Mf(n.padding, t), h = vs(s), p = l === "y" ? _t : xt, f = l === "y" ? kt : Dt, g = t.rects.reference[c] + t.rects.reference[l] - o[l] - t.rects.popper[c], m = o[l] - t.rects.reference[l], v = Si(s), E = v ? l === "y" ? v.clientHeight || 0 : v.clientWidth || 0 : 0, A = g / 2 - m / 2, _ = d[p], y = E - h[c] - d[f], S = E / 2 - h[c] / 2 + A, b = oi(_, S, y), w = l;
    t.modifiersData[r] = (e = {}, e[w] = b, e.centerOffset = b - S, e);
  }
}
function Ff(i) {
  var e = i.state, t = i.options, r = t.element, n = r === void 0 ? "[data-popper-arrow]" : r;
  n != null && (typeof n == "string" && (n = e.elements.popper.querySelector(n), !n) || !il(e.elements.popper, n) || (e.elements.arrow = n));
}
var Nf = { name: "arrow", enabled: !0, phase: "main", fn: Bf, effect: Ff, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function zr(i) {
  return i.split("-")[1];
}
var Uf = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function Kf(i) {
  var e = i.x, t = i.y, r = window, n = r.devicePixelRatio || 1;
  return { x: Jr(e * n) / n || 0, y: Jr(t * n) / n || 0 };
}
function yo(i) {
  var e, t = i.popper, r = i.popperRect, n = i.placement, s = i.variation, o = i.offsets, a = i.position, l = i.gpuAcceleration, u = i.adaptive, c = i.roundOffsets, d = i.isFixed, h = o.x, p = h === void 0 ? 0 : h, f = o.y, g = f === void 0 ? 0 : f, m = typeof c == "function" ? c({ x: p, y: g }) : { x: p, y: g };
  p = m.x, g = m.y;
  var v = o.hasOwnProperty("x"), E = o.hasOwnProperty("y"), A = xt, _ = _t, y = window;
  if (u) {
    var S = Si(t), b = "clientHeight", w = "clientWidth";
    if (S === Gt(t) && (S = pr(t), nr(S).position !== "static" && a === "absolute" && (b = "scrollHeight", w = "scrollWidth")), S = S, n === _t || (n === xt || n === Dt) && s === gi) {
      _ = kt;
      var P = d && S === y && y.visualViewport ? y.visualViewport.height : S[b];
      g -= P - r.height, g *= l ? 1 : -1;
    }
    if (n === xt || (n === _t || n === kt) && s === gi) {
      A = Dt;
      var C = d && S === y && y.visualViewport ? y.visualViewport.width : S[w];
      p -= C - r.width, p *= l ? 1 : -1;
    }
  }
  var T = Object.assign({ position: a }, u && Uf), x = c === !0 ? Kf({ x: p, y: g }) : { x: p, y: g };
  if (p = x.x, g = x.y, l) {
    var L;
    return Object.assign({}, T, (L = {}, L[_] = E ? "0" : "", L[A] = v ? "0" : "", L.transform = (y.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + g + "px)" : "translate3d(" + p + "px, " + g + "px, 0)", L));
  }
  return Object.assign({}, T, (e = {}, e[_] = E ? g + "px" : "", e[A] = v ? p + "px" : "", e.transform = "", e));
}
function Gf(i) {
  var e = i.state, t = i.options, r = t.gpuAcceleration, n = r === void 0 ? !0 : r, s = t.adaptive, o = s === void 0 ? !0 : s, a = t.roundOffsets, l = a === void 0 ? !0 : a, u = { placement: Jt(e.placement), variation: zr(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: n, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, yo(Object.assign({}, u, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, yo(Object.assign({}, u, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var al = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: Gf, data: {} }, Ti = { passive: !0 };
function Vf(i) {
  var e = i.state, t = i.instance, r = i.options, n = r.scroll, s = n === void 0 ? !0 : n, o = r.resize, a = o === void 0 ? !0 : o, l = Gt(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && u.forEach(function(c) {
    c.addEventListener("scroll", t.update, Ti);
  }), a && l.addEventListener("resize", t.update, Ti), function() {
    s && u.forEach(function(c) {
      c.removeEventListener("scroll", t.update, Ti);
    }), a && l.removeEventListener("resize", t.update, Ti);
  };
}
var ll = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
}, effect: Vf, data: {} }, Hf = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Ui(i) {
  return i.replace(/left|right|bottom|top/g, function(e) {
    return Hf[e];
  });
}
var jf = { start: "end", end: "start" };
function Eo(i) {
  return i.replace(/start|end/g, function(e) {
    return jf[e];
  });
}
function Es(i) {
  var e = Gt(i), t = e.pageXOffset, r = e.pageYOffset;
  return { scrollLeft: t, scrollTop: r };
}
function As(i) {
  return Yr(pr(i)).left + Es(i).scrollLeft;
}
function Wf(i) {
  var e = Gt(i), t = pr(i), r = e.visualViewport, n = t.clientWidth, s = t.clientHeight, o = 0, a = 0;
  return r && (n = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), { width: n, height: s, x: o + As(i), y: a };
}
function Qf(i) {
  var e, t = pr(i), r = Es(i), n = (e = i.ownerDocument) == null ? void 0 : e.body, s = Sr(t.scrollWidth, t.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = Sr(t.scrollHeight, t.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -r.scrollLeft + As(i), l = -r.scrollTop;
  return nr(n || t).direction === "rtl" && (a += Sr(t.clientWidth, n ? n.clientWidth : 0) - s), { width: s, height: o, x: a, y: l };
}
function _s(i) {
  var e = nr(i), t = e.overflow, r = e.overflowX, n = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + n + r);
}
function ul(i) {
  return ["html", "body", "#document"].indexOf(zt(i)) >= 0 ? i.ownerDocument.body : wt(i) && _s(i) ? i : ul(on(i));
}
function ai(i, e) {
  var t;
  e === void 0 && (e = []);
  var r = ul(i), n = r === ((t = i.ownerDocument) == null ? void 0 : t.body), s = Gt(r), o = n ? [s].concat(s.visualViewport || [], _s(r) ? r : []) : r, a = e.concat(o);
  return n ? a : a.concat(ai(on(o)));
}
function qn(i) {
  return Object.assign({}, i, { left: i.x, top: i.y, right: i.x + i.width, bottom: i.y + i.height });
}
function Jf(i) {
  var e = Yr(i);
  return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e;
}
function Ao(i, e) {
  return e === tl ? qn(Wf(i)) : Qr(e) ? Jf(e) : qn(Qf(pr(i)));
}
function Yf(i) {
  var e = ai(on(i)), t = ["absolute", "fixed"].indexOf(nr(i).position) >= 0, r = t && wt(i) ? Si(i) : i;
  return Qr(r) ? e.filter(function(n) {
    return Qr(n) && il(n, r) && zt(n) !== "body";
  }) : [];
}
function zf(i, e, t) {
  var r = e === "clippingParents" ? Yf(i) : [].concat(e), n = [].concat(r, [t]), s = n[0], o = n.reduce(function(a, l) {
    var u = Ao(i, l);
    return a.top = Sr(u.top, a.top), a.right = Wi(u.right, a.right), a.bottom = Wi(u.bottom, a.bottom), a.left = Sr(u.left, a.left), a;
  }, Ao(i, s));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function cl(i) {
  var e = i.reference, t = i.element, r = i.placement, n = r ? Jt(r) : null, s = r ? zr(r) : null, o = e.x + e.width / 2 - t.width / 2, a = e.y + e.height / 2 - t.height / 2, l;
  switch (n) {
    case _t:
      l = { x: o, y: e.y - t.height };
      break;
    case kt:
      l = { x: o, y: e.y + e.height };
      break;
    case Dt:
      l = { x: e.x + e.width, y: a };
      break;
    case xt:
      l = { x: e.x - t.width, y: a };
      break;
    default:
      l = { x: e.x, y: e.y };
  }
  var u = n ? ys(n) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (s) {
      case Wr:
        l[u] = l[u] - (e[c] / 2 - t[c] / 2);
        break;
      case gi:
        l[u] = l[u] + (e[c] / 2 - t[c] / 2);
        break;
    }
  }
  return l;
}
function mi(i, e) {
  e === void 0 && (e = {});
  var t = e, r = t.placement, n = r === void 0 ? i.placement : r, s = t.boundary, o = s === void 0 ? yf : s, a = t.rootBoundary, l = a === void 0 ? tl : a, u = t.elementContext, c = u === void 0 ? ei : u, d = t.altBoundary, h = d === void 0 ? !1 : d, p = t.padding, f = p === void 0 ? 0 : p, g = sl(typeof f != "number" ? f : ol(f, _i)), m = c === ei ? Ef : ei, v = i.rects.popper, E = i.elements[h ? m : c], A = zf(Qr(E) ? E : E.contextElement || pr(i.elements.popper), o, l), _ = Yr(i.elements.reference), y = cl({ reference: _, element: v, strategy: "absolute", placement: n }), S = qn(Object.assign({}, v, y)), b = c === ei ? S : _, w = { top: A.top - b.top + g.top, bottom: b.bottom - A.bottom + g.bottom, left: A.left - b.left + g.left, right: b.right - A.right + g.right }, P = i.modifiersData.offset;
  if (c === ei && P) {
    var C = P[n];
    Object.keys(w).forEach(function(T) {
      var x = [Dt, kt].indexOf(T) >= 0 ? 1 : -1, L = [_t, kt].indexOf(T) >= 0 ? "y" : "x";
      w[T] += C[L] * x;
    });
  }
  return w;
}
function qf(i, e) {
  e === void 0 && (e = {});
  var t = e, r = t.placement, n = t.boundary, s = t.rootBoundary, o = t.padding, a = t.flipVariations, l = t.allowedAutoPlacements, u = l === void 0 ? xi : l, c = zr(r), d = c ? a ? mo : mo.filter(function(f) {
    return zr(f) === c;
  }) : _i, h = d.filter(function(f) {
    return u.indexOf(f) >= 0;
  });
  h.length === 0 && (h = d);
  var p = h.reduce(function(f, g) {
    return f[g] = mi(i, { placement: g, boundary: n, rootBoundary: s, padding: o })[Jt(g)], f;
  }, {});
  return Object.keys(p).sort(function(f, g) {
    return p[f] - p[g];
  });
}
function Zf(i) {
  if (Jt(i) === gs)
    return [];
  var e = Ui(i);
  return [Eo(i), e, Eo(e)];
}
function Xf(i) {
  var e = i.state, t = i.options, r = i.name;
  if (!e.modifiersData[r]._skip) {
    for (var n = t.mainAxis, s = n === void 0 ? !0 : n, o = t.altAxis, a = o === void 0 ? !0 : o, l = t.fallbackPlacements, u = t.padding, c = t.boundary, d = t.rootBoundary, h = t.altBoundary, p = t.flipVariations, f = p === void 0 ? !0 : p, g = t.allowedAutoPlacements, m = e.options.placement, v = Jt(m), E = v === m, A = l || (E || !f ? [Ui(m)] : Zf(m)), _ = [m].concat(A).reduce(function(j, ee) {
      return j.concat(Jt(ee) === gs ? qf(e, { placement: ee, boundary: c, rootBoundary: d, padding: u, flipVariations: f, allowedAutoPlacements: g }) : ee);
    }, []), y = e.rects.reference, S = e.rects.popper, b = /* @__PURE__ */ new Map(), w = !0, P = _[0], C = 0; C < _.length; C++) {
      var T = _[C], x = Jt(T), L = zr(T) === Wr, I = [_t, kt].indexOf(x) >= 0, R = I ? "width" : "height", B = mi(e, { placement: T, boundary: c, rootBoundary: d, altBoundary: h, padding: u }), D = I ? L ? Dt : xt : L ? kt : _t;
      y[R] > S[R] && (D = Ui(D));
      var k = Ui(D), F = [];
      if (s && F.push(B[x] <= 0), a && F.push(B[D] <= 0, B[k] <= 0), F.every(function(j) {
        return j;
      })) {
        P = T, w = !1;
        break;
      }
      b.set(T, F);
    }
    if (w)
      for (var U = f ? 3 : 1, G = function(j) {
        var ee = _.find(function(Y) {
          var te = b.get(Y);
          if (te)
            return te.slice(0, j).every(function(oe) {
              return oe;
            });
        });
        if (ee)
          return P = ee, "break";
      }, N = U; N > 0; N--) {
        var V = G(N);
        if (V === "break")
          break;
      }
    e.placement !== P && (e.modifiersData[r]._skip = !0, e.placement = P, e.reset = !0);
  }
}
var $f = { name: "flip", enabled: !0, phase: "main", fn: Xf, requiresIfExists: ["offset"], data: { _skip: !1 } };
function _o(i, e, t) {
  return t === void 0 && (t = { x: 0, y: 0 }), { top: i.top - e.height - t.y, right: i.right - e.width + t.x, bottom: i.bottom - e.height + t.y, left: i.left - e.width - t.x };
}
function xo(i) {
  return [_t, Dt, kt, xt].some(function(e) {
    return i[e] >= 0;
  });
}
function e0(i) {
  var e = i.state, t = i.name, r = e.rects.reference, n = e.rects.popper, s = e.modifiersData.preventOverflow, o = mi(e, { elementContext: "reference" }), a = mi(e, { altBoundary: !0 }), l = _o(o, r), u = _o(a, n, s), c = xo(l), d = xo(u);
  e.modifiersData[t] = { referenceClippingOffsets: l, popperEscapeOffsets: u, isReferenceHidden: c, hasPopperEscaped: d }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": c, "data-popper-escaped": d });
}
var t0 = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: e0 };
function r0(i, e, t) {
  var r = Jt(i), n = [xt, _t].indexOf(r) >= 0 ? -1 : 1, s = typeof t == "function" ? t(Object.assign({}, e, { placement: i })) : t, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * n, [xt, Dt].indexOf(r) >= 0 ? { x: a, y: o } : { x: o, y: a };
}
function i0(i) {
  var e = i.state, t = i.options, r = i.name, n = t.offset, s = n === void 0 ? [0, 0] : n, o = xi.reduce(function(c, d) {
    return c[d] = r0(d, e.rects, s), c;
  }, {}), a = o[e.placement], l = a.x, u = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = o;
}
var n0 = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: i0 };
function s0(i) {
  var e = i.state, t = i.name;
  e.modifiersData[t] = cl({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var dl = { name: "popperOffsets", enabled: !0, phase: "read", fn: s0, data: {} };
function o0(i) {
  return i === "x" ? "y" : "x";
}
function a0(i) {
  var e = i.state, t = i.options, r = i.name, n = t.mainAxis, s = n === void 0 ? !0 : n, o = t.altAxis, a = o === void 0 ? !1 : o, l = t.boundary, u = t.rootBoundary, c = t.altBoundary, d = t.padding, h = t.tether, p = h === void 0 ? !0 : h, f = t.tetherOffset, g = f === void 0 ? 0 : f, m = mi(e, { boundary: l, rootBoundary: u, padding: d, altBoundary: c }), v = Jt(e.placement), E = zr(e.placement), A = !E, _ = ys(v), y = o0(_), S = e.modifiersData.popperOffsets, b = e.rects.reference, w = e.rects.popper, P = typeof g == "function" ? g(Object.assign({}, e.rects, { placement: e.placement })) : g, C = typeof P == "number" ? { mainAxis: P, altAxis: P } : Object.assign({ mainAxis: 0, altAxis: 0 }, P), T = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, x = { x: 0, y: 0 };
  if (S) {
    if (s) {
      var L, I = _ === "y" ? _t : xt, R = _ === "y" ? kt : Dt, B = _ === "y" ? "height" : "width", D = S[_], k = D + m[I], F = D - m[R], U = p ? -w[B] / 2 : 0, G = E === Wr ? b[B] : w[B], N = E === Wr ? -w[B] : -b[B], V = e.elements.arrow, j = p && V ? vs(V) : { width: 0, height: 0 }, ee = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : nl(), Y = ee[I], te = ee[R], oe = oi(0, b[B], j[B]), pe = A ? b[B] / 2 - U - oe - Y - C.mainAxis : G - oe - Y - C.mainAxis, ae = A ? -b[B] / 2 + U + oe + te + C.mainAxis : N + oe + te + C.mainAxis, Ie = e.elements.arrow && Si(e.elements.arrow), ce = Ie ? _ === "y" ? Ie.clientTop || 0 : Ie.clientLeft || 0 : 0, ie = (L = T == null ? void 0 : T[_]) != null ? L : 0, Ae = D + pe - ie - ce, we = D + ae - ie, Ve = oi(p ? Wi(k, Ae) : k, D, p ? Sr(F, we) : F);
      S[_] = Ve, x[_] = Ve - D;
    }
    if (a) {
      var He, Ge = _ === "x" ? _t : xt, Me = _ === "x" ? kt : Dt, be = S[y], Ne = y === "y" ? "height" : "width", Ue = be + m[Ge], tt = be - m[Me], Z = [_t, xt].indexOf(v) !== -1, Le = (He = T == null ? void 0 : T[y]) != null ? He : 0, Je = Z ? Ue : be - b[Ne] - w[Ne] - Le + C.altAxis, ft = Z ? be + b[Ne] + w[Ne] - Le - C.altAxis : tt, Ye = p && Z ? Pf(Je, be, ft) : oi(p ? Je : Ue, be, p ? ft : tt);
      S[y] = Ye, x[y] = Ye - be;
    }
    e.modifiersData[r] = x;
  }
}
var l0 = { name: "preventOverflow", enabled: !0, phase: "main", fn: a0, requiresIfExists: ["offset"] };
function u0(i) {
  return { scrollLeft: i.scrollLeft, scrollTop: i.scrollTop };
}
function c0(i) {
  return i === Gt(i) || !wt(i) ? Es(i) : u0(i);
}
function d0(i) {
  var e = i.getBoundingClientRect(), t = Jr(e.width) / i.offsetWidth || 1, r = Jr(e.height) / i.offsetHeight || 1;
  return t !== 1 || r !== 1;
}
function h0(i, e, t) {
  t === void 0 && (t = !1);
  var r = wt(e), n = wt(e) && d0(e), s = pr(e), o = Yr(i, n), a = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 };
  return (r || !r && !t) && ((zt(e) !== "body" || _s(s)) && (a = c0(e)), wt(e) ? (l = Yr(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = As(s))), { x: o.left + a.scrollLeft - l.x, y: o.top + a.scrollTop - l.y, width: o.width, height: o.height };
}
function f0(i) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), r = [];
  i.forEach(function(s) {
    e.set(s.name, s);
  });
  function n(s) {
    t.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!t.has(a)) {
        var l = e.get(a);
        l && n(l);
      }
    }), r.push(s);
  }
  return i.forEach(function(s) {
    t.has(s.name) || n(s);
  }), r;
}
function p0(i) {
  var e = f0(i);
  return Rf.reduce(function(t, r) {
    return t.concat(e.filter(function(n) {
      return n.phase === r;
    }));
  }, []);
}
function g0(i) {
  var e;
  return function() {
    return e || (e = new Promise(function(t) {
      Promise.resolve().then(function() {
        e = void 0, t(i());
      });
    })), e;
  };
}
function m0(i) {
  var e = i.reduce(function(t, r) {
    var n = t[r.name];
    return t[r.name] = n ? Object.assign({}, n, r, { options: Object.assign({}, n.options, r.options), data: Object.assign({}, n.data, r.data) }) : r, t;
  }, {});
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}
var So = { placement: "bottom", modifiers: [], strategy: "absolute" };
function To() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
    e[t] = arguments[t];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function xs(i) {
  i === void 0 && (i = {});
  var e = i, t = e.defaultModifiers, r = t === void 0 ? [] : t, n = e.defaultOptions, s = n === void 0 ? So : n;
  return function(o, a, l) {
    l === void 0 && (l = s);
    var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, So, s), modifiersData: {}, elements: { reference: o, popper: a }, attributes: {}, styles: {} }, c = [], d = !1, h = { state: u, setOptions: function(g) {
      var m = typeof g == "function" ? g(u.options) : g;
      f(), u.options = Object.assign({}, s, u.options, m), u.scrollParents = { reference: Qr(o) ? ai(o) : o.contextElement ? ai(o.contextElement) : [], popper: ai(a) };
      var v = p0(m0([].concat(r, u.options.modifiers)));
      return u.orderedModifiers = v.filter(function(E) {
        return E.enabled;
      }), p(), h.update();
    }, forceUpdate: function() {
      if (!d) {
        var g = u.elements, m = g.reference, v = g.popper;
        if (To(m, v)) {
          u.rects = { reference: h0(m, Si(v), u.options.strategy === "fixed"), popper: vs(v) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(w) {
            return u.modifiersData[w.name] = Object.assign({}, w.data);
          });
          for (var E = 0; E < u.orderedModifiers.length; E++) {
            if (u.reset === !0) {
              u.reset = !1, E = -1;
              continue;
            }
            var A = u.orderedModifiers[E], _ = A.fn, y = A.options, S = y === void 0 ? {} : y, b = A.name;
            typeof _ == "function" && (u = _({ state: u, options: S, name: b, instance: h }) || u);
          }
        }
      }
    }, update: g0(function() {
      return new Promise(function(g) {
        h.forceUpdate(), g(u);
      });
    }), destroy: function() {
      f(), d = !0;
    } };
    if (!To(o, a))
      return h;
    h.setOptions(l).then(function(g) {
      !d && l.onFirstUpdate && l.onFirstUpdate(g);
    });
    function p() {
      u.orderedModifiers.forEach(function(g) {
        var m = g.name, v = g.options, E = v === void 0 ? {} : v, A = g.effect;
        if (typeof A == "function") {
          var _ = A({ state: u, name: m, instance: h, options: E }), y = function() {
          };
          c.push(_ || y);
        }
      });
    }
    function f() {
      c.forEach(function(g) {
        return g();
      }), c = [];
    }
    return h;
  };
}
xs();
var v0 = [ll, dl, al, rl];
xs({ defaultModifiers: v0 });
var y0 = [ll, dl, al, rl, n0, $f, l0, Nf, t0], E0 = xs({ defaultModifiers: y0 });
const A0 = (i, e, t = {}) => {
  const r = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: l }) => {
      const u = _0(l);
      Object.assign(o.value, u);
    },
    requires: ["computeStyles"]
  }, n = J(() => {
    const { onFirstUpdate: l, placement: u, strategy: c, modifiers: d } = M(t);
    return {
      onFirstUpdate: l,
      placement: u || "bottom",
      strategy: c || "absolute",
      modifiers: [
        ...d || [],
        r,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), s = ni(), o = q({
    styles: {
      popper: {
        position: M(n).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = () => {
    s.value && (s.value.destroy(), s.value = void 0);
  };
  return Re(n, (l) => {
    const u = M(s);
    u && u.setOptions(l);
  }, {
    deep: !0
  }), Re([i, e], ([l, u]) => {
    a(), !(!l || !u) && (s.value = E0(l, u, M(n)));
  }), qt(() => {
    a();
  }), {
    state: J(() => {
      var l;
      return { ...((l = M(s)) == null ? void 0 : l.state) || {} };
    }),
    styles: J(() => M(o).styles),
    attributes: J(() => M(o).attributes),
    update: () => {
      var l;
      return (l = M(s)) == null ? void 0 : l.update();
    },
    forceUpdate: () => {
      var l;
      return (l = M(s)) == null ? void 0 : l.forceUpdate();
    },
    instanceRef: J(() => M(s))
  };
};
function _0(i) {
  const e = Object.keys(i.elements), t = Hi(e.map((n) => [n, i.styles[n] || {}])), r = Hi(e.map((n) => [n, i.attributes[n]]));
  return {
    styles: t,
    attributes: r
  };
}
function Io() {
  let i;
  const e = (r, n) => {
    t(), i = window.setTimeout(r, n);
  }, t = () => window.clearTimeout(i);
  return us(() => t()), {
    registerTimeout: e,
    cancelTimeout: t
  };
}
const Zn = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, x0 = Symbol("elIdInjection"), hl = () => qr() ? $e(x0, Zn) : Zn, fl = (i) => {
  const e = hl();
  !Rt && e === Zn && lt("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const t = ps();
  return J(() => M(i) || `${t.value}-id-${e.prefix}-${e.current++}`);
};
let Fr = [];
const bo = (i) => {
  const e = i;
  e.key === pi.esc && Fr.forEach((t) => t(e));
}, S0 = (i) => {
  ht(() => {
    Fr.length === 0 && document.addEventListener("keydown", bo), Rt && Fr.push(i);
  }), qt(() => {
    Fr = Fr.filter((e) => e !== i), Fr.length === 0 && Rt && document.removeEventListener("keydown", bo);
  });
};
let Lo;
const pl = () => {
  const i = ps(), e = hl(), t = J(() => `${i.value}-popper-container-${e.prefix}`), r = J(() => `#${t.value}`);
  return {
    id: t,
    selector: r
  };
}, T0 = (i) => {
  const e = document.createElement("div");
  return e.id = i, document.body.appendChild(e), e;
}, I0 = () => {
  const { id: i, selector: e } = pl();
  return Du(() => {
    Rt && (process.env.NODE_ENV === "test" || !Lo && !document.body.querySelector(e.value)) && (Lo = T0(i.value));
  }), {
    id: i,
    selector: e
  };
}, b0 = Xe({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), L0 = ({
  showAfter: i,
  hideAfter: e,
  autoClose: t,
  open: r,
  close: n
}) => {
  const { registerTimeout: s } = Io(), {
    registerTimeout: o,
    cancelTimeout: a
  } = Io();
  return {
    onOpen: (c) => {
      s(() => {
        r(c);
        const d = M(t);
        ze(d) && d > 0 && o(() => {
          n(c);
        }, d);
      }, M(i));
    },
    onClose: (c) => {
      a(), s(() => {
        n(c);
      }, M(e));
    }
  };
}, gl = Symbol("elForwardRef"), C0 = (i) => {
  ir(gl, {
    setForwardRef: (t) => {
      i.value = t;
    }
  });
}, R0 = (i) => ({
  mounted(e) {
    i(e);
  },
  updated(e) {
    i(e);
  },
  unmounted() {
    i(null);
  }
}), Co = q(0), w0 = 2e3, k0 = Symbol("zIndexContextKey"), D0 = (i) => {
  const e = i || $e(k0, void 0), t = J(() => {
    const s = M(e);
    return ze(s) ? s : w0;
  }), r = J(() => t.value + Co.value);
  return {
    initialZIndex: t,
    currentZIndex: r,
    nextZIndex: () => (Co.value++, r.value)
  };
};
function O0(i) {
  const e = q();
  function t() {
    if (i.value == null)
      return;
    const { selectionStart: n, selectionEnd: s, value: o } = i.value;
    if (n == null || s == null)
      return;
    const a = o.slice(0, Math.max(0, n)), l = o.slice(Math.max(0, s));
    e.value = {
      selectionStart: n,
      selectionEnd: s,
      value: o,
      beforeTxt: a,
      afterTxt: l
    };
  }
  function r() {
    if (i.value == null || e.value == null)
      return;
    const { value: n } = i.value, { beforeTxt: s, afterTxt: o, selectionStart: a } = e.value;
    if (s == null || o == null || a == null)
      return;
    let l = n.length;
    if (n.endsWith(o))
      l = n.length - o.length;
    else if (n.startsWith(s))
      l = s.length;
    else {
      const u = s[a - 1], c = n.indexOf(u, a - 1);
      c !== -1 && (l = c + 1);
    }
    i.value.setSelectionRange(l, l);
  }
  return [t, r];
}
const Qi = sn({
  type: String,
  values: Za,
  required: !1
}), P0 = Symbol("size"), M0 = () => {
  const i = $e(P0, {});
  return J(() => M(i.size) || "");
};
var ut = (i, e) => {
  const t = i.__vccOpts || i;
  for (const [r, n] of e)
    t[r] = n;
  return t;
};
const B0 = Xe({
  size: {
    type: Te([Number, String])
  },
  color: {
    type: String
  }
}), F0 = De({
  name: "ElIcon",
  inheritAttrs: !1
}), N0 = /* @__PURE__ */ De({
  ...F0,
  props: B0,
  setup(i) {
    const e = i, t = St("icon"), r = J(() => {
      const { size: n, color: s } = e;
      return !n && !s ? {} : {
        fontSize: ii(n) ? void 0 : fs(n),
        "--color": s
      };
    });
    return (n, s) => (X(), le("i", hr({
      class: M(t).b(),
      style: M(r)
    }, n.$attrs), [
      it(n.$slots, "default")
    ], 16));
  }
});
var U0 = /* @__PURE__ */ ut(N0, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const Ut = fr(U0), Ss = Symbol("formContextKey"), Ji = Symbol("formItemContextKey"), an = (i, e = {}) => {
  const t = q(void 0), r = e.prop ? t : el("size"), n = e.global ? t : M0(), s = e.form ? { size: void 0 } : $e(Ss, void 0), o = e.formItem ? { size: void 0 } : $e(Ji, void 0);
  return J(() => r.value || M(i) || (o == null ? void 0 : o.size) || (s == null ? void 0 : s.size) || n.value || "");
}, Ts = (i) => {
  const e = el("disabled"), t = $e(Ss, void 0);
  return J(() => e.value || M(i) || (t == null ? void 0 : t.disabled) || !1);
}, ln = () => {
  const i = $e(Ss, void 0), e = $e(Ji, void 0);
  return {
    form: i,
    formItem: e
  };
}, Is = (i, {
  formItemContext: e,
  disableIdGeneration: t,
  disableIdManagement: r
}) => {
  t || (t = q(!1)), r || (r = q(!1));
  const n = q();
  let s;
  const o = J(() => {
    var a;
    return !!(!i.label && e && e.inputIds && ((a = e.inputIds) == null ? void 0 : a.length) <= 1);
  });
  return ht(() => {
    s = Re([Ar(i, "id"), t], ([a, l]) => {
      const u = a ?? (l ? void 0 : fl().value);
      u !== n.value && (e != null && e.removeInputId && (n.value && e.removeInputId(n.value), !(r != null && r.value) && !l && u && e.addInputId(u)), n.value = u);
    }, { immediate: !0 });
  }), Ba(() => {
    s && s(), e != null && e.removeInputId && n.value && e.removeInputId(n.value);
  }), {
    isLabeledByFormItem: o,
    inputId: n
  };
};
let Pt;
const K0 = `
  height:0 !important;
  visibility:hidden !important;
  ${ac() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, G0 = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function V0(i) {
  const e = window.getComputedStyle(i), t = e.getPropertyValue("box-sizing"), r = Number.parseFloat(e.getPropertyValue("padding-bottom")) + Number.parseFloat(e.getPropertyValue("padding-top")), n = Number.parseFloat(e.getPropertyValue("border-bottom-width")) + Number.parseFloat(e.getPropertyValue("border-top-width"));
  return { contextStyle: G0.map((o) => `${o}:${e.getPropertyValue(o)}`).join(";"), paddingSize: r, borderSize: n, boxSizing: t };
}
function Ro(i, e = 1, t) {
  var r;
  Pt || (Pt = document.createElement("textarea"), document.body.appendChild(Pt));
  const { paddingSize: n, borderSize: s, boxSizing: o, contextStyle: a } = V0(i);
  Pt.setAttribute("style", `${a};${K0}`), Pt.value = i.value || i.placeholder || "";
  let l = Pt.scrollHeight;
  const u = {};
  o === "border-box" ? l = l + s : o === "content-box" && (l = l - n), Pt.value = "";
  const c = Pt.scrollHeight - n;
  if (ze(e)) {
    let d = c * e;
    o === "border-box" && (d = d + n + s), l = Math.max(d, l), u.minHeight = `${d}px`;
  }
  if (ze(t)) {
    let d = c * t;
    o === "border-box" && (d = d + n + s), l = Math.min(d, l);
  }
  return u.height = `${l}px`, (r = Pt.parentNode) == null || r.removeChild(Pt), Pt = void 0, u;
}
const H0 = Xe({
  id: {
    type: String,
    default: void 0
  },
  size: Qi,
  disabled: Boolean,
  modelValue: {
    type: Te([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: Te([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: fi
  },
  prefixIcon: {
    type: fi
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: Te([Object, Array, String]),
    default: () => nf({})
  }
}), j0 = {
  [dt]: (i) => It(i),
  input: (i) => It(i),
  change: (i) => It(i),
  focus: (i) => i instanceof FocusEvent,
  blur: (i) => i instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (i) => i instanceof MouseEvent,
  mouseenter: (i) => i instanceof MouseEvent,
  keydown: (i) => i instanceof Event,
  compositionstart: (i) => i instanceof CompositionEvent,
  compositionupdate: (i) => i instanceof CompositionEvent,
  compositionend: (i) => i instanceof CompositionEvent
}, W0 = ["role"], Q0 = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form"], J0 = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form"], Y0 = De({
  name: "ElInput",
  inheritAttrs: !1
}), z0 = /* @__PURE__ */ De({
  ...Y0,
  props: H0,
  emits: j0,
  setup(i, { expose: e, emit: t }) {
    const r = i, n = Ou(), s = Pu(), o = J(() => {
      const Z = {};
      return r.containerRole === "combobox" && (Z["aria-haspopup"] = n["aria-haspopup"], Z["aria-owns"] = n["aria-owns"], Z["aria-expanded"] = n["aria-expanded"]), Z;
    }), a = J(() => [
      r.type === "textarea" ? m.b() : g.b(),
      g.m(p.value),
      g.is("disabled", f.value),
      g.is("exceed", G.value),
      {
        [g.b("group")]: s.prepend || s.append,
        [g.bm("group", "append")]: s.append,
        [g.bm("group", "prepend")]: s.prepend,
        [g.m("prefix")]: s.prefix || r.prefixIcon,
        [g.m("suffix")]: s.suffix || r.suffixIcon || r.clearable || r.showPassword,
        [g.bm("suffix", "password-clear")]: D.value && k.value
      },
      n.class
    ]), l = J(() => [
      g.e("wrapper"),
      g.is("focus", A.value)
    ]), u = af({
      excludeKeys: J(() => Object.keys(o.value))
    }), { form: c, formItem: d } = ln(), { inputId: h } = Is(r, {
      formItemContext: d
    }), p = an(), f = Ts(), g = St("input"), m = St("textarea"), v = ni(), E = ni(), A = q(!1), _ = q(!1), y = q(!1), S = q(!1), b = q(), w = ni(r.inputStyle), P = J(() => v.value || E.value), C = J(() => {
      var Z;
      return (Z = c == null ? void 0 : c.statusIcon) != null ? Z : !1;
    }), T = J(() => (d == null ? void 0 : d.validateState) || ""), x = J(() => T.value && $h[T.value]), L = J(() => S.value ? Zh : Ch), I = J(() => [
      n.style,
      r.inputStyle
    ]), R = J(() => [
      r.inputStyle,
      w.value,
      { resize: r.resize }
    ]), B = J(() => rr(r.modelValue) ? "" : String(r.modelValue)), D = J(() => r.clearable && !f.value && !r.readonly && !!B.value && (A.value || _.value)), k = J(() => r.showPassword && !f.value && !r.readonly && !!B.value && (!!B.value || A.value)), F = J(() => r.showWordLimit && !!u.value.maxlength && (r.type === "text" || r.type === "textarea") && !f.value && !r.readonly && !r.showPassword), U = J(() => B.value.length), G = J(() => !!F.value && U.value > Number(u.value.maxlength)), N = J(() => !!s.suffix || !!r.suffixIcon || D.value || r.showPassword || F.value || !!T.value && C.value), [V, j] = O0(v);
    tc(E, (Z) => {
      if (te(), !F.value || r.resize !== "both")
        return;
      const Le = Z[0], { width: Je } = Le.contentRect;
      b.value = {
        right: `calc(100% - ${Je + 15 + 6}px)`
      };
    });
    const ee = () => {
      const { type: Z, autosize: Le } = r;
      if (!(!Rt || Z !== "textarea" || !E.value))
        if (Le) {
          const Je = Hr(Le) ? Le.minRows : void 0, ft = Hr(Le) ? Le.maxRows : void 0, Ye = Ro(E.value, Je, ft);
          w.value = {
            overflowY: "hidden",
            ...Ye
          }, ct(() => {
            E.value.offsetHeight, w.value = Ye;
          });
        } else
          w.value = {
            minHeight: Ro(E.value).minHeight
          };
    }, te = ((Z) => {
      let Le = !1;
      return () => {
        var Je;
        if (Le || !r.autosize)
          return;
        ((Je = E.value) == null ? void 0 : Je.offsetParent) === null || (Z(), Le = !0);
      };
    })(ee), oe = () => {
      const Z = P.value;
      !Z || Z.value === B.value || (Z.value = B.value);
    }, pe = async (Z) => {
      V();
      let { value: Le } = Z.target;
      if (r.formatter && (Le = r.parser ? r.parser(Le) : Le, Le = r.formatter(Le)), !y.value) {
        if (Le === B.value) {
          oe();
          return;
        }
        t(dt, Le), t("input", Le), await ct(), oe(), j();
      }
    }, ae = (Z) => {
      t("change", Z.target.value);
    }, Ie = (Z) => {
      t("compositionstart", Z), y.value = !0;
    }, ce = (Z) => {
      var Le;
      t("compositionupdate", Z);
      const Je = (Le = Z.target) == null ? void 0 : Le.value, ft = Je[Je.length - 1] || "";
      y.value = !rf(ft);
    }, ie = (Z) => {
      t("compositionend", Z), y.value && (y.value = !1, pe(Z));
    }, Ae = () => {
      S.value = !S.value, we();
    }, we = async () => {
      var Z;
      await ct(), (Z = P.value) == null || Z.focus();
    }, Ve = () => {
      var Z;
      return (Z = P.value) == null ? void 0 : Z.blur();
    }, He = (Z) => {
      A.value = !0, t("focus", Z);
    }, Ge = (Z) => {
      var Le;
      A.value = !1, t("blur", Z), r.validateEvent && ((Le = d == null ? void 0 : d.validate) == null || Le.call(d, "blur").catch((Je) => lt(Je)));
    }, Me = (Z) => {
      _.value = !1, t("mouseleave", Z);
    }, be = (Z) => {
      _.value = !0, t("mouseenter", Z);
    }, Ne = (Z) => {
      t("keydown", Z);
    }, Ue = () => {
      var Z;
      (Z = P.value) == null || Z.select();
    }, tt = () => {
      t(dt, ""), t("change", ""), t("clear"), t("input", "");
    };
    return Re(() => r.modelValue, () => {
      var Z;
      ct(() => ee()), r.validateEvent && ((Z = d == null ? void 0 : d.validate) == null || Z.call(d, "change").catch((Le) => lt(Le)));
    }), Re(B, () => oe()), Re(() => r.type, async () => {
      await ct(), oe(), ee();
    }), ht(() => {
      !r.formatter && r.parser && lt("ElInput", "If you set the parser, you also need to set the formatter."), oe(), ct(ee);
    }), e({
      input: v,
      textarea: E,
      ref: P,
      textareaStyle: R,
      autosize: Ar(r, "autosize"),
      focus: we,
      blur: Ve,
      select: Ue,
      clear: tt,
      resizeTextarea: ee
    }), (Z, Le) => jt((X(), le("div", hr(M(o), {
      class: M(a),
      style: M(I),
      role: Z.containerRole,
      onMouseenter: be,
      onMouseleave: Me
    }), [
      ye(" input "),
      Z.type !== "textarea" ? (X(), le(Wt, { key: 0 }, [
        ye(" prepend slot "),
        Z.$slots.prepend ? (X(), le("div", {
          key: 0,
          class: Ee(M(g).be("group", "prepend"))
        }, [
          it(Z.$slots, "prepend")
        ], 2)) : ye("v-if", !0),
        se("div", {
          class: Ee(M(l))
        }, [
          ye(" prefix slot "),
          Z.$slots.prefix || Z.prefixIcon ? (X(), le("span", {
            key: 0,
            class: Ee(M(g).e("prefix"))
          }, [
            se("span", {
              class: Ee(M(g).e("prefix-inner")),
              onClick: we
            }, [
              it(Z.$slots, "prefix"),
              Z.prefixIcon ? (X(), ke(M(Ut), {
                key: 0,
                class: Ee(M(g).e("icon"))
              }, {
                default: Ce(() => [
                  (X(), ke(_r(Z.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0)
            ], 2)
          ], 2)) : ye("v-if", !0),
          se("input", hr({
            id: M(h),
            ref_key: "input",
            ref: v,
            class: M(g).e("inner")
          }, M(u), {
            type: Z.showPassword ? S.value ? "text" : "password" : Z.type,
            disabled: M(f),
            formatter: Z.formatter,
            parser: Z.parser,
            readonly: Z.readonly,
            autocomplete: Z.autocomplete,
            tabindex: Z.tabindex,
            "aria-label": Z.label,
            placeholder: Z.placeholder,
            style: Z.inputStyle,
            form: r.form,
            onCompositionstart: Ie,
            onCompositionupdate: ce,
            onCompositionend: ie,
            onInput: pe,
            onFocus: He,
            onBlur: Ge,
            onChange: ae,
            onKeydown: Ne
          }), null, 16, Q0),
          ye(" suffix slot "),
          M(N) ? (X(), le("span", {
            key: 1,
            class: Ee(M(g).e("suffix"))
          }, [
            se("span", {
              class: Ee(M(g).e("suffix-inner")),
              onClick: we
            }, [
              !M(D) || !M(k) || !M(F) ? (X(), le(Wt, { key: 0 }, [
                it(Z.$slots, "suffix"),
                Z.suffixIcon ? (X(), ke(M(Ut), {
                  key: 0,
                  class: Ee(M(g).e("icon"))
                }, {
                  default: Ce(() => [
                    (X(), ke(_r(Z.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : ye("v-if", !0)
              ], 64)) : ye("v-if", !0),
              M(D) ? (X(), ke(M(Ut), {
                key: 1,
                class: Ee([M(g).e("icon"), M(g).e("clear")]),
                onMousedown: Ur(M(Vi), ["prevent"]),
                onClick: tt
              }, {
                default: Ce(() => [
                  Ze(M(Ya))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : ye("v-if", !0),
              M(k) ? (X(), ke(M(Ut), {
                key: 2,
                class: Ee([M(g).e("icon"), M(g).e("password")]),
                onClick: Ae
              }, {
                default: Ce(() => [
                  (X(), ke(_r(M(L))))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0),
              M(F) ? (X(), le("span", {
                key: 3,
                class: Ee(M(g).e("count"))
              }, [
                se("span", {
                  class: Ee(M(g).e("count-inner"))
                }, gt(M(U)) + " / " + gt(M(u).maxlength), 3)
              ], 2)) : ye("v-if", !0),
              M(T) && M(x) && M(C) ? (X(), ke(M(Ut), {
                key: 4,
                class: Ee([
                  M(g).e("icon"),
                  M(g).e("validateIcon"),
                  M(g).is("loading", M(T) === "validating")
                ])
              }, {
                default: Ce(() => [
                  (X(), ke(_r(M(x))))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0)
            ], 2)
          ], 2)) : ye("v-if", !0)
        ], 2),
        ye(" append slot "),
        Z.$slots.append ? (X(), le("div", {
          key: 1,
          class: Ee(M(g).be("group", "append"))
        }, [
          it(Z.$slots, "append")
        ], 2)) : ye("v-if", !0)
      ], 64)) : (X(), le(Wt, { key: 1 }, [
        ye(" textarea "),
        se("textarea", hr({
          id: M(h),
          ref_key: "textarea",
          ref: E,
          class: M(m).e("inner")
        }, M(u), {
          tabindex: Z.tabindex,
          disabled: M(f),
          readonly: Z.readonly,
          autocomplete: Z.autocomplete,
          style: M(R),
          "aria-label": Z.label,
          placeholder: Z.placeholder,
          form: r.form,
          onCompositionstart: Ie,
          onCompositionupdate: ce,
          onCompositionend: ie,
          onInput: pe,
          onFocus: He,
          onBlur: Ge,
          onChange: ae,
          onKeydown: Ne
        }), null, 16, J0),
        M(F) ? (X(), le("span", {
          key: 0,
          style: Nt(b.value),
          class: Ee(M(g).e("count"))
        }, gt(M(U)) + " / " + gt(M(u).maxlength), 7)) : ye("v-if", !0)
      ], 64))
    ], 16, W0)), [
      [Er, Z.type !== "hidden"]
    ]);
  }
});
var q0 = /* @__PURE__ */ ut(z0, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const Z0 = fr(q0), bs = Symbol("popper"), ml = Symbol("popperContent"), X0 = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], vl = Xe({
  role: {
    type: String,
    values: X0,
    default: "tooltip"
  }
}), $0 = De({
  name: "ElPopper",
  inheritAttrs: !1
}), ep = /* @__PURE__ */ De({
  ...$0,
  props: vl,
  setup(i, { expose: e }) {
    const t = i, r = q(), n = q(), s = q(), o = q(), a = J(() => t.role), l = {
      triggerRef: r,
      popperInstanceRef: n,
      contentRef: s,
      referenceRef: o,
      role: a
    };
    return e(l), ir(bs, l), (u, c) => it(u.$slots, "default");
  }
});
var tp = /* @__PURE__ */ ut(ep, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const yl = Xe({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), rp = De({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), ip = /* @__PURE__ */ De({
  ...rp,
  props: yl,
  setup(i, { expose: e }) {
    const t = i, r = St("popper"), { arrowOffset: n, arrowRef: s, arrowStyle: o } = $e(ml, void 0);
    return Re(() => t.arrowOffset, (a) => {
      n.value = a;
    }), qt(() => {
      s.value = void 0;
    }), e({
      arrowRef: s
    }), (a, l) => (X(), le("span", {
      ref_key: "arrowRef",
      ref: s,
      class: Ee(M(r).e("arrow")),
      style: Nt(M(o)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var np = /* @__PURE__ */ ut(ip, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const An = "ElOnlyChild", sp = De({
  name: An,
  setup(i, {
    slots: e,
    attrs: t
  }) {
    var r;
    const n = $e(gl), s = R0((r = n == null ? void 0 : n.setForwardRef) != null ? r : Vi);
    return () => {
      var o;
      const a = (o = e.default) == null ? void 0 : o.call(e, t);
      if (!a)
        return null;
      if (a.length > 1)
        return lt(An, "requires exact only one valid child."), null;
      const l = El(a);
      return l ? jt(Mu(l, t), [[s]]) : (lt(An, "no valid child node found"), null);
    };
  }
});
function El(i) {
  if (!i)
    return null;
  const e = i;
  for (const t of e) {
    if (Hr(t))
      switch (t.type) {
        case Fu:
          continue;
        case Bu:
        case "svg":
          return wo(t);
        case Wt:
          return El(t.children);
        default:
          return t;
      }
    return wo(t);
  }
  return null;
}
function wo(i) {
  const e = St("only-child");
  return Ze("span", {
    class: e.e("content")
  }, [i]);
}
const Al = Xe({
  virtualRef: {
    type: Te(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: Te(Function)
  },
  onMouseleave: {
    type: Te(Function)
  },
  onClick: {
    type: Te(Function)
  },
  onKeydown: {
    type: Te(Function)
  },
  onFocus: {
    type: Te(Function)
  },
  onBlur: {
    type: Te(Function)
  },
  onContextmenu: {
    type: Te(Function)
  },
  id: String,
  open: Boolean
}), op = De({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), ap = /* @__PURE__ */ De({
  ...op,
  props: Al,
  setup(i, { expose: e }) {
    const t = i, { role: r, triggerRef: n } = $e(bs, void 0);
    C0(n);
    const s = J(() => a.value ? t.id : void 0), o = J(() => {
      if (r && r.value === "tooltip")
        return t.open && t.id ? t.id : void 0;
    }), a = J(() => {
      if (r && r.value !== "tooltip")
        return r.value;
    }), l = J(() => a.value ? `${t.open}` : void 0);
    let u;
    return ht(() => {
      Re(() => t.virtualRef, (c) => {
        c && (n.value = cr(c));
      }, {
        immediate: !0
      }), Re(n, (c, d) => {
        u == null || u(), u = void 0, ji(c) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((h) => {
          var p;
          const f = t[h];
          f && (c.addEventListener(h.slice(2).toLowerCase(), f), (p = d == null ? void 0 : d.removeEventListener) == null || p.call(d, h.slice(2).toLowerCase(), f));
        }), u = Re([s, o, a, l], (h) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((p, f) => {
            rr(h[f]) ? c.removeAttribute(p) : c.setAttribute(p, h[f]);
          });
        }, { immediate: !0 })), ji(d) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((h) => d.removeAttribute(h));
      }, {
        immediate: !0
      });
    }), qt(() => {
      u == null || u(), u = void 0;
    }), e({
      triggerRef: n
    }), (c, d) => c.virtualTriggering ? ye("v-if", !0) : (X(), ke(M(sp), hr({ key: 0 }, c.$attrs, {
      "aria-controls": M(s),
      "aria-describedby": M(o),
      "aria-expanded": M(l),
      "aria-haspopup": M(a)
    }), {
      default: Ce(() => [
        it(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var lp = /* @__PURE__ */ ut(ap, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
const _n = "focus-trap.focus-after-trapped", xn = "focus-trap.focus-after-released", up = "focus-trap.focusout-prevented", ko = {
  cancelable: !0,
  bubbles: !1
}, cp = {
  cancelable: !0,
  bubbles: !1
}, Do = "focusAfterTrapped", Oo = "focusAfterReleased", dp = Symbol("elFocusTrap"), Ls = q(), un = q(0), Cs = q(0);
let Ii = 0;
const _l = (i) => {
  const e = [], t = document.createTreeWalker(i, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const n = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || n ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 || r === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; t.nextNode(); )
    e.push(t.currentNode);
  return e;
}, Po = (i, e) => {
  for (const t of i)
    if (!hp(t, e))
      return t;
}, hp = (i, e) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(i).visibility === "hidden")
    return !0;
  for (; i; ) {
    if (e && i === e)
      return !1;
    if (getComputedStyle(i).display === "none")
      return !0;
    i = i.parentElement;
  }
  return !1;
}, fp = (i) => {
  const e = _l(i), t = Po(e, i), r = Po(e.reverse(), i);
  return [t, r];
}, pp = (i) => i instanceof HTMLInputElement && "select" in i, ar = (i, e) => {
  if (i && i.focus) {
    const t = document.activeElement;
    i.focus({ preventScroll: !0 }), Cs.value = window.performance.now(), i !== t && pp(i) && e && i.select();
  }
};
function Mo(i, e) {
  const t = [...i], r = i.indexOf(e);
  return r !== -1 && t.splice(r, 1), t;
}
const gp = () => {
  let i = [];
  return {
    push: (r) => {
      const n = i[0];
      n && r !== n && n.pause(), i = Mo(i, r), i.unshift(r);
    },
    remove: (r) => {
      var n, s;
      i = Mo(i, r), (s = (n = i[0]) == null ? void 0 : n.resume) == null || s.call(n);
    }
  };
}, mp = (i, e = !1) => {
  const t = document.activeElement;
  for (const r of i)
    if (ar(r, e), document.activeElement !== t)
      return;
}, Bo = gp(), vp = () => un.value > Cs.value, bi = () => {
  Ls.value = "pointer", un.value = window.performance.now();
}, Fo = () => {
  Ls.value = "keyboard", un.value = window.performance.now();
}, yp = () => (ht(() => {
  Ii === 0 && (document.addEventListener("mousedown", bi), document.addEventListener("touchstart", bi), document.addEventListener("keydown", Fo)), Ii++;
}), qt(() => {
  Ii--, Ii <= 0 && (document.removeEventListener("mousedown", bi), document.removeEventListener("touchstart", bi), document.removeEventListener("keydown", Fo));
}), {
  focusReason: Ls,
  lastUserFocusTimestamp: un,
  lastAutomatedFocusTimestamp: Cs
}), Li = (i) => new CustomEvent(up, {
  ...cp,
  detail: i
}), Ep = De({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    Do,
    Oo,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(i, { emit: e }) {
    const t = q();
    let r, n;
    const { focusReason: s } = yp();
    S0((f) => {
      i.trapped && !o.paused && e("release-requested", f);
    });
    const o = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, a = (f) => {
      if (!i.loop && !i.trapped || o.paused)
        return;
      const { key: g, altKey: m, ctrlKey: v, metaKey: E, currentTarget: A, shiftKey: _ } = f, { loop: y } = i, S = g === pi.tab && !m && !v && !E, b = document.activeElement;
      if (S && b) {
        const w = A, [P, C] = fp(w);
        if (P && C) {
          if (!_ && b === C) {
            const x = Li({
              focusReason: s.value
            });
            e("focusout-prevented", x), x.defaultPrevented || (f.preventDefault(), y && ar(P, !0));
          } else if (_ && [P, w].includes(b)) {
            const x = Li({
              focusReason: s.value
            });
            e("focusout-prevented", x), x.defaultPrevented || (f.preventDefault(), y && ar(C, !0));
          }
        } else if (b === w) {
          const x = Li({
            focusReason: s.value
          });
          e("focusout-prevented", x), x.defaultPrevented || f.preventDefault();
        }
      }
    };
    ir(dp, {
      focusTrapRef: t,
      onKeydown: a
    }), Re(() => i.focusTrapEl, (f) => {
      f && (t.value = f);
    }, { immediate: !0 }), Re([t], ([f], [g]) => {
      f && (f.addEventListener("keydown", a), f.addEventListener("focusin", c), f.addEventListener("focusout", d)), g && (g.removeEventListener("keydown", a), g.removeEventListener("focusin", c), g.removeEventListener("focusout", d));
    });
    const l = (f) => {
      e(Do, f);
    }, u = (f) => e(Oo, f), c = (f) => {
      const g = M(t);
      if (!g)
        return;
      const m = f.target, v = f.relatedTarget, E = m && g.contains(m);
      i.trapped || v && g.contains(v) || (r = v), E && e("focusin", f), !o.paused && i.trapped && (E ? n = m : ar(n, !0));
    }, d = (f) => {
      const g = M(t);
      if (!(o.paused || !g))
        if (i.trapped) {
          const m = f.relatedTarget;
          !rr(m) && !g.contains(m) && setTimeout(() => {
            if (!o.paused && i.trapped) {
              const v = Li({
                focusReason: s.value
              });
              e("focusout-prevented", v), v.defaultPrevented || ar(n, !0);
            }
          }, 0);
        } else {
          const m = f.target;
          m && g.contains(m) || e("focusout", f);
        }
    };
    async function h() {
      await ct();
      const f = M(t);
      if (f) {
        Bo.push(o);
        const g = f.contains(document.activeElement) ? r : document.activeElement;
        if (r = g, !f.contains(g)) {
          const v = new Event(_n, ko);
          f.addEventListener(_n, l), f.dispatchEvent(v), v.defaultPrevented || ct(() => {
            let E = i.focusStartEl;
            It(E) || (ar(E), document.activeElement !== E && (E = "first")), E === "first" && mp(_l(f), !0), (document.activeElement === g || E === "container") && ar(f);
          });
        }
      }
    }
    function p() {
      const f = M(t);
      if (f) {
        f.removeEventListener(_n, l);
        const g = new CustomEvent(xn, {
          ...ko,
          detail: {
            focusReason: s.value
          }
        });
        f.addEventListener(xn, u), f.dispatchEvent(g), !g.defaultPrevented && (s.value == "keyboard" || !vp() || f.contains(document.activeElement)) && ar(r ?? document.body), f.removeEventListener(xn, l), Bo.remove(o);
      }
    }
    return ht(() => {
      i.trapped && h(), Re(() => i.trapped, (f) => {
        f ? h() : p();
      });
    }), qt(() => {
      i.trapped && p();
    }), {
      onKeydown: a
    };
  }
});
function Ap(i, e, t, r, n, s) {
  return it(i.$slots, "default", { handleKeydown: i.onKeydown });
}
var _p = /* @__PURE__ */ ut(Ep, [["render", Ap], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const xp = ["fixed", "absolute"], Sp = Xe({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: Te(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: xi,
    default: "bottom"
  },
  popperOptions: {
    type: Te(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: xp,
    default: "absolute"
  }
}), xl = Xe({
  ...Sp,
  id: String,
  style: {
    type: Te([String, Array, Object])
  },
  className: {
    type: Te([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: Te([String, Array, Object])
  },
  popperStyle: {
    type: Te([String, Array, Object])
  },
  referenceEl: {
    type: Te(Object)
  },
  triggerTargetEl: {
    type: Te(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), Tp = {
  mouseenter: (i) => i instanceof MouseEvent,
  mouseleave: (i) => i instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, Ip = (i, e = []) => {
  const { placement: t, strategy: r, popperOptions: n } = i, s = {
    placement: t,
    strategy: r,
    ...n,
    modifiers: [...Lp(i), ...e]
  };
  return Cp(s, n == null ? void 0 : n.modifiers), s;
}, bp = (i) => {
  if (Rt)
    return cr(i);
};
function Lp(i) {
  const { offset: e, gpuAcceleration: t, fallbackPlacements: r } = i;
  return [
    {
      name: "offset",
      options: {
        offset: [0, e ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: r
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: t
      }
    }
  ];
}
function Cp(i, e) {
  e && (i.modifiers = [...i.modifiers, ...e ?? []]);
}
const Rp = 0, wp = (i) => {
  const { popperInstanceRef: e, contentRef: t, triggerRef: r, role: n } = $e(bs, void 0), s = q(), o = q(), a = J(() => ({
    name: "eventListeners",
    enabled: !!i.visible
  })), l = J(() => {
    var v;
    const E = M(s), A = (v = M(o)) != null ? v : Rp;
    return {
      name: "arrow",
      enabled: !Yd(E),
      options: {
        element: E,
        padding: A
      }
    };
  }), u = J(() => ({
    onFirstUpdate: () => {
      f();
    },
    ...Ip(i, [
      M(l),
      M(a)
    ])
  })), c = J(() => bp(i.referenceEl) || M(r)), { attributes: d, state: h, styles: p, update: f, forceUpdate: g, instanceRef: m } = A0(c, t, u);
  return Re(m, (v) => e.value = v), ht(() => {
    Re(() => {
      var v;
      return (v = M(c)) == null ? void 0 : v.getBoundingClientRect();
    }, () => {
      f();
    });
  }), {
    attributes: d,
    arrowRef: s,
    contentRef: t,
    instanceRef: m,
    state: h,
    styles: p,
    role: n,
    forceUpdate: g,
    update: f
  };
}, kp = (i, {
  attributes: e,
  styles: t,
  role: r
}) => {
  const { nextZIndex: n } = D0(), s = St("popper"), o = J(() => M(e).popper), a = q(i.zIndex || n()), l = J(() => [
    s.b(),
    s.is("pure", i.pure),
    s.is(i.effect),
    i.popperClass
  ]), u = J(() => [
    { zIndex: M(a) },
    i.popperStyle || {},
    M(t).popper
  ]), c = J(() => r.value === "dialog" ? "false" : void 0), d = J(() => M(t).arrow || {});
  return {
    ariaModal: c,
    arrowStyle: d,
    contentAttrs: o,
    contentClass: l,
    contentStyle: u,
    contentZIndex: a,
    updateZIndex: () => {
      a.value = i.zIndex || n();
    }
  };
}, Dp = (i, e) => {
  const t = q(!1), r = q();
  return {
    focusStartRef: r,
    trapped: t,
    onFocusAfterReleased: (u) => {
      var c;
      ((c = u.detail) == null ? void 0 : c.focusReason) !== "pointer" && (r.value = "first", e("blur"));
    },
    onFocusAfterTrapped: () => {
      e("focus");
    },
    onFocusInTrap: (u) => {
      i.visible && !t.value && (u.target && (r.value = u.target), t.value = !0);
    },
    onFocusoutPrevented: (u) => {
      i.trapping || (u.detail.focusReason === "pointer" && u.preventDefault(), t.value = !1);
    },
    onReleaseRequested: () => {
      t.value = !1, e("close");
    }
  };
}, Op = De({
  name: "ElPopperContent"
}), Pp = /* @__PURE__ */ De({
  ...Op,
  props: xl,
  emits: Tp,
  setup(i, { expose: e, emit: t }) {
    const r = i, {
      focusStartRef: n,
      trapped: s,
      onFocusAfterReleased: o,
      onFocusAfterTrapped: a,
      onFocusInTrap: l,
      onFocusoutPrevented: u,
      onReleaseRequested: c
    } = Dp(r, t), { attributes: d, arrowRef: h, contentRef: p, styles: f, instanceRef: g, role: m, update: v } = wp(r), {
      ariaModal: E,
      arrowStyle: A,
      contentAttrs: _,
      contentClass: y,
      contentStyle: S,
      updateZIndex: b
    } = kp(r, {
      styles: f,
      attributes: d,
      role: m
    }), w = $e(Ji, void 0), P = q();
    ir(ml, {
      arrowStyle: A,
      arrowRef: h,
      arrowOffset: P
    }), w && (w.addInputId || w.removeInputId) && ir(Ji, {
      ...w,
      addInputId: Vi,
      removeInputId: Vi
    });
    let C;
    const T = (L = !0) => {
      v(), L && b();
    }, x = () => {
      T(!1), r.visible && r.focusOnShow ? s.value = !0 : r.visible === !1 && (s.value = !1);
    };
    return ht(() => {
      Re(() => r.triggerTargetEl, (L, I) => {
        C == null || C(), C = void 0;
        const R = M(L || p.value), B = M(I || p.value);
        ji(R) && (C = Re([m, () => r.ariaLabel, E, () => r.id], (D) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((k, F) => {
            rr(D[F]) ? R.removeAttribute(k) : R.setAttribute(k, D[F]);
          });
        }, { immediate: !0 })), B !== R && ji(B) && ["role", "aria-label", "aria-modal", "id"].forEach((D) => {
          B.removeAttribute(D);
        });
      }, { immediate: !0 }), Re(() => r.visible, x, { immediate: !0 });
    }), qt(() => {
      C == null || C(), C = void 0;
    }), e({
      popperContentRef: p,
      popperInstanceRef: g,
      updatePopper: T,
      contentStyle: S
    }), (L, I) => (X(), le("div", hr({
      ref_key: "contentRef",
      ref: p
    }, M(_), {
      style: M(S),
      class: M(y),
      tabindex: "-1",
      onMouseenter: I[0] || (I[0] = (R) => L.$emit("mouseenter", R)),
      onMouseleave: I[1] || (I[1] = (R) => L.$emit("mouseleave", R))
    }), [
      Ze(M(_p), {
        trapped: M(s),
        "trap-on-focus-in": !0,
        "focus-trap-el": M(p),
        "focus-start-el": M(n),
        onFocusAfterTrapped: M(a),
        onFocusAfterReleased: M(o),
        onFocusin: M(l),
        onFocusoutPrevented: M(u),
        onReleaseRequested: M(c)
      }, {
        default: Ce(() => [
          it(L.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var Mp = /* @__PURE__ */ ut(Pp, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const Bp = fr(tp), Rs = Symbol("elTooltip"), Lt = Xe({
  ...b0,
  ...xl,
  appendTo: {
    type: Te([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: Te(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), vi = Xe({
  ...Al,
  disabled: Boolean,
  trigger: {
    type: Te([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: Te(Array),
    default: () => [pi.enter, pi.space]
  }
}), {
  useModelToggleProps: Fp,
  useModelToggleEmits: Np,
  useModelToggle: Up
} = $a("visible"), Kp = Xe({
  ...vl,
  ...Fp,
  ...Lt,
  ...vi,
  ...yl,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), Gp = [
  ...Np,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], Vp = (i, e) => Ga(i) ? i.includes(e) : i === e, kr = (i, e, t) => (r) => {
  Vp(M(i), e) && t(r);
}, Hp = De({
  name: "ElTooltipTrigger"
}), jp = /* @__PURE__ */ De({
  ...Hp,
  props: vi,
  setup(i, { expose: e }) {
    const t = i, r = St("tooltip"), { controlled: n, id: s, open: o, onOpen: a, onClose: l, onToggle: u } = $e(Rs, void 0), c = q(null), d = () => {
      if (M(n) || t.disabled)
        return !0;
    }, h = Ar(t, "trigger"), p = $t(d, kr(h, "hover", a)), f = $t(d, kr(h, "hover", l)), g = $t(d, kr(h, "click", (_) => {
      _.button === 0 && u(_);
    })), m = $t(d, kr(h, "focus", a)), v = $t(d, kr(h, "focus", l)), E = $t(d, kr(h, "contextmenu", (_) => {
      _.preventDefault(), u(_);
    })), A = $t(d, (_) => {
      const { code: y } = _;
      t.triggerKeys.includes(y) && (_.preventDefault(), u(_));
    });
    return e({
      triggerRef: c
    }), (_, y) => (X(), ke(M(lp), {
      id: M(s),
      "virtual-ref": _.virtualRef,
      open: M(o),
      "virtual-triggering": _.virtualTriggering,
      class: Ee(M(r).e("trigger")),
      onBlur: M(v),
      onClick: M(g),
      onContextmenu: M(E),
      onFocus: M(m),
      onMouseenter: M(p),
      onMouseleave: M(f),
      onKeydown: M(A)
    }, {
      default: Ce(() => [
        it(_.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var Wp = /* @__PURE__ */ ut(jp, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const Qp = De({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), Jp = /* @__PURE__ */ De({
  ...Qp,
  props: Lt,
  setup(i, { expose: e }) {
    const t = i, { selector: r } = pl(), n = St("tooltip"), s = q(null), o = q(!1), {
      controlled: a,
      id: l,
      open: u,
      trigger: c,
      onClose: d,
      onOpen: h,
      onShow: p,
      onHide: f,
      onBeforeShow: g,
      onBeforeHide: m
    } = $e(Rs, void 0), v = J(() => t.transition || `${n.namespace.value}-fade-in-linear`), E = J(() => process.env.NODE_ENV === "test" ? !0 : t.persistent);
    qt(() => {
      o.value = !0;
    });
    const A = J(() => M(E) ? !0 : M(u)), _ = J(() => t.disabled ? !1 : M(u)), y = J(() => t.appendTo || r.value), S = J(() => {
      var D;
      return (D = t.style) != null ? D : {};
    }), b = J(() => !M(u)), w = () => {
      f();
    }, P = () => {
      if (M(a))
        return !0;
    }, C = $t(P, () => {
      t.enterable && M(c) === "hover" && h();
    }), T = $t(P, () => {
      M(c) === "hover" && d();
    }), x = () => {
      var D, k;
      (k = (D = s.value) == null ? void 0 : D.updatePopper) == null || k.call(D), g == null || g();
    }, L = () => {
      m == null || m();
    }, I = () => {
      p(), B = qu(J(() => {
        var D;
        return (D = s.value) == null ? void 0 : D.popperContentRef;
      }), () => {
        if (M(a))
          return;
        M(c) !== "hover" && d();
      });
    }, R = () => {
      t.virtualTriggering || d();
    };
    let B;
    return Re(() => M(u), (D) => {
      D || B == null || B();
    }, {
      flush: "post"
    }), Re(() => t.content, () => {
      var D, k;
      (k = (D = s.value) == null ? void 0 : D.updatePopper) == null || k.call(D);
    }), e({
      contentRef: s
    }), (D, k) => (X(), ke(Nu, {
      disabled: !D.teleported,
      to: M(y)
    }, [
      Ze(Fa, {
        name: M(v),
        onAfterLeave: w,
        onBeforeEnter: x,
        onAfterEnter: I,
        onBeforeLeave: L
      }, {
        default: Ce(() => [
          M(A) ? jt((X(), ke(M(Mp), hr({
            key: 0,
            id: M(l),
            ref_key: "contentRef",
            ref: s
          }, D.$attrs, {
            "aria-label": D.ariaLabel,
            "aria-hidden": M(b),
            "boundaries-padding": D.boundariesPadding,
            "fallback-placements": D.fallbackPlacements,
            "gpu-acceleration": D.gpuAcceleration,
            offset: D.offset,
            placement: D.placement,
            "popper-options": D.popperOptions,
            strategy: D.strategy,
            effect: D.effect,
            enterable: D.enterable,
            pure: D.pure,
            "popper-class": D.popperClass,
            "popper-style": [D.popperStyle, M(S)],
            "reference-el": D.referenceEl,
            "trigger-target-el": D.triggerTargetEl,
            visible: M(_),
            "z-index": D.zIndex,
            onMouseenter: M(C),
            onMouseleave: M(T),
            onBlur: R,
            onClose: M(d)
          }), {
            default: Ce(() => [
              o.value ? ye("v-if", !0) : it(D.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [Er, M(_)]
          ]) : ye("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var Yp = /* @__PURE__ */ ut(Jp, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const zp = ["innerHTML"], qp = { key: 1 }, Zp = De({
  name: "ElTooltip"
}), Xp = /* @__PURE__ */ De({
  ...Zp,
  props: Kp,
  emits: Gp,
  setup(i, { expose: e, emit: t }) {
    const r = i;
    I0();
    const n = fl(), s = q(), o = q(), a = () => {
      var v;
      const E = M(s);
      E && ((v = E.popperInstanceRef) == null || v.update());
    }, l = q(!1), u = q(), { show: c, hide: d, hasUpdateHandler: h } = Up({
      indicator: l,
      toggleReason: u
    }), { onOpen: p, onClose: f } = L0({
      showAfter: Ar(r, "showAfter"),
      hideAfter: Ar(r, "hideAfter"),
      autoClose: Ar(r, "autoClose"),
      open: c,
      close: d
    }), g = J(() => xr(r.visible) && !h.value);
    ir(Rs, {
      controlled: g,
      id: n,
      open: Uu(l),
      trigger: Ar(r, "trigger"),
      onOpen: (v) => {
        p(v);
      },
      onClose: (v) => {
        f(v);
      },
      onToggle: (v) => {
        M(l) ? f(v) : p(v);
      },
      onShow: () => {
        t("show", u.value);
      },
      onHide: () => {
        t("hide", u.value);
      },
      onBeforeShow: () => {
        t("before-show", u.value);
      },
      onBeforeHide: () => {
        t("before-hide", u.value);
      },
      updatePopper: a
    }), Re(() => r.disabled, (v) => {
      v && l.value && (l.value = !1);
    });
    const m = () => {
      var v, E;
      const A = (E = (v = o.value) == null ? void 0 : v.contentRef) == null ? void 0 : E.popperContentRef;
      return A && A.contains(document.activeElement);
    };
    return Ku(() => l.value && d()), e({
      popperRef: s,
      contentRef: o,
      isFocusInsideContent: m,
      updatePopper: a,
      onOpen: p,
      onClose: f,
      hide: d
    }), (v, E) => (X(), ke(M(Bp), {
      ref_key: "popperRef",
      ref: s,
      role: v.role
    }, {
      default: Ce(() => [
        Ze(Wp, {
          disabled: v.disabled,
          trigger: v.trigger,
          "trigger-keys": v.triggerKeys,
          "virtual-ref": v.virtualRef,
          "virtual-triggering": v.virtualTriggering
        }, {
          default: Ce(() => [
            v.$slots.default ? it(v.$slots, "default", { key: 0 }) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        Ze(Yp, {
          ref_key: "contentRef",
          ref: o,
          "aria-label": v.ariaLabel,
          "boundaries-padding": v.boundariesPadding,
          content: v.content,
          disabled: v.disabled,
          effect: v.effect,
          enterable: v.enterable,
          "fallback-placements": v.fallbackPlacements,
          "hide-after": v.hideAfter,
          "gpu-acceleration": v.gpuAcceleration,
          offset: v.offset,
          persistent: v.persistent,
          "popper-class": v.popperClass,
          "popper-style": v.popperStyle,
          placement: v.placement,
          "popper-options": v.popperOptions,
          pure: v.pure,
          "raw-content": v.rawContent,
          "reference-el": v.referenceEl,
          "trigger-target-el": v.triggerTargetEl,
          "show-after": v.showAfter,
          strategy: v.strategy,
          teleported: v.teleported,
          transition: v.transition,
          "virtual-triggering": v.virtualTriggering,
          "z-index": v.zIndex,
          "append-to": v.appendTo
        }, {
          default: Ce(() => [
            it(v.$slots, "content", {}, () => [
              v.rawContent ? (X(), le("span", {
                key: 0,
                innerHTML: v.content
              }, null, 8, zp)) : (X(), le("span", qp, gt(v.content), 1))
            ]),
            v.showArrow ? (X(), ke(M(np), {
              key: 0,
              "arrow-offset": v.arrowOffset
            }, null, 8, ["arrow-offset"])) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var $p = /* @__PURE__ */ ut(Xp, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const ws = fr($p);
function eg(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
const tg = 100, rg = 600, No = {
  beforeMount(i, e) {
    const t = e.value, { interval: r = tg, delay: n = rg } = dr(t) ? {} : t;
    let s, o;
    const a = () => dr(t) ? t() : t.handler(), l = () => {
      o && (clearTimeout(o), o = void 0), s && (clearInterval(s), s = void 0);
    };
    i.addEventListener("mousedown", (u) => {
      u.button === 0 && (l(), a(), document.addEventListener("mouseup", () => l(), {
        once: !0
      }), o = setTimeout(() => {
        s = setInterval(() => {
          a();
        }, r);
      }, n));
    });
  }
}, ig = /* @__PURE__ */ De({
  inheritAttrs: !1
});
function ng(i, e, t, r, n, s) {
  return it(i.$slots, "default");
}
var sg = /* @__PURE__ */ ut(ig, [["render", ng], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
const og = /* @__PURE__ */ De({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function ag(i, e, t, r, n, s) {
  return it(i.$slots, "default");
}
var lg = /* @__PURE__ */ ut(og, [["render", ag], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
const ug = "data-el-collection-item", cg = (i) => {
  const e = `El${i}Collection`, t = `${e}Item`, r = Symbol(e), n = Symbol(t), s = {
    ...sg,
    name: e,
    setup() {
      const a = q(null), l = /* @__PURE__ */ new Map();
      ir(r, {
        itemMap: l,
        getItems: () => {
          const c = M(a);
          if (!c)
            return [];
          const d = Array.from(c.querySelectorAll(`[${ug}]`));
          return [...l.values()].sort((p, f) => d.indexOf(p.ref) - d.indexOf(f.ref));
        },
        collectionRef: a
      });
    }
  }, o = {
    ...lg,
    name: t,
    setup(a, { attrs: l }) {
      const u = q(null), c = $e(r, void 0);
      ir(n, {
        collectionItemRef: u
      }), ht(() => {
        const d = M(u);
        d && c.itemMap.set(d, {
          ref: d,
          ...l
        });
      }), qt(() => {
        const d = M(u);
        c.itemMap.delete(d);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: r,
    COLLECTION_ITEM_INJECTION_KEY: n,
    ElCollection: s,
    ElCollectionItem: o
  };
}, Sn = Xe({
  trigger: vi.trigger,
  effect: {
    ...Lt.effect,
    default: "light"
  },
  type: {
    type: Te(String)
  },
  placement: {
    type: Te(String),
    default: "bottom"
  },
  popperOptions: {
    type: Te(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: Te([Number, String]),
    default: 0
  },
  maxHeight: {
    type: Te([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: Te(Object)
  },
  teleported: Lt.teleported
});
Xe({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: fi
  }
});
Xe({
  onKeydown: { type: Te(Function) }
});
cg("Dropdown");
const dg = Xe({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: Qi,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (i) => i === null || ze(i) || ["min", "max"].includes(i),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (i) => i >= 0 && i === Number.parseInt(`${i}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), hg = {
  [br]: (i, e) => e !== i,
  blur: (i) => i instanceof FocusEvent,
  focus: (i) => i instanceof FocusEvent,
  [Qt]: (i) => ze(i) || rr(i),
  [dt]: (i) => ze(i) || rr(i)
}, fg = ["aria-label", "onKeydown"], pg = ["aria-label", "onKeydown"], gg = De({
  name: "ElInputNumber"
}), mg = /* @__PURE__ */ De({
  ...gg,
  props: dg,
  emits: hg,
  setup(i, { expose: e, emit: t }) {
    const r = i, { t: n } = Xa(), s = St("input-number"), o = q(), a = ci({
      currentValue: r.modelValue,
      userInput: null
    }), { formItem: l } = ln(), u = J(() => ze(r.modelValue) && r.modelValue <= r.min), c = J(() => ze(r.modelValue) && r.modelValue >= r.max), d = J(() => {
      const L = v(r.step);
      return ii(r.precision) ? Math.max(v(r.modelValue), L) : (L > r.precision && lt("InputNumber", "precision should not be less than the decimal places of step"), r.precision);
    }), h = J(() => r.controls && r.controlsPosition === "right"), p = an(), f = Ts(), g = J(() => {
      if (a.userInput !== null)
        return a.userInput;
      let L = a.currentValue;
      if (rr(L))
        return "";
      if (ze(L)) {
        if (Number.isNaN(L))
          return "";
        ii(r.precision) || (L = L.toFixed(r.precision));
      }
      return L;
    }), m = (L, I) => {
      if (ii(I) && (I = d.value), I === 0)
        return Math.round(L);
      let R = String(L);
      const B = R.indexOf(".");
      if (B === -1 || !R.replace(".", "").split("")[B + I])
        return L;
      const F = R.length;
      return R.charAt(F - 1) === "5" && (R = `${R.slice(0, Math.max(0, F - 1))}6`), Number.parseFloat(Number(R).toFixed(I));
    }, v = (L) => {
      if (rr(L))
        return 0;
      const I = L.toString(), R = I.indexOf(".");
      let B = 0;
      return R !== -1 && (B = I.length - R - 1), B;
    }, E = (L, I = 1) => ze(L) ? m(L + r.step * I) : a.currentValue, A = () => {
      if (r.readonly || f.value || c.value)
        return;
      const L = Number(g.value) || 0, I = E(L);
      S(I), t(Qt, a.currentValue);
    }, _ = () => {
      if (r.readonly || f.value || u.value)
        return;
      const L = Number(g.value) || 0, I = E(L, -1);
      S(I), t(Qt, a.currentValue);
    }, y = (L, I) => {
      const { max: R, min: B, step: D, precision: k, stepStrictly: F, valueOnClear: U } = r;
      let G = Number(L);
      if (rr(L) || Number.isNaN(G))
        return null;
      if (L === "") {
        if (U === null)
          return null;
        G = It(U) ? { min: B, max: R }[U] : U;
      }
      return F && (G = m(Math.round(G / D) * D, k)), ii(k) || (G = m(G, k)), (G > R || G < B) && (G = G > R ? R : B, I && t(dt, G)), G;
    }, S = (L, I = !0) => {
      var R;
      const B = a.currentValue, D = y(L);
      if (!I) {
        t(dt, D);
        return;
      }
      B !== D && (a.userInput = null, t(dt, D), t(br, D, B), r.validateEvent && ((R = l == null ? void 0 : l.validate) == null || R.call(l, "change").catch((k) => lt(k))), a.currentValue = D);
    }, b = (L) => {
      a.userInput = L;
      const I = L === "" ? null : Number(L);
      t(Qt, I), S(I, !1);
    }, w = (L) => {
      const I = L !== "" ? Number(L) : "";
      (ze(I) && !Number.isNaN(I) || L === "") && S(I), a.userInput = null;
    }, P = () => {
      var L, I;
      (I = (L = o.value) == null ? void 0 : L.focus) == null || I.call(L);
    }, C = () => {
      var L, I;
      (I = (L = o.value) == null ? void 0 : L.blur) == null || I.call(L);
    }, T = (L) => {
      t("focus", L);
    }, x = (L) => {
      var I;
      t("blur", L), r.validateEvent && ((I = l == null ? void 0 : l.validate) == null || I.call(l, "blur").catch((R) => lt(R)));
    };
    return Re(() => r.modelValue, (L) => {
      const I = y(a.userInput), R = y(L, !0);
      !ze(I) && (!I || I !== R) && (a.currentValue = R, a.userInput = null);
    }, { immediate: !0 }), ht(() => {
      var L;
      const { min: I, max: R, modelValue: B } = r, D = (L = o.value) == null ? void 0 : L.input;
      if (D.setAttribute("role", "spinbutton"), Number.isFinite(R) ? D.setAttribute("aria-valuemax", String(R)) : D.removeAttribute("aria-valuemax"), Number.isFinite(I) ? D.setAttribute("aria-valuemin", String(I)) : D.removeAttribute("aria-valuemin"), D.setAttribute("aria-valuenow", String(a.currentValue)), D.setAttribute("aria-disabled", String(f.value)), !ze(B) && B != null) {
        let k = Number(B);
        Number.isNaN(k) && (k = null), t(dt, k);
      }
    }), Gu(() => {
      var L;
      const I = (L = o.value) == null ? void 0 : L.input;
      I == null || I.setAttribute("aria-valuenow", `${a.currentValue}`);
    }), e({
      focus: P,
      blur: C
    }), (L, I) => (X(), le("div", {
      class: Ee([
        M(s).b(),
        M(s).m(M(p)),
        M(s).is("disabled", M(f)),
        M(s).is("without-controls", !L.controls),
        M(s).is("controls-right", M(h))
      ]),
      onDragstart: I[1] || (I[1] = Ur(() => {
      }, ["prevent"]))
    }, [
      L.controls ? jt((X(), le("span", {
        key: 0,
        role: "button",
        "aria-label": M(n)("el.inputNumber.decrease"),
        class: Ee([M(s).e("decrease"), M(s).is("disabled", M(u))]),
        onKeydown: ri(_, ["enter"])
      }, [
        Ze(M(Ut), null, {
          default: Ce(() => [
            M(h) ? (X(), ke(M(rh), { key: 0 })) : (X(), ke(M(Uh), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, fg)), [
        [M(No), _]
      ]) : ye("v-if", !0),
      L.controls ? jt((X(), le("span", {
        key: 1,
        role: "button",
        "aria-label": M(n)("el.inputNumber.increase"),
        class: Ee([M(s).e("increase"), M(s).is("disabled", M(c))]),
        onKeydown: ri(A, ["enter"])
      }, [
        Ze(M(Ut), null, {
          default: Ce(() => [
            M(h) ? (X(), ke(M(lh), { key: 0 })) : (X(), ke(M(Wh), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, pg)), [
        [M(No), A]
      ]) : ye("v-if", !0),
      Ze(M(Z0), {
        id: L.id,
        ref_key: "input",
        ref: o,
        type: "number",
        step: L.step,
        "model-value": M(g),
        placeholder: L.placeholder,
        readonly: L.readonly,
        disabled: M(f),
        size: M(p),
        max: L.max,
        min: L.min,
        name: L.name,
        label: L.label,
        "validate-event": !1,
        onWheel: I[0] || (I[0] = Ur(() => {
        }, ["prevent"])),
        onKeydown: [
          ri(Ur(A, ["prevent"]), ["up"]),
          ri(Ur(_, ["prevent"]), ["down"])
        ],
        onBlur: x,
        onFocus: T,
        onInput: b,
        onChange: w
      }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
    ], 34));
  }
});
var vg = /* @__PURE__ */ ut(mg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
const yg = fr(vg), Eg = Xe({
  trigger: vi.trigger,
  placement: Sn.placement,
  disabled: vi.disabled,
  visible: Lt.visible,
  transition: Lt.transition,
  popperOptions: Sn.popperOptions,
  tabindex: Sn.tabindex,
  content: Lt.content,
  popperStyle: Lt.popperStyle,
  popperClass: Lt.popperClass,
  enterable: {
    ...Lt.enterable,
    default: !0
  },
  effect: {
    ...Lt.effect,
    default: "light"
  },
  teleported: Lt.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), Ag = {
  "update:visible": (i) => xr(i),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, _g = "onUpdate:visible", xg = De({
  name: "ElPopover"
}), Sg = /* @__PURE__ */ De({
  ...xg,
  props: Eg,
  emits: Ag,
  setup(i, { expose: e, emit: t }) {
    const r = i, n = J(() => r[_g]), s = St("popover"), o = q(), a = J(() => {
      var m;
      return (m = M(o)) == null ? void 0 : m.popperRef;
    }), l = J(() => [
      {
        width: fs(r.width)
      },
      r.popperStyle
    ]), u = J(() => [s.b(), r.popperClass, { [s.m("plain")]: !!r.content }]), c = J(() => r.transition === `${s.namespace.value}-fade-in-linear`), d = () => {
      var m;
      (m = o.value) == null || m.hide();
    }, h = () => {
      t("before-enter");
    }, p = () => {
      t("before-leave");
    }, f = () => {
      t("after-enter");
    }, g = () => {
      t("update:visible", !1), t("after-leave");
    };
    return e({
      popperRef: a,
      hide: d
    }), (m, v) => (X(), ke(M(ws), hr({
      ref_key: "tooltipRef",
      ref: o
    }, m.$attrs, {
      trigger: m.trigger,
      placement: m.placement,
      disabled: m.disabled,
      visible: m.visible,
      transition: m.transition,
      "popper-options": m.popperOptions,
      tabindex: m.tabindex,
      content: m.content,
      offset: m.offset,
      "show-after": m.showAfter,
      "hide-after": m.hideAfter,
      "auto-close": m.autoClose,
      "show-arrow": m.showArrow,
      "aria-label": m.title,
      effect: m.effect,
      enterable: m.enterable,
      "popper-class": M(u),
      "popper-style": M(l),
      teleported: m.teleported,
      persistent: m.persistent,
      "gpu-acceleration": M(c),
      "onUpdate:visible": M(n),
      onBeforeShow: h,
      onBeforeHide: p,
      onShow: f,
      onHide: g
    }), {
      content: Ce(() => [
        m.title ? (X(), le("div", {
          key: 0,
          class: Ee(M(s).e("title")),
          role: "title"
        }, gt(m.title), 3)) : ye("v-if", !0),
        it(m.$slots, "default", {}, () => [
          Vu(gt(m.content), 1)
        ])
      ]),
      default: Ce(() => [
        m.$slots.reference ? it(m.$slots, "reference", { key: 0 }) : ye("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var Tg = /* @__PURE__ */ ut(Sg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const Uo = (i, e) => {
  const t = e.arg || e.value, r = t == null ? void 0 : t.popperRef;
  r && (r.triggerRef = i);
};
var Ig = {
  mounted(i, e) {
    Uo(i, e);
  },
  updated(i, e) {
    Uo(i, e);
  }
};
const bg = "popover", Lg = ef(Ig, bg), Cg = fr(Tg, {
  directive: Lg
}), Sl = Symbol("sliderContextKey"), Rg = Xe({
  modelValue: {
    type: Te([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: !0
  },
  size: Qi,
  inputSize: Qi,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: !0
  },
  formatTooltip: {
    type: Te(Function),
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  label: {
    type: String,
    default: void 0
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: Te(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: xi,
    default: "top"
  },
  marks: {
    type: Te(Object)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), Tn = (i) => ze(i) || Ga(i) && i.every(ze), wg = {
  [dt]: Tn,
  [Qt]: Tn,
  [br]: Tn
}, kg = (i, e, t) => {
  const r = q();
  return ht(async () => {
    i.range ? (Array.isArray(i.modelValue) ? (e.firstValue = Math.max(i.min, i.modelValue[0]), e.secondValue = Math.min(i.max, i.modelValue[1])) : (e.firstValue = i.min, e.secondValue = i.max), e.oldValue = [e.firstValue, e.secondValue]) : (typeof i.modelValue != "number" || Number.isNaN(i.modelValue) ? e.firstValue = i.min : e.firstValue = Math.min(i.max, Math.max(i.min, i.modelValue)), e.oldValue = e.firstValue), Ni(window, "resize", t), await ct(), t();
  }), {
    sliderWrapper: r
  };
}, Dg = (i) => J(() => i.marks ? Object.keys(i.marks).map(Number.parseFloat).sort((t, r) => t - r).filter((t) => t <= i.max && t >= i.min).map((t) => ({
  point: t,
  position: (t - i.min) * 100 / (i.max - i.min),
  mark: i.marks[t]
})) : []), Og = (i, e, t) => {
  const { form: r, formItem: n } = ln(), s = ni(), o = q(), a = q(), l = {
    firstButton: o,
    secondButton: a
  }, u = J(() => i.disabled || (r == null ? void 0 : r.disabled) || !1), c = J(() => Math.min(e.firstValue, e.secondValue)), d = J(() => Math.max(e.firstValue, e.secondValue)), h = J(() => i.range ? `${100 * (d.value - c.value) / (i.max - i.min)}%` : `${100 * (e.firstValue - i.min) / (i.max - i.min)}%`), p = J(() => i.range ? `${100 * (c.value - i.min) / (i.max - i.min)}%` : "0%"), f = J(() => i.vertical ? { height: i.height } : {}), g = J(() => i.vertical ? {
    height: h.value,
    bottom: p.value
  } : {
    width: h.value,
    left: p.value
  }), m = () => {
    s.value && (e.sliderSize = s.value[`client${i.vertical ? "Height" : "Width"}`]);
  }, v = (T) => {
    const x = i.min + T * (i.max - i.min) / 100;
    if (!i.range)
      return o;
    let L;
    return Math.abs(c.value - x) < Math.abs(d.value - x) ? L = e.firstValue < e.secondValue ? "firstButton" : "secondButton" : L = e.firstValue > e.secondValue ? "firstButton" : "secondButton", l[L];
  }, E = (T) => {
    const x = v(T);
    return x.value.setPosition(T), x;
  }, A = (T) => {
    e.firstValue = T, y(i.range ? [c.value, d.value] : T);
  }, _ = (T) => {
    e.secondValue = T, i.range && y([c.value, d.value]);
  }, y = (T) => {
    t(dt, T), t(Qt, T);
  }, S = async () => {
    await ct(), t(br, i.range ? [c.value, d.value] : i.modelValue);
  }, b = (T) => {
    var x, L, I, R, B, D;
    if (u.value || e.dragging)
      return;
    m();
    let k = 0;
    if (i.vertical) {
      const F = (I = (L = (x = T.touches) == null ? void 0 : x.item(0)) == null ? void 0 : L.clientY) != null ? I : T.clientY;
      k = (s.value.getBoundingClientRect().bottom - F) / e.sliderSize * 100;
    } else {
      const F = (D = (B = (R = T.touches) == null ? void 0 : R.item(0)) == null ? void 0 : B.clientX) != null ? D : T.clientX, U = s.value.getBoundingClientRect().left;
      k = (F - U) / e.sliderSize * 100;
    }
    if (!(k < 0 || k > 100))
      return E(k);
  };
  return {
    elFormItem: n,
    slider: s,
    firstButton: o,
    secondButton: a,
    sliderDisabled: u,
    minValue: c,
    maxValue: d,
    runwayStyle: f,
    barStyle: g,
    resetSize: m,
    setPosition: E,
    emitChange: S,
    onSliderWrapperPrevent: (T) => {
      var x, L;
      ((x = l.firstButton.value) != null && x.dragging || (L = l.secondButton.value) != null && L.dragging) && T.preventDefault();
    },
    onSliderClick: (T) => {
      b(T) && S();
    },
    onSliderDown: async (T) => {
      const x = b(T);
      x && (await ct(), x.value.onButtonDown(T));
    },
    setFirstValue: A,
    setSecondValue: _
  };
}, { left: Pg, down: Mg, right: Bg, up: Fg, home: Ng, end: Ug, pageUp: Kg, pageDown: Gg } = pi, Vg = (i, e, t) => {
  const r = q(), n = q(!1), s = J(() => e.value instanceof Function), o = J(() => s.value && e.value(i.modelValue) || i.modelValue), a = po(() => {
    t.value && (n.value = !0);
  }, 50), l = po(() => {
    t.value && (n.value = !1);
  }, 50);
  return {
    tooltip: r,
    tooltipVisible: n,
    formatValue: o,
    displayTooltip: a,
    hideTooltip: l
  };
}, Hg = (i, e, t) => {
  const {
    disabled: r,
    min: n,
    max: s,
    step: o,
    showTooltip: a,
    precision: l,
    sliderSize: u,
    formatTooltip: c,
    emitChange: d,
    resetSize: h,
    updateDragging: p
  } = $e(Sl), { tooltip: f, tooltipVisible: g, formatValue: m, displayTooltip: v, hideTooltip: E } = Vg(i, c, a), A = q(), _ = J(() => `${(i.modelValue - n.value) / (s.value - n.value) * 100}%`), y = J(() => i.vertical ? { bottom: _.value } : { left: _.value }), S = () => {
    e.hovering = !0, v();
  }, b = () => {
    e.hovering = !1, e.dragging || E();
  }, w = (N) => {
    r.value || (N.preventDefault(), k(N), window.addEventListener("mousemove", F), window.addEventListener("touchmove", F), window.addEventListener("mouseup", U), window.addEventListener("touchend", U), window.addEventListener("contextmenu", U), A.value.focus());
  }, P = (N) => {
    r.value || (e.newPosition = Number.parseFloat(_.value) + N / (s.value - n.value) * 100, G(e.newPosition), d());
  }, C = () => {
    P(-o.value);
  }, T = () => {
    P(o.value);
  }, x = () => {
    P(-o.value * 4);
  }, L = () => {
    P(o.value * 4);
  }, I = () => {
    r.value || (G(0), d());
  }, R = () => {
    r.value || (G(100), d());
  }, B = (N) => {
    let V = !0;
    [Pg, Mg].includes(N.key) ? C() : [Bg, Fg].includes(N.key) ? T() : N.key === Ng ? I() : N.key === Ug ? R() : N.key === Gg ? x() : N.key === Kg ? L() : V = !1, V && N.preventDefault();
  }, D = (N) => {
    let V, j;
    return N.type.startsWith("touch") ? (j = N.touches[0].clientY, V = N.touches[0].clientX) : (j = N.clientY, V = N.clientX), {
      clientX: V,
      clientY: j
    };
  }, k = (N) => {
    e.dragging = !0, e.isClick = !0;
    const { clientX: V, clientY: j } = D(N);
    i.vertical ? e.startY = j : e.startX = V, e.startPosition = Number.parseFloat(_.value), e.newPosition = e.startPosition;
  }, F = (N) => {
    if (e.dragging) {
      e.isClick = !1, v(), h();
      let V;
      const { clientX: j, clientY: ee } = D(N);
      i.vertical ? (e.currentY = ee, V = (e.startY - e.currentY) / u.value * 100) : (e.currentX = j, V = (e.currentX - e.startX) / u.value * 100), e.newPosition = e.startPosition + V, G(e.newPosition);
    }
  }, U = () => {
    e.dragging && (setTimeout(() => {
      e.dragging = !1, e.hovering || E(), e.isClick || G(e.newPosition), d();
    }, 0), window.removeEventListener("mousemove", F), window.removeEventListener("touchmove", F), window.removeEventListener("mouseup", U), window.removeEventListener("touchend", U), window.removeEventListener("contextmenu", U));
  }, G = async (N) => {
    if (N === null || Number.isNaN(+N))
      return;
    N < 0 ? N = 0 : N > 100 && (N = 100);
    const V = 100 / ((s.value - n.value) / o.value);
    let ee = Math.round(N / V) * V * (s.value - n.value) * 0.01 + n.value;
    ee = Number.parseFloat(ee.toFixed(l.value)), ee !== i.modelValue && t(dt, ee), !e.dragging && i.modelValue !== e.oldValue && (e.oldValue = i.modelValue), await ct(), e.dragging && v(), f.value.updatePopper();
  };
  return Re(() => e.dragging, (N) => {
    p(N);
  }), {
    disabled: r,
    button: A,
    tooltip: f,
    tooltipVisible: g,
    showTooltip: a,
    wrapperStyle: y,
    formatValue: m,
    handleMouseEnter: S,
    handleMouseLeave: b,
    onButtonDown: w,
    onKeyDown: B,
    setPosition: G
  };
}, jg = (i, e, t, r) => ({
  stops: J(() => {
    if (!i.showStops || i.min > i.max)
      return [];
    if (i.step === 0)
      return lt("ElSlider", "step should not be 0."), [];
    const o = (i.max - i.min) / i.step, a = 100 * i.step / (i.max - i.min), l = Array.from({ length: o - 1 }).map((u, c) => (c + 1) * a);
    return i.range ? l.filter((u) => u < 100 * (t.value - i.min) / (i.max - i.min) || u > 100 * (r.value - i.min) / (i.max - i.min)) : l.filter((u) => u > 100 * (e.firstValue - i.min) / (i.max - i.min));
  }),
  getStopStyle: (o) => i.vertical ? { bottom: `${o}%` } : { left: `${o}%` }
}), Wg = (i, e, t, r, n, s) => {
  const o = (u) => {
    n(dt, u), n(Qt, u);
  }, a = () => i.range ? ![t.value, r.value].every((u, c) => u === e.oldValue[c]) : i.modelValue !== e.oldValue, l = () => {
    var u, c;
    i.min > i.max && Ja("Slider", "min should not be greater than max.");
    const d = i.modelValue;
    i.range && Array.isArray(d) ? d[1] < i.min ? o([i.min, i.min]) : d[0] > i.max ? o([i.max, i.max]) : d[0] < i.min ? o([i.min, d[1]]) : d[1] > i.max ? o([d[0], i.max]) : (e.firstValue = d[0], e.secondValue = d[1], a() && (i.validateEvent && ((u = s == null ? void 0 : s.validate) == null || u.call(s, "change").catch((h) => lt(h))), e.oldValue = d.slice())) : !i.range && typeof d == "number" && !Number.isNaN(d) && (d < i.min ? o(i.min) : d > i.max ? o(i.max) : (e.firstValue = d, a() && (i.validateEvent && ((c = s == null ? void 0 : s.validate) == null || c.call(s, "change").catch((h) => lt(h))), e.oldValue = d)));
  };
  l(), Re(() => e.dragging, (u) => {
    u || l();
  }), Re(() => i.modelValue, (u, c) => {
    e.dragging || Array.isArray(u) && Array.isArray(c) && u.every((d, h) => d === c[h]) && e.firstValue === u[0] && e.secondValue === u[1] || l();
  }, {
    deep: !0
  }), Re(() => [i.min, i.max], () => {
    l();
  });
}, Qg = Xe({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: xi,
    default: "top"
  }
}), Jg = {
  [dt]: (i) => ze(i)
}, Yg = ["tabindex"], zg = De({
  name: "ElSliderButton"
}), qg = /* @__PURE__ */ De({
  ...zg,
  props: Qg,
  emits: Jg,
  setup(i, { expose: e, emit: t }) {
    const r = i, n = St("slider"), s = ci({
      hovering: !1,
      dragging: !1,
      isClick: !1,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: r.modelValue
    }), {
      disabled: o,
      button: a,
      tooltip: l,
      showTooltip: u,
      tooltipVisible: c,
      wrapperStyle: d,
      formatValue: h,
      handleMouseEnter: p,
      handleMouseLeave: f,
      onButtonDown: g,
      onKeyDown: m,
      setPosition: v
    } = Hg(r, s, t), { hovering: E, dragging: A } = zn(s);
    return e({
      onButtonDown: g,
      onKeyDown: m,
      setPosition: v,
      hovering: E,
      dragging: A
    }), (_, y) => (X(), le("div", {
      ref_key: "button",
      ref: a,
      class: Ee([M(n).e("button-wrapper"), { hover: M(E), dragging: M(A) }]),
      style: Nt(M(d)),
      tabindex: M(o) ? -1 : 0,
      onMouseenter: y[0] || (y[0] = (...S) => M(p) && M(p)(...S)),
      onMouseleave: y[1] || (y[1] = (...S) => M(f) && M(f)(...S)),
      onMousedown: y[2] || (y[2] = (...S) => M(g) && M(g)(...S)),
      onTouchstart: y[3] || (y[3] = (...S) => M(g) && M(g)(...S)),
      onFocus: y[4] || (y[4] = (...S) => M(p) && M(p)(...S)),
      onBlur: y[5] || (y[5] = (...S) => M(f) && M(f)(...S)),
      onKeydown: y[6] || (y[6] = (...S) => M(m) && M(m)(...S))
    }, [
      Ze(M(ws), {
        ref_key: "tooltip",
        ref: l,
        visible: M(c),
        placement: _.placement,
        "fallback-placements": ["top", "bottom", "right", "left"],
        "stop-popper-mouse-event": !1,
        "popper-class": _.tooltipClass,
        disabled: !M(u),
        persistent: ""
      }, {
        content: Ce(() => [
          se("span", null, gt(M(h)), 1)
        ]),
        default: Ce(() => [
          se("div", {
            class: Ee([M(n).e("button"), { hover: M(E), dragging: M(A) }])
          }, null, 2)
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class", "disabled"])
    ], 46, Yg));
  }
});
var Ko = /* @__PURE__ */ ut(qg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
const Zg = Xe({
  mark: {
    type: Te([String, Object]),
    default: void 0
  }
});
var Xg = De({
  name: "ElSliderMarker",
  props: Zg,
  setup(i) {
    const e = St("slider"), t = J(() => It(i.mark) ? i.mark : i.mark.label), r = J(() => It(i.mark) ? void 0 : i.mark.style);
    return () => Na("div", {
      class: e.e("marks-text"),
      style: r.value
    }, t.value);
  }
});
const $g = ["id", "role", "aria-label", "aria-labelledby"], em = { key: 1 }, tm = De({
  name: "ElSlider"
}), rm = /* @__PURE__ */ De({
  ...tm,
  props: Rg,
  emits: wg,
  setup(i, { expose: e, emit: t }) {
    const r = i, n = St("slider"), { t: s } = Xa(), o = ci({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: !1,
      sliderSize: 1
    }), {
      elFormItem: a,
      slider: l,
      firstButton: u,
      secondButton: c,
      sliderDisabled: d,
      minValue: h,
      maxValue: p,
      runwayStyle: f,
      barStyle: g,
      resetSize: m,
      emitChange: v,
      onSliderWrapperPrevent: E,
      onSliderClick: A,
      onSliderDown: _,
      setFirstValue: y,
      setSecondValue: S
    } = Og(r, o, t), { stops: b, getStopStyle: w } = jg(r, o, h, p), { inputId: P, isLabeledByFormItem: C } = Is(r, {
      formItemContext: a
    }), T = an(), x = J(() => r.inputSize || T.value), L = J(() => r.label || s("el.slider.defaultLabel", {
      min: r.min,
      max: r.max
    })), I = J(() => r.range ? r.rangeStartLabel || s("el.slider.defaultRangeStartLabel") : L.value), R = J(() => r.formatValueText ? r.formatValueText(N.value) : `${N.value}`), B = J(() => r.rangeEndLabel || s("el.slider.defaultRangeEndLabel")), D = J(() => r.formatValueText ? r.formatValueText(V.value) : `${V.value}`), k = J(() => [
      n.b(),
      n.m(T.value),
      n.is("vertical", r.vertical),
      { [n.m("with-input")]: r.showInput }
    ]), F = Dg(r);
    Wg(r, o, h, p, t, a);
    const U = J(() => {
      const Y = [r.min, r.max, r.step].map((te) => {
        const oe = `${te}`.split(".")[1];
        return oe ? oe.length : 0;
      });
      return Math.max.apply(null, Y);
    }), { sliderWrapper: G } = kg(r, o, m), { firstValue: N, secondValue: V, sliderSize: j } = zn(o), ee = (Y) => {
      o.dragging = Y;
    };
    return ir(Sl, {
      ...zn(r),
      sliderSize: j,
      disabled: d,
      precision: U,
      emitChange: v,
      resetSize: m,
      updateDragging: ee
    }), e({
      onSliderClick: A
    }), (Y, te) => {
      var oe, pe;
      return X(), le("div", {
        id: Y.range ? M(P) : void 0,
        ref_key: "sliderWrapper",
        ref: G,
        class: Ee(M(k)),
        role: Y.range ? "group" : void 0,
        "aria-label": Y.range && !M(C) ? M(L) : void 0,
        "aria-labelledby": Y.range && M(C) ? (oe = M(a)) == null ? void 0 : oe.labelId : void 0,
        onTouchstart: te[2] || (te[2] = (...ae) => M(E) && M(E)(...ae)),
        onTouchmove: te[3] || (te[3] = (...ae) => M(E) && M(E)(...ae))
      }, [
        se("div", {
          ref_key: "slider",
          ref: l,
          class: Ee([
            M(n).e("runway"),
            { "show-input": Y.showInput && !Y.range },
            M(n).is("disabled", M(d))
          ]),
          style: Nt(M(f)),
          onMousedown: te[0] || (te[0] = (...ae) => M(_) && M(_)(...ae)),
          onTouchstart: te[1] || (te[1] = (...ae) => M(_) && M(_)(...ae))
        }, [
          se("div", {
            class: Ee(M(n).e("bar")),
            style: Nt(M(g))
          }, null, 6),
          Ze(Ko, {
            id: Y.range ? void 0 : M(P),
            ref_key: "firstButton",
            ref: u,
            "model-value": M(N),
            vertical: Y.vertical,
            "tooltip-class": Y.tooltipClass,
            placement: Y.placement,
            role: "slider",
            "aria-label": Y.range || !M(C) ? M(I) : void 0,
            "aria-labelledby": !Y.range && M(C) ? (pe = M(a)) == null ? void 0 : pe.labelId : void 0,
            "aria-valuemin": Y.min,
            "aria-valuemax": Y.range ? M(V) : Y.max,
            "aria-valuenow": M(N),
            "aria-valuetext": M(R),
            "aria-orientation": Y.vertical ? "vertical" : "horizontal",
            "aria-disabled": M(d),
            "onUpdate:modelValue": M(y)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
          Y.range ? (X(), ke(Ko, {
            key: 0,
            ref_key: "secondButton",
            ref: c,
            "model-value": M(V),
            vertical: Y.vertical,
            "tooltip-class": Y.tooltipClass,
            placement: Y.placement,
            role: "slider",
            "aria-label": M(B),
            "aria-valuemin": M(N),
            "aria-valuemax": Y.max,
            "aria-valuenow": M(V),
            "aria-valuetext": M(D),
            "aria-orientation": Y.vertical ? "vertical" : "horizontal",
            "aria-disabled": M(d),
            "onUpdate:modelValue": M(S)
          }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : ye("v-if", !0),
          Y.showStops ? (X(), le("div", em, [
            (X(!0), le(Wt, null, si(M(b), (ae, Ie) => (X(), le("div", {
              key: Ie,
              class: Ee(M(n).e("stop")),
              style: Nt(M(w)(ae))
            }, null, 6))), 128))
          ])) : ye("v-if", !0),
          M(F).length > 0 ? (X(), le(Wt, { key: 2 }, [
            se("div", null, [
              (X(!0), le(Wt, null, si(M(F), (ae, Ie) => (X(), le("div", {
                key: Ie,
                style: Nt(M(w)(ae.position)),
                class: Ee([M(n).e("stop"), M(n).e("marks-stop")])
              }, null, 6))), 128))
            ]),
            se("div", {
              class: Ee(M(n).e("marks"))
            }, [
              (X(!0), le(Wt, null, si(M(F), (ae, Ie) => (X(), ke(M(Xg), {
                key: Ie,
                mark: ae.mark,
                style: Nt(M(w)(ae.position))
              }, null, 8, ["mark", "style"]))), 128))
            ], 2)
          ], 64)) : ye("v-if", !0)
        ], 38),
        Y.showInput && !Y.range ? (X(), ke(M(yg), {
          key: 0,
          ref: "input",
          "model-value": M(N),
          class: Ee(M(n).e("input")),
          step: Y.step,
          disabled: M(d),
          controls: Y.showInputControls,
          min: Y.min,
          max: Y.max,
          debounce: Y.debounce,
          size: M(x),
          "onUpdate:modelValue": M(y),
          onChange: M(v)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : ye("v-if", !0)
      ], 42, $g);
    };
  }
});
var im = /* @__PURE__ */ ut(rm, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
const nm = fr(im), sm = Xe({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  value: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: !1
  },
  activeIcon: {
    type: fi
  },
  inactiveIcon: {
    type: fi
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  id: String,
  loading: {
    type: Boolean,
    default: !1
  },
  beforeChange: {
    type: Te(Function)
  },
  size: {
    type: String,
    validator: tf
  },
  tabindex: {
    type: [String, Number]
  }
}), om = {
  [dt]: (i) => xr(i) || It(i) || ze(i),
  [br]: (i) => xr(i) || It(i) || ze(i),
  [Qt]: (i) => xr(i) || It(i) || ze(i)
}, am = ["onClick"], lm = ["id", "aria-checked", "aria-disabled", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], um = ["aria-hidden"], cm = ["aria-hidden"], dm = ["aria-hidden"], Ki = "ElSwitch", hm = De({
  name: Ki
}), fm = /* @__PURE__ */ De({
  ...hm,
  props: sm,
  emits: om,
  setup(i, { expose: e, emit: t }) {
    const r = i, n = qr(), { formItem: s } = ln(), o = an(), a = St("switch");
    lf({
      from: '"value"',
      replacement: '"model-value" or "v-model"',
      scope: Ki,
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/switch.html#attributes",
      type: "Attribute"
    }, J(() => {
      var y;
      return !!((y = n.vnode.props) != null && y.value);
    }));
    const { inputId: l } = Is(r, {
      formItemContext: s
    }), u = Ts(J(() => r.loading)), c = q(r.modelValue !== !1), d = q(), h = q(), p = J(() => [
      a.b(),
      a.m(o.value),
      a.is("disabled", u.value),
      a.is("checked", m.value)
    ]), f = J(() => ({
      width: fs(r.width)
    }));
    Re(() => r.modelValue, () => {
      c.value = !0;
    }), Re(() => r.value, () => {
      c.value = !1;
    });
    const g = J(() => c.value ? r.modelValue : r.value), m = J(() => g.value === r.activeValue);
    [r.activeValue, r.inactiveValue].includes(g.value) || (t(dt, r.inactiveValue), t(br, r.inactiveValue), t(Qt, r.inactiveValue)), Re(m, (y) => {
      var S;
      d.value.checked = y, r.validateEvent && ((S = s == null ? void 0 : s.validate) == null || S.call(s, "change").catch((b) => lt(b)));
    });
    const v = () => {
      const y = m.value ? r.inactiveValue : r.activeValue;
      t(dt, y), t(br, y), t(Qt, y), ct(() => {
        d.value.checked = m.value;
      });
    }, E = () => {
      if (u.value)
        return;
      const { beforeChange: y } = r;
      if (!y) {
        v();
        return;
      }
      const S = y();
      [
        oo(S),
        xr(S)
      ].includes(!0) || Ja(Ki, "beforeChange must return type `Promise<boolean>` or `boolean`"), oo(S) ? S.then((w) => {
        w && v();
      }).catch((w) => {
        lt(Ki, `some error occurred: ${w}`);
      }) : S && v();
    }, A = J(() => a.cssVarBlock({
      ...r.activeColor ? { "on-color": r.activeColor } : null,
      ...r.inactiveColor ? { "off-color": r.inactiveColor } : null,
      ...r.borderColor ? { "border-color": r.borderColor } : null
    })), _ = () => {
      var y, S;
      (S = (y = d.value) == null ? void 0 : y.focus) == null || S.call(y);
    };
    return ht(() => {
      d.value.checked = m.value;
    }), e({
      focus: _,
      checked: m
    }), (y, S) => (X(), le("div", {
      class: Ee(M(p)),
      style: Nt(M(A)),
      onClick: Ur(E, ["prevent"])
    }, [
      se("input", {
        id: M(l),
        ref_key: "input",
        ref: d,
        class: Ee(M(a).e("input")),
        type: "checkbox",
        role: "switch",
        "aria-checked": M(m),
        "aria-disabled": M(u),
        name: y.name,
        "true-value": y.activeValue,
        "false-value": y.inactiveValue,
        disabled: M(u),
        tabindex: y.tabindex,
        onChange: v,
        onKeydown: ri(E, ["enter"])
      }, null, 42, lm),
      !y.inlinePrompt && (y.inactiveIcon || y.inactiveText) ? (X(), le("span", {
        key: 0,
        class: Ee([
          M(a).e("label"),
          M(a).em("label", "left"),
          M(a).is("active", !M(m))
        ])
      }, [
        y.inactiveIcon ? (X(), ke(M(Ut), { key: 0 }, {
          default: Ce(() => [
            (X(), ke(_r(y.inactiveIcon)))
          ]),
          _: 1
        })) : ye("v-if", !0),
        !y.inactiveIcon && y.inactiveText ? (X(), le("span", {
          key: 1,
          "aria-hidden": M(m)
        }, gt(y.inactiveText), 9, um)) : ye("v-if", !0)
      ], 2)) : ye("v-if", !0),
      se("span", {
        ref_key: "core",
        ref: h,
        class: Ee(M(a).e("core")),
        style: Nt(M(f))
      }, [
        y.inlinePrompt ? (X(), le("div", {
          key: 0,
          class: Ee(M(a).e("inner"))
        }, [
          y.activeIcon || y.inactiveIcon ? (X(), ke(M(Ut), {
            key: 0,
            class: Ee(M(a).is("icon"))
          }, {
            default: Ce(() => [
              (X(), ke(_r(M(m) ? y.activeIcon : y.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : y.activeText || y.inactiveText ? (X(), le("span", {
            key: 1,
            class: Ee(M(a).is("text")),
            "aria-hidden": !M(m)
          }, gt(M(m) ? y.activeText : y.inactiveText), 11, cm)) : ye("v-if", !0)
        ], 2)) : ye("v-if", !0),
        se("div", {
          class: Ee(M(a).e("action"))
        }, [
          y.loading ? (X(), ke(M(Ut), {
            key: 0,
            class: Ee(M(a).is("loading"))
          }, {
            default: Ce(() => [
              Ze(M(za))
            ]),
            _: 1
          }, 8, ["class"])) : ye("v-if", !0)
        ], 2)
      ], 6),
      !y.inlinePrompt && (y.activeIcon || y.activeText) ? (X(), le("span", {
        key: 1,
        class: Ee([
          M(a).e("label"),
          M(a).em("label", "right"),
          M(a).is("active", M(m))
        ])
      }, [
        y.activeIcon ? (X(), ke(M(Ut), { key: 0 }, {
          default: Ce(() => [
            (X(), ke(_r(y.activeIcon)))
          ]),
          _: 1
        })) : ye("v-if", !0),
        !y.activeIcon && y.activeText ? (X(), le("span", {
          key: 1,
          "aria-hidden": !M(m)
        }, gt(y.activeText), 9, dm)) : ye("v-if", !0)
      ], 2)) : ye("v-if", !0)
    ], 14, am));
  }
});
var pm = /* @__PURE__ */ ut(fm, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
const gm = fr(pm);
const mm = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAFQElEQVRoge2W228UVRzHv78z07l0L6Vt1hZ8gMpqgaWUaNSaIFowxGBibEqNMTxoTDTGR5/1P/ClDz4Zn7ylSBoeQKKWcolXCKGV1tKWUhIMUkrY3e5lZs7MOT50Nymw053dbSkx/b5scn5nfvv5/n7nBqxrXeta11qK1vLPe27ITsnQS8AeSWiHREuBaR7ANQAXCfhF3YjvjhB5pXKsiYFXr7oHdZ19Qoy6gswn4PDgJvq6VIytLFoZSckOTDhDuqEcDwoPAALY4xd7aAbiJ6T+7NnU98SwjyrsOxE6/WJqrWBBlBiTWv18egCg1z1XVvy9lGjzi626gfgJqZvz6aMAXgMA4VVugIBGv9iqLqHEmNQaQ+kBKsAD1RkAUPIEAlaxA/dXvighqjJwxy+wKh0oVfmilnbAsVzMXpqD6/gWeFGESb/QinfAr/JFyYIBO8fx28AEFu5YABG2dMZ8cxJw1i+2oh2In5D6hlD6aKnKFyWEhJ3j+H1gHJn5HCLNBja1++7RxW8Ig36xFbuJg8ADgMc9zP4xi/R8HuGmELre2gEjVOc7X0qcPfY4veQXX5ElFP/qTnRDffpbAg4uN8+1XUyfm4GVthBprsfz5eEhhPvpcjlrNtB+7HbEytiTUigtpPg31LVdXD03DTtlQY+a2PLCFiTnbCiKA1IITCEwVvhVCEwlwMPwj9u1M6tmYBGeTzk5t0V4EszHgGdzzJyZgpVehI+/+ARUTYXnCniuX3Y5eH5vw6FyDFVv4sTwXNha4JNOzm0BAOEJX/irp6/ASmVhhDXE98ahGv7LBgBAOBkSDW+DqHTSJarKQGJ4Lpz5x51y8m5rcazUDevZHDPDf8NOZaGHDWx9uT0YvBftOd1NVhCWig0kBqSWueFOLoUHHrxhPZtj5tQ47GQBvntbWXgJHL+bib4RFB6oYg/kxc1fHcvdeP+4t6QDnsVxbfgv2Mkc9IYQ2vZtDwSfzEZ7pw+SXQlPRR3YOnDr/fyC+0ypmCg8kz2L49qpUdh3M9CjJtr2JaAa2vKJCSfDInqoUnigwg5w2/3ML+Z5Ep7lYPbnETipLLSGENr2d5SFl8DxZCbae74KeKCCDjx59OY73PLCfnHXcnD9p4uwkwvQIibaXukMBl/FslmqwB1wHXzgC8I5kpevwMvmoEcj2Hxgd7Bl40UPXagBHqjAgMdFotS45Bz58XGIXB5KqB6RXduQTgooqgXGCIp63w2rMJBCNS2bag08sHwk57DGxiByObB6E+a27XA4weGObx7NUOYbw/WHp3tqhwcC7oHE8FxYCHnPO0FyB9blUYhsBoppwNyxE6Qtf1RqunJb0c34pZ7GZA3M9yiQgexs7J4Xi+QOrNERyGwGzNRhJDrKwxvKfGOk/qmZN5tSNfA+oEAGZt8liwozJXdgj14Cchkww4Sxs3NNKl9U4GNUVZklHQfOyEXI7ALIMGHs2g3Slj9tdFO9WceM+EpXvqjABojzOWfkAmQmDWaaMDqfBsrAGyH1z+bsxs3Th5vTNZP6cQWZFO77MmZElQmRt5sQCkPf/dyy8HW6mtZCdR9P98a+WDFSH5U9Rlv7+mNctYdEjprINJLhrq6UULXHPFeYsvBaZwoJRWVZtY5GFY19PtXb+s1qgxe1rIHWvv4YZ2wIUnYQYYItZLuvv/fEvw8LLogUv0BrX3+ME4aI0AFggnnovn3ko0cKHvDpQGtff8yDHCIU4AV7JOEBHwNSej8A6CDQZca1/bcGP5x7yFyBVfIYlcLLA/ICc/kjDb+uda3rf6D/AMizOvqVjqIFAAAAAElFTkSuQmCC", vm = "data:image/png;base64,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", ym = "data:image/png;base64,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", Em = "data:image/png;base64,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", Am = "data:image/png;base64,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", _m = "data:image/png;base64,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", xm = "data:image/png;base64,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", Sm = "data:image/png;base64,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", Tm = "data:image/png;base64,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", Im = "data:image/png;base64,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", bm = "data:image/png;base64,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", Lm = "data:image/png;base64,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", Cm = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAAAXNSR0IArs4c6QAACoRJREFUeF7tnV2oplUZhu/7IDqKsh8slZTCE/sxwkyTwMRsnJKKjEyCpB8PGhsYLaIyHMEBMRyiySINrIMwoYmorAaz6UBLM8ufIBBJEbIis6jDDp74ajdNzezZ33rf9a21vrWuD4Y5Wc+znue634s9M/vdjMUHAhDYlIBhAwEIbE4AQXg6IHAMAgjC4wEBBOEZgMA0AnwFmcaNqkEIIMggQbPmNAIIMo0bVYMQQJBBgmbNaQQQZBo3qgYhgCCDBM2a0wggyDRuVA1CAEEGCZo1pxFAkGncqBqEAIIMEjRrTiOAINO4UTUIAQQZJGjWnEYAQaZxo2oQAggySNCsOY0AgkzjRtUgBBBkkKBZcxoBBJnGjapBCCDIIEGz5jQCCDKNG1WDEECQQYJmzWkEEGQaN6oGIYAggwTNmtMIIMg0blQNQgBBBgmaNacRQJBp3KgahACCDBI0a04jgCDTuFE1CAEEGSRo1pxGYO0EiYjjJb1O0gmSXnLY78+ZhqB41S8k3S3pfttPFb+dC5MIrIUgEXGqpHdIukjSG5M2bPvwPts72x5x7OmaFiQi3ibp8g0xek3qGUkX2v55rwuu815NCjKIGP/z3NhuMot1frhzzN5UKBHxaknXdf4VY7Pc9ti+Okeo9MhHoBlBIuINkm6XdFK+9dau0zbbB9Zu6o4HbkKQiLhAEg+GtNv2tR0/b2u3WnVBImKXpL1rR241Ax+wvW01rek6hUBVQSLiQ5JumTJ4pzV/s/3cTndby7WqCRIR50o6uJbUVjf0w7ZPX117OqcSqCJIRJwo6R5JJ6cO3Pn5m2xf0fmOa7VeLUG+Jemda0WqzLCX2F78Sx6fRggUFyQi3iXpm43s39IYt9m+tKWBmEWqIciPJb0J+EcQONn2k3Bpi0BRQSLi/ZK+2haCJqbh+x9NxHDkEKUFWbyQt3hVnc+/CSz+oWKH7YcA0iaBYoJExHmS7moTQ9GpFj8PsuCw+HmQ/UVv5rJkAiUF2SPpU8kTbl7wS0k/k7R44H5i+4mMvWkFgX8RKCnIryW9IhP3qyQtftjoH5n60QYCRyVQRJCIeKWkRzJl8GLbf8zUizYQOCaBUoJcI2l3hix22f5chj60gMBSBEoJcrOkDy810eaHfmj7wpk9KIdAEoFSgtwhaXvSZEcePsf2T2f2oBwCSQRKCfKgpLlvqR5n+69J23EYAjMJlBLkT5JeOGPW39p++Yx6SiEwiUApQWLSdP8tWnyfg/e3ZkKkPJ0AgqQzo2IgAggyUNismk4AQdKZUTEQAQQZKGxWTSeAIOnMqBiIAIIMFDarphNAkHRmVAxEAEEGCptV0wkgSDozKgYigCADhc2q6QQQJJ0ZFQMRQJCBwmbVdAIIks6MioEIIMhAYbNqOgEESWdGxUAEEGSgsFk1nQCCpDOjYiACCDJQ2KyaTgBB0plRMRABBBkobFZNJ4Ag6cyoGIgAggwUNqumE0CQdGZUDEQAQQYKm1XTCSBIOjMqBiKAIAOFzarpBBAknRkVAxFAkIHCZtV0AgiSzoyKgQggyEBhs2o6AQRJZ0bFQAQQZKCwWTWdAIKkM6NiIAIIMlDYrJpOAEHSmVExEAEEGShsVk0ngCDpzKgYiACCDBQ2q6YTQJB0ZlQMRABBBgqbVdMJIEg6MyoGIlBKkMclnTKD69dtv29GPaVrQCAi3iLpLElnb/x6VNJdku63vb/GCqUEuVXSZTMW3Gl734x6ShsnEBHXSfr0Mca8R9IO2w+VXKWUIDskfWHGYmfZvm9GPaWNEoiIMyWlZLvb9rWl1iklyGsl3SvpWRMW+5HtN0+oo2QNCETEnyU9P3HUk20/mVgz6XgRQRaTRcSNkq6cMOUZth+YUEdJ4wQi4vOSPjphzNtsXzqhLrmkmCAbkvxB0vEJU15v+5MJ5zm6JgQi4gRJv5sx7iW2b59Rv1RpUUE2JNkradcS0+21fdUS5ziyhgQi4u2Svj1j9JtsXzGjfqnS4oJsSLJN0mcknSbpeYdN+oSkRyTdYPvupTbg0FoSiIjPSvrYjOEftn36jPqlSqsIcvhkEfEySS+Q9Jjtvyw1NYfWnkBEHJR07pxFbK/8+V35BXMAUNsvAQTpN1s2y0AAQTJApEW/BBCk32zZLAMBBMkAkRb9EkCQfrNlswwEECQDRFr0SwBB+s2WzTIQQJAMEGnRLwEE6TdbNstAAEEyQKRFvwQQpN9s2SwDAQTJAJEW/RJAkH6zZbMMBBAkA0Ra9EsAQfrNls0yEECQDBBp0S8BBOk3WzbLQABBMkCkRb8EEKTfbNksAwEEyQCRFv0SQJB+s2WzDAQQJANEWvRLAEH6zZbNMhBAkAwQadEvAQTpN1s2y0AAQTJApEW/BBCk32zZLAMBBMkAkRb9EkCQfrNlswwEECQDRFr0SwBB+s2WzTIQQJAMEGnRLwEE6TdbNstAICIel3TKjFZP237RjPqlSvkfppbCxKGcBCLiOEnPzOz5kO3XzOyxZTmCbImIA7kJRMQ5kub+J63ft/3W3LP9fz8EWTVh+h9BICJulXTZTDS32L58Zo8tyxFkS0QcyEkgIs6XdGeGnrttX5uhzzFbIMiqCdP/EIGIOFXSo5mQnGH7gUy9Nm2DIKsmTH9FxLMlfVHSBzLheMz2QraVfxBk5YjHvCAiTpJ09sav8ySdnpHEPts7M/bjK0gJmKXuiIh3bzx4Z238XurqVu7ZbvsHJYbhK0gJypnuiIiXSrpe0nsztVzHNvfbPrPU4AhSivTMeyLiGkm7Z7bpofwy218rtQiClCI9456IWPz5/cEZLXopPWh78feZYh8EKYZ6+kURsfiu8+K7z6N/Lra9vyQEBClJe8JdEXGRpO9MKO2tZL/ti0svhSCliSfeFxFXSroxsay347+SdL7tuS84JnNBkGRkZQsi4iuSPlj21uZuO832b2pMhSA1qCfcGRF3SNqeUNLb0Qts53h3axIXBJmErVxRRNwg6ePlbmzqpqtt76k5EYLUpL/E3RGxeKX7y0sc7e3IR2x/qfZSCFI7gS3uz/h6eOObHhpv8RfxHba/0cLACNJCCltLsnhY3rMGo84d8buS9ti+b26jXPUIkovkivtERKz4iprtF2LcbPt7NYc42t0I0loim8wTEa+StHiAFi8s9vJpVoz/AEaQNXvUIuITG2/0rtnkh8Y9IGnxusidtp9ofQkEaT2ho8wXESdKev3Gr2Kvfiei+ruk30t66rDf77X9dGKfqscRpCp+Lm+dAIK0nhDzVSWAIFXxc3nrBBCk9YSYryoBBKmKn8tbJ4AgrSfEfFUJIEhV/FzeOgEEaT0h5qtKAEGq4ufy1gkgSOsJMV9VAghSFT+Xt04AQVpPiPmqEkCQqvi5vHUCCNJ6QsxXlQCCVMXP5a0TQJDWE2K+qgQQpCp+Lm+dAIK0nhDzVSWAIFXxc3nrBBCk9YSYryoBBKmKn8tbJ4AgrSfEfFUJIEhV/FzeOgEEaT0h5qtKAEGq4ufy1gkgSOsJMV9VAghSFT+Xt04AQVpPiPmqEkCQqvi5vHUCCNJ6QsxXlQCCVMXP5a0TQJDWE2K+qgQQpCp+Lm+dwD8Bb+HD5zpHx1QAAAAASUVORK5CYII=";
function Gr(i) {
  "@babel/helpers - typeof";
  return Gr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Gr(i);
}
function Tl(i, e) {
  var t = typeof Symbol == "function" && i[Symbol.iterator];
  if (!t)
    return i;
  var r = t.call(i), n, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = r.next()).done; )
      s.push(n.value);
  } catch (a) {
    o = {
      error: a
    };
  } finally {
    try {
      n && !n.done && (t = r.return) && t.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function Il(i, e, t) {
  if (t || arguments.length === 2)
    for (var r = 0, n = e.length, s; r < n; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return i.concat(s || e);
}
var Rm = function(i, e) {
  var t = Date.now();
  return function() {
    for (var r = [], n = 0; n < arguments.length; n++)
      r[n] = arguments[n];
    var s = Date.now();
    s - t < e || (t = s, i.call.apply(i, Il([this], Tl(r))));
  };
}, bl = (
  /** @class */
  function() {
    function i(e) {
      this.memoryCache = /* @__PURE__ */ new Map(), this.timer = {}, this.maxCache = (e == null ? void 0 : e.maxCache) || 1e3;
    }
    return i.prototype.put = function(e, t, r, n) {
      var s = this;
      if (!e || !t)
        throw new Error("key & value is required");
      this.size() >= this.maxCache && this.del(Il([], Tl(this.memoryCache))[0][0]), this.memoryCache.set(e, t), r && typeof r == "number" && r > 0 && (this.timer[e] = setTimeout(function() {
        s.del(e), delete s.timer[e], n && n();
      }, r));
    }, i.prototype.get = function(e) {
      return this.has(e) ? this.memoryCache.get(e) : null;
    }, i.prototype.has = function(e) {
      return this.memoryCache.has(e);
    }, i.prototype.del = function(e) {
      this.has(e) && (this.timer[e] && (clearTimeout(this.timer[e]), delete this.timer[e]), this.memoryCache.delete(e));
    }, i.prototype.clear = function() {
      if (!(this.size() <= 0)) {
        this.memoryCache.clear();
        for (var e in this.timer)
          clearTimeout(this.timer[e]), delete this.timer[e];
      }
    }, i.prototype.size = function() {
      return this.memoryCache.size;
    }, i;
  }()
);
new bl();
new bl();
var Nr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, wm = { exports: {} };
(function(i, e) {
  (function(t, r) {
    i.exports = r();
  })(Nr, function() {
    var t = 1e3, r = 6e4, n = 36e5, s = "millisecond", o = "second", a = "minute", l = "hour", u = "day", c = "week", d = "month", h = "quarter", p = "year", f = "date", g = "Invalid Date", m = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, v = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, E = {
      name: "en",
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
    }, A = function(I, R, B) {
      var D = String(I);
      return !D || D.length >= R ? I : "" + Array(R + 1 - D.length).join(B) + I;
    }, _ = {
      s: A,
      z: function(I) {
        var R = -I.utcOffset(), B = Math.abs(R), D = Math.floor(B / 60), k = B % 60;
        return (R <= 0 ? "+" : "-") + A(D, 2, "0") + ":" + A(k, 2, "0");
      },
      m: function L(I, R) {
        if (I.date() < R.date())
          return -L(R, I);
        var B = 12 * (R.year() - I.year()) + (R.month() - I.month()), D = I.clone().add(B, d), k = R - D < 0, F = I.clone().add(B + (k ? -1 : 1), d);
        return +(-(B + (R - D) / (k ? D - F : F - D)) || 0);
      },
      a: function(I) {
        return I < 0 ? Math.ceil(I) || 0 : Math.floor(I);
      },
      p: function(I) {
        return {
          M: d,
          y: p,
          w: c,
          d: u,
          D: f,
          h: l,
          m: a,
          s: o,
          ms: s,
          Q: h
        }[I] || String(I || "").toLowerCase().replace(/s$/, "");
      },
      u: function(I) {
        return I === void 0;
      }
    }, y = "en", S = {};
    S[y] = E;
    var b = function(I) {
      return I instanceof T;
    }, w = function(I, R, B) {
      var D;
      if (!I)
        return y;
      if (typeof I == "string")
        S[I] && (D = I), R && (S[I] = R, D = I);
      else {
        var k = I.name;
        S[k] = I, D = k;
      }
      return !B && D && (y = D), D || !B && y;
    }, P = function(I, R) {
      if (b(I))
        return I.clone();
      var B = Gr(R) == "object" ? R : {};
      return B.date = I, B.args = arguments, new T(B);
    }, C = _;
    C.l = w, C.i = b, C.w = function(L, I) {
      return P(L, {
        locale: I.$L,
        utc: I.$u,
        x: I.$x,
        $offset: I.$offset
      });
    };
    var T = function() {
      function L(R) {
        this.$L = w(R.locale, null, !0), this.parse(R);
      }
      var I = L.prototype;
      return I.parse = function(R) {
        this.$d = function(B) {
          var D = B.date, k = B.utc;
          if (D === null)
            return /* @__PURE__ */ new Date(NaN);
          if (C.u(D))
            return /* @__PURE__ */ new Date();
          if (D instanceof Date)
            return new Date(D);
          if (typeof D == "string" && !/Z$/i.test(D)) {
            var F = D.match(m);
            if (F) {
              var U = F[2] - 1 || 0, G = (F[7] || "0").substring(0, 3);
              return k ? new Date(Date.UTC(F[1], U, F[3] || 1, F[4] || 0, F[5] || 0, F[6] || 0, G)) : new Date(F[1], U, F[3] || 1, F[4] || 0, F[5] || 0, F[6] || 0, G);
            }
          }
          return new Date(D);
        }(R), this.$x = R.x || {}, this.init();
      }, I.init = function() {
        var R = this.$d;
        this.$y = R.getFullYear(), this.$M = R.getMonth(), this.$D = R.getDate(), this.$W = R.getDay(), this.$H = R.getHours(), this.$m = R.getMinutes(), this.$s = R.getSeconds(), this.$ms = R.getMilliseconds();
      }, I.$utils = function() {
        return C;
      }, I.isValid = function() {
        return this.$d.toString() !== g;
      }, I.isSame = function(R, B) {
        var D = P(R);
        return this.startOf(B) <= D && D <= this.endOf(B);
      }, I.isAfter = function(R, B) {
        return P(R) < this.startOf(B);
      }, I.isBefore = function(R, B) {
        return this.endOf(B) < P(R);
      }, I.$g = function(R, B, D) {
        return C.u(R) ? this[B] : this.set(D, R);
      }, I.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, I.valueOf = function() {
        return this.$d.getTime();
      }, I.startOf = function(R, B) {
        var D = this, k = !!C.u(B) || B, F = C.p(R), U = function(pe, ae) {
          var Ie = C.w(D.$u ? Date.UTC(D.$y, ae, pe) : new Date(D.$y, ae, pe), D);
          return k ? Ie : Ie.endOf(u);
        }, G = function(pe, ae) {
          return C.w(D.toDate()[pe].apply(D.toDate("s"), (k ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ae)), D);
        }, N = this.$W, V = this.$M, j = this.$D, ee = "set" + (this.$u ? "UTC" : "");
        switch (F) {
          case p:
            return k ? U(1, 0) : U(31, 11);
          case d:
            return k ? U(1, V) : U(0, V + 1);
          case c:
            var Y = this.$locale().weekStart || 0, te = (N < Y ? N + 7 : N) - Y;
            return U(k ? j - te : j + (6 - te), V);
          case u:
          case f:
            return G(ee + "Hours", 0);
          case l:
            return G(ee + "Minutes", 1);
          case a:
            return G(ee + "Seconds", 2);
          case o:
            return G(ee + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, I.endOf = function(R) {
        return this.startOf(R, !1);
      }, I.$set = function(R, B) {
        var D, k = C.p(R), F = "set" + (this.$u ? "UTC" : ""), U = (D = {}, D[u] = F + "Date", D[f] = F + "Date", D[d] = F + "Month", D[p] = F + "FullYear", D[l] = F + "Hours", D[a] = F + "Minutes", D[o] = F + "Seconds", D[s] = F + "Milliseconds", D)[k], G = k === u ? this.$D + (B - this.$W) : B;
        if (k === d || k === p) {
          var N = this.clone().set(f, 1);
          N.$d[U](G), N.init(), this.$d = N.set(f, Math.min(this.$D, N.daysInMonth())).$d;
        } else
          U && this.$d[U](G);
        return this.init(), this;
      }, I.set = function(R, B) {
        return this.clone().$set(R, B);
      }, I.get = function(R) {
        return this[C.p(R)]();
      }, I.add = function(R, B) {
        var D, k = this;
        R = Number(R);
        var F = C.p(B), U = function(j) {
          var ee = P(k);
          return C.w(ee.date(ee.date() + Math.round(j * R)), k);
        };
        if (F === d)
          return this.set(d, this.$M + R);
        if (F === p)
          return this.set(p, this.$y + R);
        if (F === u)
          return U(1);
        if (F === c)
          return U(7);
        var G = (D = {}, D[a] = r, D[l] = n, D[o] = t, D)[F] || 1, N = this.$d.getTime() + R * G;
        return C.w(N, this);
      }, I.subtract = function(R, B) {
        return this.add(-1 * R, B);
      }, I.format = function(R) {
        var B = this, D = this.$locale();
        if (!this.isValid())
          return D.invalidDate || g;
        var k = R || "YYYY-MM-DDTHH:mm:ssZ", F = C.z(this), U = this.$H, G = this.$m, N = this.$M, V = D.weekdays, j = D.months, ee = function(ae, Ie, ce, ie) {
          return ae && (ae[Ie] || ae(B, k)) || ce[Ie].substr(0, ie);
        }, Y = function(ae) {
          return C.s(U % 12 || 12, ae, "0");
        }, te = D.meridiem || function(pe, ae, Ie) {
          var ce = pe < 12 ? "AM" : "PM";
          return Ie ? ce.toLowerCase() : ce;
        }, oe = {
          YY: String(this.$y).slice(-2),
          YYYY: this.$y,
          M: N + 1,
          MM: C.s(N + 1, 2, "0"),
          MMM: ee(D.monthsShort, N, j, 3),
          MMMM: ee(j, N),
          D: this.$D,
          DD: C.s(this.$D, 2, "0"),
          d: String(this.$W),
          dd: ee(D.weekdaysMin, this.$W, V, 2),
          ddd: ee(D.weekdaysShort, this.$W, V, 3),
          dddd: V[this.$W],
          H: String(U),
          HH: C.s(U, 2, "0"),
          h: Y(1),
          hh: Y(2),
          a: te(U, G, !0),
          A: te(U, G, !1),
          m: String(G),
          mm: C.s(G, 2, "0"),
          s: String(this.$s),
          ss: C.s(this.$s, 2, "0"),
          SSS: C.s(this.$ms, 3, "0"),
          Z: F
        };
        return k.replace(v, function(pe, ae) {
          return ae || oe[pe] || F.replace(":", "");
        });
      }, I.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, I.diff = function(R, B, D) {
        var k, F = C.p(B), U = P(R), G = (U.utcOffset() - this.utcOffset()) * r, N = this - U, V = C.m(this, U);
        return V = (k = {}, k[p] = V / 12, k[d] = V, k[h] = V / 3, k[c] = (N - G) / 6048e5, k[u] = (N - G) / 864e5, k[l] = N / n, k[a] = N / r, k[o] = N / t, k)[F] || N, D ? V : C.a(V);
      }, I.daysInMonth = function() {
        return this.endOf(d).$D;
      }, I.$locale = function() {
        return S[this.$L];
      }, I.locale = function(R, B) {
        if (!R)
          return this.$L;
        var D = this.clone(), k = w(R, B, !0);
        return k && (D.$L = k), D;
      }, I.clone = function() {
        return C.w(this.$d, this);
      }, I.toDate = function() {
        return new Date(this.valueOf());
      }, I.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, I.toISOString = function() {
        return this.$d.toISOString();
      }, I.toString = function() {
        return this.$d.toUTCString();
      }, L;
    }(), x = T.prototype;
    return P.prototype = x, [["$ms", s], ["$s", o], ["$m", a], ["$H", l], ["$W", u], ["$M", d], ["$y", p], ["$D", f]].forEach(function(L) {
      x[L[1]] = function(I) {
        return this.$g(I, L[0], L[1]);
      };
    }), P.extend = function(L, I) {
      return L.$i || (L(I, T, P), L.$i = !0), P;
    }, P.locale = w, P.isDayjs = b, P.unix = function(L) {
      return P(1e3 * L);
    }, P.en = S[y], P.Ls = S, P.p = {}, P;
  });
})(wm);
var km = 1e3, Dm = function(i, e) {
  var t = Rm(i, typeof e == "number" ? e : km);
  return { run: t };
}, Om = { exports: {} };
/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
(function(i, e) {
  (function(t) {
    var r;
    if (i.exports = t(), r = !0, !r) {
      var n = window.Cookies, s = window.Cookies = t();
      s.noConflict = function() {
        return window.Cookies = n, s;
      };
    }
  })(function() {
    function t() {
      for (var s = 0, o = {}; s < arguments.length; s++) {
        var a = arguments[s];
        for (var l in a)
          o[l] = a[l];
      }
      return o;
    }
    function r(s) {
      return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
    }
    function n(s) {
      function o() {
      }
      function a(u, c, d) {
        if (!(typeof document > "u")) {
          d = t({
            path: "/"
          }, o.defaults, d), typeof d.expires == "number" && (d.expires = new Date(/* @__PURE__ */ new Date() * 1 + d.expires * 864e5)), d.expires = d.expires ? d.expires.toUTCString() : "";
          try {
            var h = JSON.stringify(c);
            /^[\{\[]/.test(h) && (c = h);
          } catch {
          }
          c = s.write ? s.write(c, u) : encodeURIComponent(String(c)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), u = encodeURIComponent(String(u)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var p = "";
          for (var f in d)
            d[f] && (p += "; " + f, d[f] !== !0 && (p += "=" + d[f].split(";")[0]));
          return document.cookie = u + "=" + c + p;
        }
      }
      function l(u, c) {
        if (!(typeof document > "u")) {
          for (var d = {}, h = document.cookie ? document.cookie.split("; ") : [], p = 0; p < h.length; p++) {
            var f = h[p].split("="), g = f.slice(1).join("=");
            !c && g.charAt(0) === '"' && (g = g.slice(1, -1));
            try {
              var m = r(f[0]);
              if (g = (s.read || s)(g, m) || r(g), c)
                try {
                  g = JSON.parse(g);
                } catch {
                }
              if (d[m] = g, u === m)
                break;
            } catch {
            }
          }
          return u ? d[u] : d;
        }
      }
      return o.set = a, o.get = function(u) {
        return l(
          u,
          !1
          /* read as raw */
        );
      }, o.getJSON = function(u) {
        return l(
          u,
          !0
          /* read as json */
        );
      }, o.remove = function(u, c) {
        a(u, "", t(c, {
          expires: -1
        }));
      }, o.defaults = {}, o.withConverter = n, o;
    }
    return n(function() {
    });
  });
})(Om);
var Xn = { exports: {} };
(function(i, e) {
  (function() {
    function t(h, p) {
      var f, g = Object.keys(p);
      for (f = 0; f < g.length; f++)
        h = h.replace(new RegExp("\\{" + g[f] + "\\}", "gi"), p[g[f]]);
      return h;
    }
    function r(h) {
      var p, f, g;
      if (!h)
        throw new Error("cannot create a random attribute name for an undefined object");
      p = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", f = "";
      do
        for (f = "", g = 0; g < 12; g++)
          f += p[Math.floor(Math.random() * p.length)];
      while (h[f]);
      return f;
    }
    function n(h) {
      var p = {
        left: "start",
        right: "end",
        center: "middle",
        start: "start",
        end: "end"
      };
      return p[h] || p.start;
    }
    function s(h) {
      var p = {
        alphabetic: "alphabetic",
        hanging: "hanging",
        top: "text-before-edge",
        bottom: "text-after-edge",
        middle: "central"
      };
      return p[h] || p.alphabetic;
    }
    var o, a, l, u, c;
    c = function(h, p) {
      var f, g, m, v = {};
      for (h = h.split(","), p = p || 10, f = 0; f < h.length; f += 2)
        g = "&" + h[f + 1] + ";", m = parseInt(h[f], p), v[g] = "&#" + m + ";";
      return v["\\xa0"] = "&#160;", v;
    }("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), o = {
      strokeStyle: {
        svgAttr: "stroke",
        canvas: "#000000",
        svg: "none",
        apply: "stroke"
      },
      fillStyle: {
        svgAttr: "fill",
        canvas: "#000000",
        svg: null,
        apply: "fill"
      },
      lineCap: {
        svgAttr: "stroke-linecap",
        canvas: "butt",
        svg: "butt",
        apply: "stroke"
      },
      lineJoin: {
        svgAttr: "stroke-linejoin",
        canvas: "miter",
        svg: "miter",
        apply: "stroke"
      },
      miterLimit: {
        svgAttr: "stroke-miterlimit",
        canvas: 10,
        svg: 4,
        apply: "stroke"
      },
      lineWidth: {
        svgAttr: "stroke-width",
        canvas: 1,
        svg: 1,
        apply: "stroke"
      },
      globalAlpha: {
        svgAttr: "opacity",
        canvas: 1,
        svg: 1,
        apply: "fill stroke"
      },
      font: {
        canvas: "10px sans-serif"
      },
      shadowColor: {
        canvas: "#000000"
      },
      shadowOffsetX: {
        canvas: 0
      },
      shadowOffsetY: {
        canvas: 0
      },
      shadowBlur: {
        canvas: 0
      },
      textAlign: {
        canvas: "start"
      },
      textBaseline: {
        canvas: "alphabetic"
      },
      lineDash: {
        svgAttr: "stroke-dasharray",
        canvas: [],
        svg: null,
        apply: "stroke"
      }
    }, l = function(p, f) {
      this.__root = p, this.__ctx = f;
    }, l.prototype.addColorStop = function(h, p) {
      var f, g, m = this.__ctx.__createElement("stop");
      m.setAttribute("offset", h), p.indexOf("rgba") !== -1 ? (f = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi, g = f.exec(p), m.setAttribute("stop-color", t("rgb({r},{g},{b})", {
        r: g[1],
        g: g[2],
        b: g[3]
      })), m.setAttribute("stop-opacity", g[4])) : m.setAttribute("stop-color", p), this.__root.appendChild(m);
    }, u = function(p, f) {
      this.__root = p, this.__ctx = f;
    }, a = function(p) {
      var f, g = {
        width: 500,
        height: 500,
        enableMirroring: !1
      };
      if (arguments.length > 1 ? (f = g, f.width = arguments[0], f.height = arguments[1]) : f = p || g, !(this instanceof a))
        return new a(f);
      this.width = f.width || g.width, this.height = f.height || g.height, this.enableMirroring = f.enableMirroring !== void 0 ? f.enableMirroring : g.enableMirroring, this.canvas = this, this.__document = f.document || document, f.ctx ? this.__ctx = f.ctx : (this.__canvas = this.__document.createElement("canvas"), this.__ctx = this.__canvas.getContext("2d")), this.__setDefaultStyles(), this.__stack = [this.__getStyleState()], this.__groupStack = [], this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg"), this.__root.setAttribute("version", 1.1), this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"), this.__root.setAttribute("width", this.width), this.__root.setAttribute("height", this.height), this.__ids = {}, this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs"), this.__root.appendChild(this.__defs), this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g"), this.__root.appendChild(this.__currentElement);
    }, a.prototype.__createElement = function(h, p, f) {
      p === void 0 && (p = {});
      var g, m, v = this.__document.createElementNS("http://www.w3.org/2000/svg", h), E = Object.keys(p);
      for (f && (v.setAttribute("fill", "none"), v.setAttribute("stroke", "none")), g = 0; g < E.length; g++)
        m = E[g], v.setAttribute(m, p[m]);
      return v;
    }, a.prototype.__setDefaultStyles = function() {
      var h, p, f = Object.keys(o);
      for (h = 0; h < f.length; h++)
        p = f[h], this[p] = o[p].canvas;
    }, a.prototype.__applyStyleState = function(h) {
      var p, f, g = Object.keys(h);
      for (p = 0; p < g.length; p++)
        f = g[p], this[f] = h[f];
    }, a.prototype.__getStyleState = function() {
      var h, p, f = {}, g = Object.keys(o);
      for (h = 0; h < g.length; h++)
        p = g[h], f[p] = this[p];
      return f;
    }, a.prototype.__applyStyleToCurrentElement = function(h) {
      var p = this.__currentElement, f = this.__currentElementsToStyle;
      f && (p.setAttribute(h, ""), p = f.element, f.children.forEach(function(P) {
        P.setAttribute(h, "");
      }));
      var g, m, v, E, A, _, y = Object.keys(o);
      for (g = 0; g < y.length; g++)
        if (m = o[y[g]], v = this[y[g]], m.apply) {
          if (v instanceof u) {
            if (v.__ctx)
              for (; v.__ctx.__defs.childNodes.length; )
                E = v.__ctx.__defs.childNodes[0].getAttribute("id"), this.__ids[E] = E, this.__defs.appendChild(v.__ctx.__defs.childNodes[0]);
            p.setAttribute(m.apply, t("url(#{id})", {
              id: v.__root.getAttribute("id")
            }));
          } else if (v instanceof l)
            p.setAttribute(m.apply, t("url(#{id})", {
              id: v.__root.getAttribute("id")
            }));
          else if (m.apply.indexOf(h) !== -1 && m.svg !== v)
            if (m.svgAttr !== "stroke" && m.svgAttr !== "fill" || v.indexOf("rgba") === -1) {
              var S = m.svgAttr;
              if (y[g] === "globalAlpha" && (S = h + "-" + m.svgAttr, p.getAttribute(S)))
                continue;
              p.setAttribute(S, v);
            } else {
              A = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi, _ = A.exec(v), p.setAttribute(m.svgAttr, t("rgb({r},{g},{b})", {
                r: _[1],
                g: _[2],
                b: _[3]
              }));
              var b = _[4], w = this.globalAlpha;
              w != null && (b *= w), p.setAttribute(m.svgAttr + "-opacity", b);
            }
        }
    }, a.prototype.__closestGroupOrSvg = function(h) {
      return h = h || this.__currentElement, h.nodeName === "g" || h.nodeName === "svg" ? h : this.__closestGroupOrSvg(h.parentNode);
    }, a.prototype.getSerializedSvg = function(h) {
      var p, f, g, m, v, E, A = new XMLSerializer().serializeToString(this.__root);
      if (E = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi, E.test(A) && (A = A.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink')), h)
        for (p = Object.keys(c), f = 0; f < p.length; f++)
          g = p[f], m = c[g], v = new RegExp(g, "gi"), v.test(A) && (A = A.replace(v, m));
      return A;
    }, a.prototype.getSvg = function() {
      return this.__root;
    }, a.prototype.save = function() {
      var h = this.__createElement("g"), p = this.__closestGroupOrSvg();
      this.__groupStack.push(p), p.appendChild(h), this.__currentElement = h, this.__stack.push(this.__getStyleState());
    }, a.prototype.restore = function() {
      this.__currentElement = this.__groupStack.pop(), this.__currentElementsToStyle = null, this.__currentElement || (this.__currentElement = this.__root.childNodes[1]);
      var h = this.__stack.pop();
      this.__applyStyleState(h);
    }, a.prototype.__addTransform = function(h) {
      var p = this.__closestGroupOrSvg();
      if (p.childNodes.length > 0) {
        this.__currentElement.nodeName === "path" && (this.__currentElementsToStyle || (this.__currentElementsToStyle = {
          element: p,
          children: []
        }), this.__currentElementsToStyle.children.push(this.__currentElement), this.__applyCurrentDefaultPath());
        var f = this.__createElement("g");
        p.appendChild(f), this.__currentElement = f;
      }
      var g = this.__currentElement.getAttribute("transform");
      g ? g += " " : g = "", g += h, this.__currentElement.setAttribute("transform", g);
    }, a.prototype.scale = function(h, p) {
      p === void 0 && (p = h), this.__addTransform(t("scale({x},{y})", {
        x: h,
        y: p
      }));
    }, a.prototype.rotate = function(h) {
      var p = 180 * h / Math.PI;
      this.__addTransform(t("rotate({angle},{cx},{cy})", {
        angle: p,
        cx: 0,
        cy: 0
      }));
    }, a.prototype.translate = function(h, p) {
      this.__addTransform(t("translate({x},{y})", {
        x: h,
        y: p
      }));
    }, a.prototype.transform = function(h, p, f, g, m, v) {
      this.__addTransform(t("matrix({a},{b},{c},{d},{e},{f})", {
        a: h,
        b: p,
        c: f,
        d: g,
        e: m,
        f: v
      }));
    }, a.prototype.beginPath = function() {
      var h, p;
      this.__currentDefaultPath = "", this.__currentPosition = {}, h = this.__createElement("path", {}, !0), p = this.__closestGroupOrSvg(), p.appendChild(h), this.__currentElement = h;
    }, a.prototype.__applyCurrentDefaultPath = function() {
      var h = this.__currentElement;
      h.nodeName === "path" ? h.setAttribute("d", this.__currentDefaultPath) : console.error("Attempted to apply path command to node", h.nodeName);
    }, a.prototype.__addPathCommand = function(h) {
      this.__currentDefaultPath += " ", this.__currentDefaultPath += h;
    }, a.prototype.moveTo = function(h, p) {
      this.__currentElement.nodeName !== "path" && this.beginPath(), this.__currentPosition = {
        x: h,
        y: p
      }, this.__addPathCommand(t("M {x} {y}", {
        x: h,
        y: p
      }));
    }, a.prototype.closePath = function() {
      this.__currentDefaultPath && this.__addPathCommand("Z");
    }, a.prototype.lineTo = function(h, p) {
      this.__currentPosition = {
        x: h,
        y: p
      }, this.__currentDefaultPath.indexOf("M") > -1 ? this.__addPathCommand(t("L {x} {y}", {
        x: h,
        y: p
      })) : this.__addPathCommand(t("M {x} {y}", {
        x: h,
        y: p
      }));
    }, a.prototype.bezierCurveTo = function(h, p, f, g, m, v) {
      this.__currentPosition = {
        x: m,
        y: v
      }, this.__addPathCommand(t("C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}", {
        cp1x: h,
        cp1y: p,
        cp2x: f,
        cp2y: g,
        x: m,
        y: v
      }));
    }, a.prototype.quadraticCurveTo = function(h, p, f, g) {
      this.__currentPosition = {
        x: f,
        y: g
      }, this.__addPathCommand(t("Q {cpx} {cpy} {x} {y}", {
        cpx: h,
        cpy: p,
        x: f,
        y: g
      }));
    };
    var d = function(p) {
      var f = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
      return [p[0] / f, p[1] / f];
    };
    a.prototype.arcTo = function(h, p, f, g, m) {
      var v = this.__currentPosition && this.__currentPosition.x, E = this.__currentPosition && this.__currentPosition.y;
      if (v !== void 0 && E !== void 0) {
        if (m < 0)
          throw new Error("IndexSizeError: The radius provided (" + m + ") is negative.");
        if (v === h && E === p || h === f && p === g || m === 0)
          return void this.lineTo(h, p);
        var A = d([v - h, E - p]), _ = d([f - h, g - p]);
        if (A[0] * _[1] == A[1] * _[0])
          return void this.lineTo(h, p);
        var y = A[0] * _[0] + A[1] * _[1], S = Math.acos(Math.abs(y)), b = d([A[0] + _[0], A[1] + _[1]]), w = m / Math.sin(S / 2), P = h + w * b[0], C = p + w * b[1], T = [-A[1], A[0]], x = [_[1], -_[0]], L = function(D) {
          var k = D[0];
          return D[1] >= 0 ? Math.acos(k) : -Math.acos(k);
        }, I = L(T), R = L(x);
        this.lineTo(P + T[0] * m, C + T[1] * m), this.arc(P, C, m, I, R);
      }
    }, a.prototype.stroke = function() {
      this.__currentElement.nodeName === "path" && this.__currentElement.setAttribute("paint-order", "fill stroke markers"), this.__applyCurrentDefaultPath(), this.__applyStyleToCurrentElement("stroke");
    }, a.prototype.fill = function() {
      this.__currentElement.nodeName === "path" && this.__currentElement.setAttribute("paint-order", "stroke fill markers"), this.__applyCurrentDefaultPath(), this.__applyStyleToCurrentElement("fill");
    }, a.prototype.rect = function(h, p, f, g) {
      this.__currentElement.nodeName !== "path" && this.beginPath(), this.moveTo(h, p), this.lineTo(h + f, p), this.lineTo(h + f, p + g), this.lineTo(h, p + g), this.lineTo(h, p), this.closePath();
    }, a.prototype.fillRect = function(h, p, f, g) {
      var m, v;
      m = this.__createElement("rect", {
        x: h,
        y: p,
        width: f,
        height: g,
        "shape-rendering": "crispEdges"
      }, !0), v = this.__closestGroupOrSvg(), v.appendChild(m), this.__currentElement = m, this.__applyStyleToCurrentElement("fill");
    }, a.prototype.strokeRect = function(h, p, f, g) {
      var m, v;
      m = this.__createElement("rect", {
        x: h,
        y: p,
        width: f,
        height: g
      }, !0), v = this.__closestGroupOrSvg(), v.appendChild(m), this.__currentElement = m, this.__applyStyleToCurrentElement("stroke");
    }, a.prototype.__clearCanvas = function() {
      for (var h = this.__closestGroupOrSvg(), p = h.getAttribute("transform"), f = this.__root.childNodes[1], g = f.childNodes, m = g.length - 1; m >= 0; m--)
        g[m] && f.removeChild(g[m]);
      this.__currentElement = f, this.__groupStack = [], p && this.__addTransform(p);
    }, a.prototype.clearRect = function(h, p, f, g) {
      if (h === 0 && p === 0 && f === this.width && g === this.height)
        return void this.__clearCanvas();
      var m, v = this.__closestGroupOrSvg();
      m = this.__createElement("rect", {
        x: h,
        y: p,
        width: f,
        height: g,
        fill: "#FFFFFF"
      }, !0), v.appendChild(m);
    }, a.prototype.createLinearGradient = function(h, p, f, g) {
      var m = this.__createElement("linearGradient", {
        id: r(this.__ids),
        x1: h + "px",
        x2: f + "px",
        y1: p + "px",
        y2: g + "px",
        gradientUnits: "userSpaceOnUse"
      }, !1);
      return this.__defs.appendChild(m), new l(m, this);
    }, a.prototype.createRadialGradient = function(h, p, f, g, m, v) {
      var E = this.__createElement("radialGradient", {
        id: r(this.__ids),
        cx: g + "px",
        cy: m + "px",
        r: v + "px",
        fx: h + "px",
        fy: p + "px",
        gradientUnits: "userSpaceOnUse"
      }, !1);
      return this.__defs.appendChild(E), new l(E, this);
    }, a.prototype.__parseFont = function() {
      var h = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i, p = h.exec(this.font), f = {
        style: p[1] || "normal",
        size: p[4] || "10px",
        family: p[6] || "sans-serif",
        weight: p[3] || "normal",
        decoration: p[2] || "normal",
        href: null
      };
      return this.__fontUnderline === "underline" && (f.decoration = "underline"), this.__fontHref && (f.href = this.__fontHref), f;
    }, a.prototype.__wrapTextLink = function(h, p) {
      if (h.href) {
        var f = this.__createElement("a");
        return f.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", h.href), f.appendChild(p), f;
      }
      return p;
    }, a.prototype.__applyText = function(h, p, f, g) {
      var m = this.__parseFont(), v = this.__closestGroupOrSvg(), E = this.__createElement("text", {
        "font-family": m.family,
        "font-size": m.size,
        "font-style": m.style,
        "font-weight": m.weight,
        "text-decoration": m.decoration,
        x: p,
        y: f,
        "text-anchor": n(this.textAlign),
        "dominant-baseline": s(this.textBaseline)
      }, !0);
      E.appendChild(this.__document.createTextNode(h)), this.__currentElement = E, this.__applyStyleToCurrentElement(g), v.appendChild(this.__wrapTextLink(m, E));
    }, a.prototype.fillText = function(h, p, f) {
      this.__applyText(h, p, f, "fill");
    }, a.prototype.strokeText = function(h, p, f) {
      this.__applyText(h, p, f, "stroke");
    }, a.prototype.measureText = function(h) {
      return this.__ctx.font = this.font, this.__ctx.measureText(h);
    }, a.prototype.arc = function(h, p, f, g, m, v) {
      if (g !== m) {
        g %= 2 * Math.PI, m %= 2 * Math.PI, g === m && (m = (m + 2 * Math.PI - 1e-3 * (v ? -1 : 1)) % (2 * Math.PI));
        var E = h + f * Math.cos(m), A = p + f * Math.sin(m), _ = h + f * Math.cos(g), y = p + f * Math.sin(g), S = v ? 0 : 1, b = 0, w = m - g;
        w < 0 && (w += 2 * Math.PI), b = v ? w > Math.PI ? 0 : 1 : w > Math.PI ? 1 : 0, this.lineTo(_, y), this.__addPathCommand(t("A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}", {
          rx: f,
          ry: f,
          xAxisRotation: 0,
          largeArcFlag: b,
          sweepFlag: S,
          endX: E,
          endY: A
        })), this.__currentPosition = {
          x: E,
          y: A
        };
      }
    }, a.prototype.clip = function() {
      var h = this.__closestGroupOrSvg(), p = this.__createElement("clipPath"), f = r(this.__ids), g = this.__createElement("g");
      this.__applyCurrentDefaultPath(), h.removeChild(this.__currentElement), p.setAttribute("id", f), p.appendChild(this.__currentElement), this.__defs.appendChild(p), h.setAttribute("clip-path", t("url(#{id})", {
        id: f
      })), h.appendChild(g), this.__currentElement = g;
    }, a.prototype.drawImage = function() {
      var h, p, f, g, m, v, E, A, _, y, S, b, w, P, C = Array.prototype.slice.call(arguments), T = C[0], x = 0, L = 0;
      if (C.length === 3)
        h = C[1], p = C[2], m = T.width, v = T.height, f = m, g = v;
      else if (C.length === 5)
        h = C[1], p = C[2], f = C[3], g = C[4], m = T.width, v = T.height;
      else {
        if (C.length !== 9)
          throw new Error("Invalid number of arguments passed to drawImage: " + arguments.length);
        x = C[1], L = C[2], m = C[3], v = C[4], h = C[5], p = C[6], f = C[7], g = C[8];
      }
      E = this.__closestGroupOrSvg(), this.__currentElement;
      var I = "translate(" + h + ", " + p + ")";
      if (T instanceof a) {
        if (A = T.getSvg().cloneNode(!0), A.childNodes && A.childNodes.length > 1) {
          for (_ = A.childNodes[0]; _.childNodes.length; )
            P = _.childNodes[0].getAttribute("id"), this.__ids[P] = P, this.__defs.appendChild(_.childNodes[0]);
          if (y = A.childNodes[1]) {
            var R, B = y.getAttribute("transform");
            R = B ? B + " " + I : I, y.setAttribute("transform", R), E.appendChild(y);
          }
        }
      } else
        T.nodeName !== "CANVAS" && T.nodeName !== "IMG" || (S = this.__createElement("image"), S.setAttribute("width", f), S.setAttribute("height", g), S.setAttribute("preserveAspectRatio", "none"), S.setAttribute("opacity", this.globalAlpha), (x || L || m !== T.width || v !== T.height) && (b = this.__document.createElement("canvas"), b.width = f, b.height = g, w = b.getContext("2d"), w.drawImage(T, x, L, m, v, 0, 0, f, g), T = b), S.setAttribute("transform", I), S.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", T.nodeName === "CANVAS" ? T.toDataURL() : T.originalSrc), E.appendChild(S));
    }, a.prototype.createPattern = function(h, p) {
      var f, g = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"), m = r(this.__ids);
      return g.setAttribute("id", m), g.setAttribute("width", h.width), g.setAttribute("height", h.height), h.nodeName === "CANVAS" || h.nodeName === "IMG" ? (f = this.__document.createElementNS("http://www.w3.org/2000/svg", "image"), f.setAttribute("width", h.width), f.setAttribute("height", h.height), f.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", h.nodeName === "CANVAS" ? h.toDataURL() : h.getAttribute("src")), g.appendChild(f), this.__defs.appendChild(g)) : h instanceof a && (g.appendChild(h.__root.childNodes[1]), this.__defs.appendChild(g)), new u(g, this);
    }, a.prototype.setLineDash = function(h) {
      h && h.length > 0 ? this.lineDash = h.join(",") : this.lineDash = null;
    }, a.prototype.drawFocusRing = function() {
    }, a.prototype.createImageData = function() {
    }, a.prototype.getImageData = function() {
    }, a.prototype.putImageData = function() {
    }, a.prototype.globalCompositeOperation = function() {
    }, a.prototype.setTransform = function() {
    }, (typeof window > "u" ? "undefined" : Gr(window)) == "object" && (window.C2S = a), i.exports = a;
  })(), function() {
    function t(C, T) {
      this.mode = E.MODE_8BIT_BYTE, this.data = C, this.parsedData = [];
      for (var x = 0, L = this.data.length; x < L; x++) {
        var I = [], R = this.data.charCodeAt(x);
        T ? I[0] = R : R > 65536 ? (I[0] = 240 | (1835008 & R) >>> 18, I[1] = 128 | (258048 & R) >>> 12, I[2] = 128 | (4032 & R) >>> 6, I[3] = 128 | 63 & R) : R > 2048 ? (I[0] = 224 | (61440 & R) >>> 12, I[1] = 128 | (4032 & R) >>> 6, I[2] = 128 | 63 & R) : R > 128 ? (I[0] = 192 | (1984 & R) >>> 6, I[1] = 128 | 63 & R) : I[0] = R, this.parsedData.push(I);
      }
      this.parsedData = Array.prototype.concat.apply([], this.parsedData), this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239));
    }
    function r(C, T) {
      this.typeNumber = C, this.errorCorrectLevel = T, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
    }
    function n(C, T) {
      if (C.length == c)
        throw new Error(C.length + "/" + T);
      for (var x = 0; x < C.length && C[x] == 0; )
        x++;
      this.num = new Array(C.length - x + T);
      for (var L = 0; L < C.length - x; L++)
        this.num[L] = C[L + x];
    }
    function s(C, T) {
      this.totalCount = C, this.dataCount = T;
    }
    function o() {
      this.buffer = [], this.length = 0;
    }
    function a() {
      var C = !1, T = navigator.userAgent;
      if (/android/i.test(T)) {
        C = !0;
        var x = T.toString().match(/android ([0-9]\.[0-9])/i);
        x && x[1] && (C = parseFloat(x[1]));
      }
      return C;
    }
    function l(C, T) {
      for (var x = T.correctLevel, L = 1, I = u(C), R = 0, B = w.length; R < B; R++) {
        var D = 0;
        switch (x) {
          case A.L:
            D = w[R][0];
            break;
          case A.M:
            D = w[R][1];
            break;
          case A.Q:
            D = w[R][2];
            break;
          case A.H:
            D = w[R][3];
        }
        if (I <= D)
          break;
        L++;
      }
      if (L > w.length)
        throw new Error("Too long data. the CorrectLevel." + ["M", "L", "H", "Q"][x] + " limit length is " + D);
      return T.version != 0 && (L <= T.version ? (L = T.version, T.runVersion = L) : (console.warn("QR Code version " + T.version + " too small, run version use " + L), T.runVersion = L)), L;
    }
    function u(C) {
      var T = encodeURI(C).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
      return T.length + (T.length != C.length ? 3 : 0);
    }
    var c, d, h = Gr(Nr) == "object" && Nr && Nr.Object === Object && Nr, p = (typeof self > "u" ? "undefined" : Gr(self)) == "object" && self && self.Object === Object && self, f = h || p || Function("return this")(), g = e && !e.nodeType && e, m = g && !0 && i && !i.nodeType && i, v = f.QRCode;
    t.prototype = {
      getLength: function(T) {
        return this.parsedData.length;
      },
      write: function(T) {
        for (var x = 0, L = this.parsedData.length; x < L; x++)
          T.put(this.parsedData[x], 8);
      }
    }, r.prototype = {
      addData: function(T, x) {
        var L = new t(T, x);
        this.dataList.push(L), this.dataCache = null;
      },
      isDark: function(T, x) {
        if (T < 0 || this.moduleCount <= T || x < 0 || this.moduleCount <= x)
          throw new Error(T + "," + x);
        return this.modules[T][x][0];
      },
      getEye: function(T, x) {
        if (T < 0 || this.moduleCount <= T || x < 0 || this.moduleCount <= x)
          throw new Error(T + "," + x);
        var L = this.modules[T][x];
        if (L[1]) {
          var I = "P" + L[1] + "_" + L[2];
          return L[2] == "A" && (I = "A" + L[1]), {
            isDark: L[0],
            type: I
          };
        }
        return null;
      },
      getModuleCount: function() {
        return this.moduleCount;
      },
      make: function() {
        this.makeImpl(!1, this.getBestMaskPattern());
      },
      makeImpl: function(T, x) {
        this.moduleCount = 4 * this.typeNumber + 17, this.modules = new Array(this.moduleCount);
        for (var L = 0; L < this.moduleCount; L++) {
          this.modules[L] = new Array(this.moduleCount);
          for (var I = 0; I < this.moduleCount; I++)
            this.modules[L][I] = [];
        }
        this.setupPositionProbePattern(0, 0, "TL"), this.setupPositionProbePattern(this.moduleCount - 7, 0, "BL"), this.setupPositionProbePattern(0, this.moduleCount - 7, "TR"), this.setupPositionAdjustPattern("A"), this.setupTimingPattern(), this.setupTypeInfo(T, x), this.typeNumber >= 7 && this.setupTypeNumber(T), this.dataCache == null && (this.dataCache = r.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, x);
      },
      setupPositionProbePattern: function(T, x, L) {
        for (var I = -1; I <= 7; I++)
          if (!(T + I <= -1 || this.moduleCount <= T + I))
            for (var R = -1; R <= 7; R++)
              x + R <= -1 || this.moduleCount <= x + R || (0 <= I && I <= 6 && (R == 0 || R == 6) || 0 <= R && R <= 6 && (I == 0 || I == 6) || 2 <= I && I <= 4 && 2 <= R && R <= 4 ? (this.modules[T + I][x + R][0] = !0, this.modules[T + I][x + R][2] = L, this.modules[T + I][x + R][1] = I == -0 || R == -0 || I == 6 || R == 6 ? "O" : "I") : this.modules[T + I][x + R][0] = !1);
      },
      getBestMaskPattern: function() {
        for (var T = 0, x = 0, L = 0; L < 8; L++) {
          this.makeImpl(!0, L);
          var I = y.getLostPoint(this);
          (L == 0 || T > I) && (T = I, x = L);
        }
        return x;
      },
      createMovieClip: function(T, x, L) {
        var I = T.createEmptyMovieClip(x, L);
        this.make();
        for (var R = 0; R < this.modules.length; R++)
          for (var B = 1 * R, D = 0; D < this.modules[R].length; D++) {
            var k = 1 * D, F = this.modules[R][D][0];
            F && (I.beginFill(0, 100), I.moveTo(k, B), I.lineTo(k + 1, B), I.lineTo(k + 1, B + 1), I.lineTo(k, B + 1), I.endFill());
          }
        return I;
      },
      setupTimingPattern: function() {
        for (var T = 8; T < this.moduleCount - 8; T++)
          this.modules[T][6][0] == null && (this.modules[T][6][0] = T % 2 == 0);
        for (var x = 8; x < this.moduleCount - 8; x++)
          this.modules[6][x][0] == null && (this.modules[6][x][0] = x % 2 == 0);
      },
      setupPositionAdjustPattern: function(T) {
        for (var x = y.getPatternPosition(this.typeNumber), L = 0; L < x.length; L++)
          for (var I = 0; I < x.length; I++) {
            var R = x[L], B = x[I];
            if (this.modules[R][B][0] == null)
              for (var D = -2; D <= 2; D++)
                for (var k = -2; k <= 2; k++)
                  D == -2 || D == 2 || k == -2 || k == 2 || D == 0 && k == 0 ? (this.modules[R + D][B + k][0] = !0, this.modules[R + D][B + k][2] = T, this.modules[R + D][B + k][1] = D == -2 || k == -2 || D == 2 || k == 2 ? "O" : "I") : this.modules[R + D][B + k][0] = !1;
          }
      },
      setupTypeNumber: function(T) {
        for (var x = y.getBCHTypeNumber(this.typeNumber), L = 0; L < 18; L++) {
          var I = !T && (x >> L & 1) == 1;
          this.modules[Math.floor(L / 3)][L % 3 + this.moduleCount - 8 - 3][0] = I;
        }
        for (var L = 0; L < 18; L++) {
          var I = !T && (x >> L & 1) == 1;
          this.modules[L % 3 + this.moduleCount - 8 - 3][Math.floor(L / 3)][0] = I;
        }
      },
      setupTypeInfo: function(T, x) {
        for (var L = this.errorCorrectLevel << 3 | x, I = y.getBCHTypeInfo(L), R = 0; R < 15; R++) {
          var B = !T && (I >> R & 1) == 1;
          R < 6 ? this.modules[R][8][0] = B : R < 8 ? this.modules[R + 1][8][0] = B : this.modules[this.moduleCount - 15 + R][8][0] = B;
        }
        for (var R = 0; R < 15; R++) {
          var B = !T && (I >> R & 1) == 1;
          R < 8 ? this.modules[8][this.moduleCount - R - 1][0] = B : R < 9 ? this.modules[8][15 - R - 1 + 1][0] = B : this.modules[8][15 - R - 1][0] = B;
        }
        this.modules[this.moduleCount - 8][8][0] = !T;
      },
      mapData: function(T, x) {
        for (var L = -1, I = this.moduleCount - 1, R = 7, B = 0, D = this.moduleCount - 1; D > 0; D -= 2)
          for (D == 6 && D--; ; ) {
            for (var k = 0; k < 2; k++)
              if (this.modules[I][D - k][0] == null) {
                var F = !1;
                B < T.length && (F = (T[B] >>> R & 1) == 1);
                var U = y.getMask(x, I, D - k);
                U && (F = !F), this.modules[I][D - k][0] = F, R--, R == -1 && (B++, R = 7);
              }
            if ((I += L) < 0 || this.moduleCount <= I) {
              I -= L, L = -L;
              break;
            }
          }
      }
    }, r.PAD0 = 236, r.PAD1 = 17, r.createData = function(C, T, x) {
      for (var L = s.getRSBlocks(C, T), I = new o(), R = 0; R < x.length; R++) {
        var B = x[R];
        I.put(B.mode, 4), I.put(B.getLength(), y.getLengthInBits(B.mode, C)), B.write(I);
      }
      for (var D = 0, R = 0; R < L.length; R++)
        D += L[R].dataCount;
      if (I.getLengthInBits() > 8 * D)
        throw new Error("code length overflow. (" + I.getLengthInBits() + ">" + 8 * D + ")");
      for (I.getLengthInBits() + 4 <= 8 * D && I.put(0, 4); I.getLengthInBits() % 8 != 0; )
        I.putBit(!1);
      for (; !(I.getLengthInBits() >= 8 * D || (I.put(r.PAD0, 8), I.getLengthInBits() >= 8 * D)); )
        I.put(r.PAD1, 8);
      return r.createBytes(I, L);
    }, r.createBytes = function(C, T) {
      for (var x = 0, L = 0, I = 0, R = new Array(T.length), B = new Array(T.length), D = 0; D < T.length; D++) {
        var k = T[D].dataCount, F = T[D].totalCount - k;
        L = Math.max(L, k), I = Math.max(I, F), R[D] = new Array(k);
        for (var U = 0; U < R[D].length; U++)
          R[D][U] = 255 & C.buffer[U + x];
        x += k;
        var G = y.getErrorCorrectPolynomial(F), N = new n(R[D], G.getLength() - 1), V = N.mod(G);
        B[D] = new Array(G.getLength() - 1);
        for (var U = 0; U < B[D].length; U++) {
          var j = U + V.getLength() - B[D].length;
          B[D][U] = j >= 0 ? V.get(j) : 0;
        }
      }
      for (var ee = 0, U = 0; U < T.length; U++)
        ee += T[U].totalCount;
      for (var Y = new Array(ee), te = 0, U = 0; U < L; U++)
        for (var D = 0; D < T.length; D++)
          U < R[D].length && (Y[te++] = R[D][U]);
      for (var U = 0; U < I; U++)
        for (var D = 0; D < T.length; D++)
          U < B[D].length && (Y[te++] = B[D][U]);
      return Y;
    };
    for (var E = {
      MODE_NUMBER: 1,
      MODE_ALPHA_NUM: 2,
      MODE_8BIT_BYTE: 4,
      MODE_KANJI: 8
    }, A = {
      L: 1,
      M: 0,
      Q: 3,
      H: 2
    }, _ = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    }, y = {
      PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
      G15: 1335,
      G18: 7973,
      G15_MASK: 21522,
      getBCHTypeInfo: function(T) {
        for (var x = T << 10; y.getBCHDigit(x) - y.getBCHDigit(y.G15) >= 0; )
          x ^= y.G15 << y.getBCHDigit(x) - y.getBCHDigit(y.G15);
        return (T << 10 | x) ^ y.G15_MASK;
      },
      getBCHTypeNumber: function(T) {
        for (var x = T << 12; y.getBCHDigit(x) - y.getBCHDigit(y.G18) >= 0; )
          x ^= y.G18 << y.getBCHDigit(x) - y.getBCHDigit(y.G18);
        return T << 12 | x;
      },
      getBCHDigit: function(T) {
        for (var x = 0; T != 0; )
          x++, T >>>= 1;
        return x;
      },
      getPatternPosition: function(T) {
        return y.PATTERN_POSITION_TABLE[T - 1];
      },
      getMask: function(T, x, L) {
        switch (T) {
          case _.PATTERN000:
            return (x + L) % 2 == 0;
          case _.PATTERN001:
            return x % 2 == 0;
          case _.PATTERN010:
            return L % 3 == 0;
          case _.PATTERN011:
            return (x + L) % 3 == 0;
          case _.PATTERN100:
            return (Math.floor(x / 2) + Math.floor(L / 3)) % 2 == 0;
          case _.PATTERN101:
            return x * L % 2 + x * L % 3 == 0;
          case _.PATTERN110:
            return (x * L % 2 + x * L % 3) % 2 == 0;
          case _.PATTERN111:
            return (x * L % 3 + (x + L) % 2) % 2 == 0;
          default:
            throw new Error("bad maskPattern:" + T);
        }
      },
      getErrorCorrectPolynomial: function(T) {
        for (var x = new n([1], 0), L = 0; L < T; L++)
          x = x.multiply(new n([1, S.gexp(L)], 0));
        return x;
      },
      getLengthInBits: function(T, x) {
        if (1 <= x && x < 10)
          switch (T) {
            case E.MODE_NUMBER:
              return 10;
            case E.MODE_ALPHA_NUM:
              return 9;
            case E.MODE_8BIT_BYTE:
            case E.MODE_KANJI:
              return 8;
            default:
              throw new Error("mode:" + T);
          }
        else if (x < 27)
          switch (T) {
            case E.MODE_NUMBER:
              return 12;
            case E.MODE_ALPHA_NUM:
              return 11;
            case E.MODE_8BIT_BYTE:
              return 16;
            case E.MODE_KANJI:
              return 10;
            default:
              throw new Error("mode:" + T);
          }
        else {
          if (!(x < 41))
            throw new Error("type:" + x);
          switch (T) {
            case E.MODE_NUMBER:
              return 14;
            case E.MODE_ALPHA_NUM:
              return 13;
            case E.MODE_8BIT_BYTE:
              return 16;
            case E.MODE_KANJI:
              return 12;
            default:
              throw new Error("mode:" + T);
          }
        }
      },
      getLostPoint: function(T) {
        for (var x = T.getModuleCount(), L = 0, I = 0; I < x; I++)
          for (var R = 0; R < x; R++) {
            for (var B = 0, D = T.isDark(I, R), k = -1; k <= 1; k++)
              if (!(I + k < 0 || x <= I + k))
                for (var F = -1; F <= 1; F++)
                  R + F < 0 || x <= R + F || k == 0 && F == 0 || D == T.isDark(I + k, R + F) && B++;
            B > 5 && (L += 3 + B - 5);
          }
        for (var I = 0; I < x - 1; I++)
          for (var R = 0; R < x - 1; R++) {
            var U = 0;
            T.isDark(I, R) && U++, T.isDark(I + 1, R) && U++, T.isDark(I, R + 1) && U++, T.isDark(I + 1, R + 1) && U++, U != 0 && U != 4 || (L += 3);
          }
        for (var I = 0; I < x; I++)
          for (var R = 0; R < x - 6; R++)
            T.isDark(I, R) && !T.isDark(I, R + 1) && T.isDark(I, R + 2) && T.isDark(I, R + 3) && T.isDark(I, R + 4) && !T.isDark(I, R + 5) && T.isDark(I, R + 6) && (L += 40);
        for (var R = 0; R < x; R++)
          for (var I = 0; I < x - 6; I++)
            T.isDark(I, R) && !T.isDark(I + 1, R) && T.isDark(I + 2, R) && T.isDark(I + 3, R) && T.isDark(I + 4, R) && !T.isDark(I + 5, R) && T.isDark(I + 6, R) && (L += 40);
        for (var G = 0, R = 0; R < x; R++)
          for (var I = 0; I < x; I++)
            T.isDark(I, R) && G++;
        return L += Math.abs(100 * G / x / x - 50) / 5 * 10;
      }
    }, S = {
      glog: function(T) {
        if (T < 1)
          throw new Error("glog(" + T + ")");
        return S.LOG_TABLE[T];
      },
      gexp: function(T) {
        for (; T < 0; )
          T += 255;
        for (; T >= 256; )
          T -= 255;
        return S.EXP_TABLE[T];
      },
      EXP_TABLE: new Array(256),
      LOG_TABLE: new Array(256)
    }, b = 0; b < 8; b++)
      S.EXP_TABLE[b] = 1 << b;
    for (var b = 8; b < 256; b++)
      S.EXP_TABLE[b] = S.EXP_TABLE[b - 4] ^ S.EXP_TABLE[b - 5] ^ S.EXP_TABLE[b - 6] ^ S.EXP_TABLE[b - 8];
    for (var b = 0; b < 255; b++)
      S.LOG_TABLE[S.EXP_TABLE[b]] = b;
    n.prototype = {
      get: function(T) {
        return this.num[T];
      },
      getLength: function() {
        return this.num.length;
      },
      multiply: function(T) {
        for (var x = new Array(this.getLength() + T.getLength() - 1), L = 0; L < this.getLength(); L++)
          for (var I = 0; I < T.getLength(); I++)
            x[L + I] ^= S.gexp(S.glog(this.get(L)) + S.glog(T.get(I)));
        return new n(x, 0);
      },
      mod: function(T) {
        if (this.getLength() - T.getLength() < 0)
          return this;
        for (var x = S.glog(this.get(0)) - S.glog(T.get(0)), L = new Array(this.getLength()), I = 0; I < this.getLength(); I++)
          L[I] = this.get(I);
        for (var I = 0; I < T.getLength(); I++)
          L[I] ^= S.gexp(S.glog(T.get(I)) + x);
        return new n(L, 0).mod(T);
      }
    }, s.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], s.getRSBlocks = function(C, T) {
      var x = s.getRsBlockTable(C, T);
      if (x == c)
        throw new Error("bad rs block @ typeNumber:" + C + "/errorCorrectLevel:" + T);
      for (var L = x.length / 3, I = [], R = 0; R < L; R++)
        for (var B = x[3 * R + 0], D = x[3 * R + 1], k = x[3 * R + 2], F = 0; F < B; F++)
          I.push(new s(D, k));
      return I;
    }, s.getRsBlockTable = function(C, T) {
      switch (T) {
        case A.L:
          return s.RS_BLOCK_TABLE[4 * (C - 1) + 0];
        case A.M:
          return s.RS_BLOCK_TABLE[4 * (C - 1) + 1];
        case A.Q:
          return s.RS_BLOCK_TABLE[4 * (C - 1) + 2];
        case A.H:
          return s.RS_BLOCK_TABLE[4 * (C - 1) + 3];
        default:
          return c;
      }
    }, o.prototype = {
      get: function(T) {
        var x = Math.floor(T / 8);
        return (this.buffer[x] >>> 7 - T % 8 & 1) == 1;
      },
      put: function(T, x) {
        for (var L = 0; L < x; L++)
          this.putBit((T >>> x - L - 1 & 1) == 1);
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(T) {
        var x = Math.floor(this.length / 8);
        this.buffer.length <= x && this.buffer.push(0), T && (this.buffer[x] |= 128 >>> this.length % 8), this.length++;
      }
    };
    var w = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]], P = function() {
      return typeof CanvasRenderingContext2D < "u";
    }() ? function() {
      function C() {
        if (this._htOption.drawer == "svg") {
          var R = this._oContext.getSerializedSvg(!0);
          this.dataURL = R, this._el.innerHTML = R;
        } else
          try {
            var B = this._elCanvas.toDataURL("image/png");
            this.dataURL = B;
          } catch (D) {
            console.error(D);
          }
        this._htOption.onRenderingEnd && (this.dataURL || console.error("Can not get base64 data, please check: 1. Published the page and image to the server 2. The image request support CORS 3. Configured `crossOrigin:'anonymous'` option"), this._htOption.onRenderingEnd(this._htOption, this.dataURL));
      }
      function T(R, B) {
        var D = this;
        if (D._fFail = B, D._fSuccess = R, D._bSupportDataURI === null) {
          var k = document.createElement("img"), F = function() {
            D._bSupportDataURI = !1, D._fFail && D._fFail.call(D);
          }, U = function() {
            D._bSupportDataURI = !0, D._fSuccess && D._fSuccess.call(D);
          };
          return k.onabort = F, k.onerror = F, k.onload = U, void (k.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==");
        }
        D._bSupportDataURI === !0 && D._fSuccess ? D._fSuccess.call(D) : D._bSupportDataURI === !1 && D._fFail && D._fFail.call(D);
      }
      if (f._android && f._android <= 2.1) {
        var x = 1 / window.devicePixelRatio, L = CanvasRenderingContext2D.prototype.drawImage;
        CanvasRenderingContext2D.prototype.drawImage = function(R, B, D, k, F, U, G, N, V) {
          if ("nodeName" in R && /img/i.test(R.nodeName))
            for (var j = arguments.length - 1; j >= 1; j--)
              arguments[j] = arguments[j] * x;
          else
            N === void 0 && (arguments[1] *= x, arguments[2] *= x, arguments[3] *= x, arguments[4] *= x);
          L.apply(this, arguments);
        };
      }
      var I = function(B, D) {
        this._bIsPainted = !1, this._android = a(), this._el = B, this._htOption = D, this._htOption.drawer == "svg" ? (this._oContext = {}, this._elCanvas = {}) : (this._elCanvas = document.createElement("canvas"), this._el.appendChild(this._elCanvas), this._oContext = this._elCanvas.getContext("2d")), this._bSupportDataURI = null, this.dataURL = null;
      };
      return I.prototype.draw = function(R) {
        function B() {
          k.quietZone > 0 && k.quietZoneColor && (N.lineWidth = 0, N.fillStyle = k.quietZoneColor, N.fillRect(0, 0, V._elCanvas.width, k.quietZone), N.fillRect(0, k.quietZone, k.quietZone, V._elCanvas.height - 2 * k.quietZone), N.fillRect(V._elCanvas.width - k.quietZone, k.quietZone, k.quietZone, V._elCanvas.height - 2 * k.quietZone), N.fillRect(0, V._elCanvas.height - k.quietZone, V._elCanvas.width, k.quietZone));
        }
        function D(ee) {
          function Y(Ge) {
            var Me = Math.round(k.width / 3.5), be = Math.round(k.height / 3.5);
            Me !== be && (Me = be), k.logoMaxWidth ? Me = Math.round(k.logoMaxWidth) : k.logoWidth && (Me = Math.round(k.logoWidth)), k.logoMaxHeight ? be = Math.round(k.logoMaxHeight) : k.logoHeight && (be = Math.round(k.logoHeight));
            var Ne, Ue;
            Ge.naturalWidth === void 0 ? (Ne = Ge.width, Ue = Ge.height) : (Ne = Ge.naturalWidth, Ue = Ge.naturalHeight), (k.logoMaxWidth || k.logoMaxHeight) && (k.logoMaxWidth && Ne <= Me && (Me = Ne), k.logoMaxHeight && Ue <= be && (be = Ue), Ne <= Me && Ue <= be && (Me = Ne, be = Ue));
            var tt = (k.width + 2 * k.quietZone - Me) / 2, Z = (k.height + k.titleHeight + 2 * k.quietZone - be) / 2, Le = Math.min(Me / Ne, be / Ue), Je = Ne * Le, ft = Ue * Le;
            (k.logoMaxWidth || k.logoMaxHeight) && (Me = Je, be = ft, tt = (k.width + 2 * k.quietZone - Me) / 2, Z = (k.height + k.titleHeight + 2 * k.quietZone - be) / 2), k.logoBackgroundTransparent || (N.fillStyle = k.logoBackgroundColor, N.fillRect(tt, Z, Me, be)), N.drawImage(Ge, tt + (Me - Je) / 2, Z + (be - ft) / 2, Je, ft), B(), He._bIsPainted = !0, He.makeImage();
          }
          k.onRenderingStart && k.onRenderingStart(k);
          for (var te = 0; te < F; te++)
            for (var oe = 0; oe < F; oe++) {
              var pe = oe * U + k.quietZone, ae = te * G + k.quietZone, Ie = ee.isDark(te, oe), ce = ee.getEye(te, oe), ie = k.dotScale;
              N.lineWidth = 0;
              var Ae, we;
              ce ? (Ae = k[ce.type] || k[ce.type.substring(0, 2)] || k.colorDark, we = k.colorLight) : k.backgroundImage ? (we = "rgba(0,0,0,0)", te == 6 ? k.autoColor ? (Ae = k.timing_H || k.timing || k.autoColorDark, we = k.timing_H || k.timing || k.autoColorLight) : Ae = k.timing_H || k.timing || k.colorDark : oe == 6 ? k.autoColor ? (Ae = k.timing_V || k.timing || k.autoColorDark, we = k.timing_V || k.timing || k.autoColorLight) : Ae = k.timing_V || k.timing || k.colorDark : k.autoColor ? (Ae = k.autoColorDark, we = k.autoColorLight) : Ae = k.colorDark) : (Ae = te == 6 ? k.timing_H || k.timing || k.colorDark : oe == 6 && (k.timing_V || k.timing) || k.colorDark, we = k.colorLight), N.strokeStyle = Ie ? Ae : we, N.fillStyle = Ie ? Ae : we, ce ? (ie = ce.type == "AO" ? k.dotScaleAO : ce.type == "AI" ? k.dotScaleAI : 1, k.backgroundImage && k.autoColor ? (Ae = (ce.type == "AO" ? k.AI : k.AO) || k.autoColorDark, we = k.autoColorLight) : Ae = (ce.type == "AO" ? k.AI : k.AO) || Ae, Ie = ce.isDark, N.fillRect(pe + U * (1 - ie) / 2, k.titleHeight + ae + G * (1 - ie) / 2, U * ie, G * ie)) : te == 6 ? (ie = k.dotScaleTiming_H, N.fillRect(pe + U * (1 - ie) / 2, k.titleHeight + ae + G * (1 - ie) / 2, U * ie, G * ie)) : oe == 6 ? (ie = k.dotScaleTiming_V, N.fillRect(pe + U * (1 - ie) / 2, k.titleHeight + ae + G * (1 - ie) / 2, U * ie, G * ie)) : (k.backgroundImage, N.fillRect(pe + U * (1 - ie) / 2, k.titleHeight + ae + G * (1 - ie) / 2, U * ie, G * ie)), k.dotScale == 1 || ce || (N.strokeStyle = k.colorLight);
            }
          if (k.title && (N.fillStyle = k.titleBackgroundColor, N.fillRect(0, 0, this._elCanvas.width, k.titleHeight + k.quietZone), N.font = k.titleFont, N.fillStyle = k.titleColor, N.textAlign = "center", N.fillText(k.title, this._elCanvas.width / 2, +k.quietZone + k.titleTop)), k.subTitle && (N.font = k.subTitleFont, N.fillStyle = k.subTitleColor, N.fillText(k.subTitle, this._elCanvas.width / 2, +k.quietZone + k.subTitleTop)), k.logo) {
            var Ve = new Image(), He = this;
            Ve.onload = function() {
              Y(Ve);
            }, Ve.onerror = function(Ge) {
              console.error(Ge);
            }, k.crossOrigin != null && (Ve.crossOrigin = k.crossOrigin), Ve.originalSrc = k.logo, Ve.src = k.logo;
          } else
            B(), this._bIsPainted = !0, this.makeImage();
        }
        console.log(this);
        var k = this._htOption;
        k.title || k.subTitle || (k.height -= k.titleHeight, k.titleHeight = 0);
        var F = R.getModuleCount(), U = Math.round(k.width / F), G = Math.round((k.height - k.titleHeight) / F);
        U <= 1 && (U = 1), G <= 1 && (G = 1), k.width = U * F, k.height = G * F + k.titleHeight, k.quietZone = Math.round(k.quietZone), this._elCanvas.width = k.width + 2 * k.quietZone, this._elCanvas.height = k.height + 2 * k.quietZone, this._htOption.drawer != "canvas" && (this._oContext = new C2S(this._elCanvas.width, this._elCanvas.height)), this.clear();
        var N = this._oContext;
        N.lineWidth = 0, N.fillStyle = k.colorLight, N.fillRect(0, 0, this._elCanvas.width, this._elCanvas.height);
        var V = this;
        if (k.backgroundImage) {
          var j = new Image();
          j.onload = function() {
            N.globalAlpha = 1, N.globalAlpha = k.backgroundImageAlpha, N.drawImage(j, 0, k.titleHeight, k.width + 2 * k.quietZone, k.height + 2 * k.quietZone - k.titleHeight), N.globalAlpha = 1, D.call(V, R);
          }, k.crossOrigin != null && (j.crossOrigin = k.crossOrigin), j.originalSrc = k.backgroundImage, j.src = k.backgroundImage;
        } else
          D.call(V, R);
      }, I.prototype.makeImage = function() {
        this._bIsPainted && T.call(this, C);
      }, I.prototype.isPainted = function() {
        return this._bIsPainted;
      }, I.prototype.clear = function() {
        this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height), this._bIsPainted = !1;
      }, I.prototype.remove = function() {
        this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height), this._bIsPainted = !1, this._el.innerHTML = "";
      }, I.prototype.round = function(R) {
        return R && Math.floor(1e3 * R) / 1e3;
      }, I;
    }() : function() {
      var C = function(x, L) {
        this._el = x, this._htOption = L;
      };
      return C.prototype.draw = function(T) {
        var x = this._htOption, L = this._el, I = T.getModuleCount(), R = Math.round(x.width / I), B = Math.round((x.height - x.titleHeight) / I);
        R <= 1 && (R = 1), B <= 1 && (B = 1), this._htOption.width = R * I, this._htOption.height = B * I + x.titleHeight, this._htOption.quietZone = Math.round(this._htOption.quietZone);
        var D = [], k = "", F = Math.round(R * x.dotScale), U = Math.round(B * x.dotScale);
        F < 4 && (F = 4, U = 4);
        var G = x.colorDark, N = x.colorLight;
        if (x.backgroundImage) {
          x.autoColor ? (x.colorDark = "rgba(0, 0, 0, .6);filter:progid:DXImageTransform.Microsoft.Gradient(GradientType=0, StartColorStr='#99000000', EndColorStr='#99000000');", x.colorLight = "rgba(255, 255, 255, .7);filter:progid:DXImageTransform.Microsoft.Gradient(GradientType=0, StartColorStr='#B2FFFFFF', EndColorStr='#B2FFFFFF');") : x.colorLight = "rgba(0,0,0,0)";
          var V = '<div style="display:inline-block; z-index:-10;position:absolute;"><img src="' + x.backgroundImage + '" widht="' + (x.width + 2 * x.quietZone) + '" height="' + (x.height + 2 * x.quietZone) + '" style="opacity:' + x.backgroundImageAlpha + ";filter:alpha(opacity=" + 100 * x.backgroundImageAlpha + '); "/></div>';
          D.push(V);
        }
        if (x.quietZone && (k = "display:inline-block; width:" + (x.width + 2 * x.quietZone) + "px; height:" + (x.width + 2 * x.quietZone) + "px;background:" + x.quietZoneColor + "; text-align:center;"), D.push('<div style="font-size:0;' + k + '">'), D.push('<table  style="font-size:0;border:0;border-collapse:collapse; margin-top:' + x.quietZone + 'px;" border="0" cellspacing="0" cellspadding="0" align="center" valign="middle">'), D.push('<tr height="' + x.titleHeight + '" align="center"><td style="border:0;border-collapse:collapse;margin:0;padding:0" colspan="' + I + '">'), x.title) {
          var j = x.titleColor, ee = x.titleFont;
          D.push('<div style="width:100%;margin-top:' + x.titleTop + "px;color:" + j + ";font:" + ee + ";background:" + x.titleBackgroundColor + '">' + x.title + "</div>");
        }
        x.subTitle && D.push('<div style="width:100%;margin-top:' + (x.subTitleTop - x.titleTop) + "px;color:" + x.subTitleColor + "; font:" + x.subTitleFont + '">' + x.subTitle + "</div>"), D.push("</td></tr>");
        for (var Y = 0; Y < I; Y++) {
          D.push('<tr style="border:0; padding:0; margin:0;" height="7">');
          for (var te = 0; te < I; te++) {
            var oe = T.isDark(Y, te), pe = T.getEye(Y, te);
            if (pe) {
              oe = pe.isDark;
              var ae = pe.type, Ie = x[ae] || x[ae.substring(0, 2)] || G;
              D.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + R + "px;height:" + B + 'px;"><span style="width:' + R + "px;height:" + B + "px;background-color:" + (oe ? Ie : N) + ';display:inline-block"></span></td>');
            } else {
              var ce = x.colorDark;
              Y == 6 ? (ce = x.timing_H || x.timing || G, D.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + R + "px;height:" + B + "px;background-color:" + (oe ? ce : N) + ';"></td>')) : te == 6 ? (ce = x.timing_V || x.timing || G, D.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + R + "px;height:" + B + "px;background-color:" + (oe ? ce : N) + ';"></td>')) : D.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + R + "px;height:" + B + 'px;"><div style="display:inline-block;width:' + F + "px;height:" + U + "px;background-color:" + (oe ? ce : x.colorLight) + ';"></div></td>');
            }
          }
          D.push("</tr>");
        }
        if (D.push("</table>"), D.push("</div>"), x.logo) {
          var ie = new Image();
          x.crossOrigin != null && (ie.crossOrigin = x.crossOrigin), ie.src = x.logo;
          var Ae = x.width / 3.5, we = x.height / 3.5;
          Ae != we && (Ae = we), x.logoWidth && (Ae = x.logoWidth), x.logoHeight && (we = x.logoHeight);
          var Ve = "position:relative; z-index:1;display:table-cell;top:-" + ((x.height - x.titleHeight) / 2 + we / 2 + x.quietZone) + "px;text-align:center; width:" + Ae + "px; height:" + we + "px;line-height:" + Ae + "px; vertical-align: middle;";
          x.logoBackgroundTransparent || (Ve += "background:" + x.logoBackgroundColor), D.push('<div style="' + Ve + '"><img  src="' + x.logo + '"  style="max-width: ' + Ae + "px; max-height: " + we + 'px;" /> <div style=" display: none; width:1px;margin-left: -1px;"></div></div>');
        }
        x.onRenderingStart && x.onRenderingStart(x), L.innerHTML = D.join("");
        var He = L.childNodes[0], Ge = (x.width - He.offsetWidth) / 2, Me = (x.height - He.offsetHeight) / 2;
        Ge > 0 && Me > 0 && (He.style.margin = Me + "px " + Ge + "px"), this._htOption.onRenderingEnd && this._htOption.onRenderingEnd(this._htOption, null);
      }, C.prototype.clear = function() {
        this._el.innerHTML = "";
      }, C;
    }();
    d = function(T, x) {
      if (this._htOption = {
        width: 256,
        height: 256,
        typeNumber: 4,
        colorDark: "#000000",
        colorLight: "#ffffff",
        correctLevel: A.H,
        dotScale: 1,
        dotScaleTiming: 1,
        dotScaleTiming_H: c,
        dotScaleTiming_V: c,
        dotScaleA: 1,
        dotScaleAO: c,
        dotScaleAI: c,
        quietZone: 0,
        quietZoneColor: "rgba(0,0,0,0)",
        title: "",
        titleFont: "normal normal bold 16px Arial",
        titleColor: "#000000",
        titleBackgroundColor: "#ffffff",
        titleHeight: 0,
        titleTop: 30,
        subTitle: "",
        subTitleFont: "normal normal normal 14px Arial",
        subTitleColor: "#4F4F4F",
        subTitleTop: 60,
        logo: c,
        logoWidth: c,
        logoHeight: c,
        logoMaxWidth: c,
        logoMaxHeight: c,
        logoBackgroundColor: "#ffffff",
        logoBackgroundTransparent: !1,
        PO: c,
        PI: c,
        PO_TL: c,
        PI_TL: c,
        PO_TR: c,
        PI_TR: c,
        PO_BL: c,
        PI_BL: c,
        AO: c,
        AI: c,
        timing: c,
        timing_H: c,
        timing_V: c,
        backgroundImage: c,
        backgroundImageAlpha: 1,
        autoColor: !1,
        autoColorDark: "rgba(0, 0, 0, .6)",
        autoColorLight: "rgba(255, 255, 255, .7)",
        onRenderingStart: c,
        onRenderingEnd: c,
        version: 0,
        tooltip: !1,
        binary: !1,
        drawer: "canvas",
        crossOrigin: null
      }, typeof x == "string" && (x = {
        text: x
      }), x)
        for (var L in x)
          this._htOption[L] = x[L];
      (this._htOption.version < 0 || this._htOption.version > 40) && (console.warn("QR Code version '" + this._htOption.version + "' is invalidate, reset to 0"), this._htOption.version = 0), (this._htOption.dotScale < 0 || this._htOption.dotScale > 1) && (console.warn(this._htOption.dotScale + " , is invalidate, dotScale must greater than 0, less than or equal to 1, now reset to 1. "), this._htOption.dotScale = 1), (this._htOption.dotScaleTiming < 0 || this._htOption.dotScaleTiming > 1) && (console.warn(this._htOption.dotScaleTiming + " , is invalidate, dotScaleTiming must greater than 0, less than or equal to 1, now reset to 1. "), this._htOption.dotScaleTiming = 1), this._htOption.dotScaleTiming_H ? (this._htOption.dotScaleTiming_H < 0 || this._htOption.dotScaleTiming_H > 1) && (console.warn(this._htOption.dotScaleTiming_H + " , is invalidate, dotScaleTiming_H must greater than 0, less than or equal to 1, now reset to 1. "), this._htOption.dotScaleTiming_H = 1) : this._htOption.dotScaleTiming_H = this._htOption.dotScaleTiming, this._htOption.dotScaleTiming_V ? (this._htOption.dotScaleTiming_V < 0 || this._htOption.dotScaleTiming_V > 1) && (console.warn(this._htOption.dotScaleTiming_V + " , is invalidate, dotScaleTiming_V must greater than 0, less than or equal to 1, now reset to 1. "), this._htOption.dotScaleTiming_V = 1) : this._htOption.dotScaleTiming_V = this._htOption.dotScaleTiming, (this._htOption.dotScaleA < 0 || this._htOption.dotScaleA > 1) && (console.warn(this._htOption.dotScaleA + " , is invalidate, dotScaleA must greater than 0, less than or equal to 1, now reset to 1. "), this._htOption.dotScaleA = 1), this._htOption.dotScaleAO ? (this._htOption.dotScaleAO < 0 || this._htOption.dotScaleAO > 1) && (console.warn(this._htOption.dotScaleAO + " , is invalidate, dotScaleAO must greater than 0, less than or equal to 1, now reset to 1. "), this._htOption.dotScaleAO = 1) : this._htOption.dotScaleAO = this._htOption.dotScaleA, this._htOption.dotScaleAI ? (this._htOption.dotScaleAI < 0 || this._htOption.dotScaleAI > 1) && (console.warn(this._htOption.dotScaleAI + " , is invalidate, dotScaleAI must greater than 0, less than or equal to 1, now reset to 1. "), this._htOption.dotScaleAI = 1) : this._htOption.dotScaleAI = this._htOption.dotScaleA, (this._htOption.backgroundImageAlpha < 0 || this._htOption.backgroundImageAlpha > 1) && (console.warn(this._htOption.backgroundImageAlpha + " , is invalidate, backgroundImageAlpha must between 0 and 1, now reset to 1. "), this._htOption.backgroundImageAlpha = 1), this._htOption.height = this._htOption.height + this._htOption.titleHeight, typeof T == "string" && (T = document.getElementById(T)), (!this._htOption.drawer || this._htOption.drawer != "svg" && this._htOption.drawer != "canvas") && (this._htOption.drawer = "canvas"), this._android = a(), this._el = T, this._oQRCode = null;
      var I = {};
      for (var L in this._htOption)
        I[L] = this._htOption[L];
      this._oDrawing = new P(this._el, I), this._htOption.text && this.makeCode(this._htOption.text);
    }, d.prototype.makeCode = function(C) {
      this._oQRCode = new r(l(C, this._htOption), this._htOption.correctLevel), this._oQRCode.addData(C, this._htOption.binary), this._oQRCode.make(), this._htOption.tooltip && (this._el.title = C), this._oDrawing.draw(this._oQRCode);
    }, d.prototype.makeImage = function() {
      typeof this._oDrawing.makeImage == "function" && (!this._android || this._android >= 3) && this._oDrawing.makeImage();
    }, d.prototype.clear = function() {
      this._oDrawing.remove();
    }, d.prototype.resize = function(C, T) {
      this._oDrawing._htOption.width = C, this._oDrawing._htOption.height = T, this._oDrawing.draw(this._oQRCode);
    }, d.prototype.noConflict = function() {
      return f.QRCode === this && (f.QRCode = v), d;
    }, d.CorrectLevel = A, m ? ((m.exports = d).QRCode = d, g.QRCode = d) : f.QRCode = d;
  }.call(Nr);
})(Xn, Xn.exports);
Xn.exports;
var Go;
(function(i) {
  i[i.Connecting = 0] = "Connecting", i[i.Open = 1] = "Open", i[i.Closing = 2] = "Closing", i[i.Closed = 3] = "Closed";
})(Go || (Go = {}));
function Pm(i, e, t = "modelValue", r) {
  return J({
    get: () => i[t],
    set: (n) => {
      e(`update:${t}`, r ? r(n) : n);
    }
  });
}
var ks = De({
  name: "vue3-danmaku",
  components: {},
  props: {
    /**
     * 弹幕列表数据
     */
    danmus: {
      type: Array,
      required: !0,
      default: () => []
    },
    /**
     * 轨道数量，0为最大轨道数量（撑满容器）
     */
    channels: {
      type: Number,
      default: 0
    },
    /**
     * 是否自动播放
     */
    autoplay: {
      type: Boolean,
      default: !0
    },
    /**
     * 是否循环播放
     */
    loop: {
      type: Boolean,
      default: !1
    },
    /**
     * 是否开启弹幕插槽，默认否
     */
    useSlot: {
      type: Boolean,
      default: !1
    },
    /**
     * 弹幕刷新频率(ms)
     */
    debounce: {
      type: Number,
      default: 100
    },
    /**
     * 弹幕速度（像素/秒）
     */
    speeds: {
      type: Number,
      default: 200
    },
    /**
     * 是否开启随机轨道注入弹幕
     */
    randomChannel: {
      type: Boolean,
      default: !1
    },
    /**
     * 弹幕字号（仅文本模式）
     */
    fontSize: {
      type: Number,
      default: 18
    },
    /**
     * 弹幕垂直间距
     */
    top: {
      type: Number,
      default: 4
    },
    /**
     * 弹幕水平间距
     */
    right: {
      type: Number,
      default: 0
    },
    /**
     * 是否开启悬浮暂停
     */
    isSuspend: {
      type: Boolean,
      default: !1
    },
    /**
     * 弹幕额外样式
     */
    extraStyle: {
      type: String,
      default: ""
    }
  },
  emits: ["list-end", "play-end", "update:danmus"],
  setup(i, { emit: e, slots: t }) {
    let r = q(document.createElement("div")), n = q(document.createElement("div"));
    const s = q(0), o = q(0);
    let a = 0;
    const l = q(0), u = q(0), c = q(0), d = q(!1), h = q(!1), p = q({}), f = Pm(i, e, "danmus"), g = ci({
      channels: J(() => i.channels || l.value),
      autoplay: J(() => i.autoplay),
      loop: J(() => i.loop),
      useSlot: J(() => i.useSlot),
      debounce: J(() => i.debounce),
      randomChannel: J(() => i.randomChannel)
    }), m = ci({
      height: J(() => u.value),
      fontSize: J(() => i.fontSize),
      speeds: J(() => i.speeds),
      top: J(() => i.top),
      right: J(() => i.right)
    });
    ht(() => {
      v();
    }), qt(() => {
      T();
    });
    function v() {
      E(), i.isSuspend && C(), g.autoplay && A();
    }
    function E() {
      s.value = r.value.offsetWidth, o.value = r.value.offsetHeight;
    }
    function A() {
      h.value = !1, a || (a = setInterval(() => _(), g.debounce));
    }
    function _() {
      if (!h.value && f.value.length)
        if (c.value > f.value.length - 1) {
          const G = n.value.children.length;
          g.loop && (G < c.value && (e("list-end"), c.value = 0), y());
        } else
          y();
    }
    function y(G) {
      const N = g.loop ? c.value % f.value.length : c.value, V = G || f.value[N];
      let j = document.createElement("div");
      g.useSlot ? j = S(V, N).$el : (j.innerHTML = V, j.setAttribute("style", i.extraStyle), j.style.fontSize = `${m.fontSize}px`, j.style.lineHeight = `${m.fontSize}px`), j.classList.add("dm"), n.value.appendChild(j), j.style.opacity = "0", ct(() => {
        m.height || (u.value = j.offsetHeight), g.channels || (l.value = Math.floor(o.value / (m.height + m.top)));
        let ee = b(j);
        if (ee >= 0) {
          const Y = j.offsetWidth, te = m.height;
          j.classList.add("move"), j.dataset.index = `${N}`, j.style.opacity = "1", j.style.top = ee * (te + m.top) + "px", j.style.width = Y + m.right + "px", j.style.setProperty("--dm-scroll-width", `-${s.value + Y * 2}px`), j.style.left = `${s.value}px`, j.style.animationDuration = `${s.value / m.speeds}s`, j.addEventListener("animationend", () => {
            Number(j.dataset.index) === f.value.length - 1 && !g.loop && e("play-end", j.dataset.index), n.value && n.value.removeChild(j);
          }), c.value++;
        } else
          n.value.removeChild(j);
      });
    }
    function S(G, N) {
      return Hu({
        render() {
          return Na("div", {}, [
            t.dm && t.dm({
              danmu: G,
              index: N
            })
          ]);
        }
      }).mount(document.createElement("div"));
    }
    function b(G) {
      let N = [...Array(g.channels).keys()];
      g.randomChannel && (N = N.sort(() => 0.5 - Math.random()));
      for (let V of N) {
        const j = p.value[V];
        if (j && j.length)
          for (let ee = 0; ee < j.length; ee++) {
            const Y = w(j[ee]) - 10;
            if (Y <= (G.offsetWidth - j[ee].offsetWidth) * 0.88 || Y <= 0)
              break;
            if (ee === j.length - 1)
              return p.value[V].push(G), G.addEventListener("animationend", () => p.value[V].splice(0, 1)), V % g.channels;
          }
        else
          return p.value[V] = [G], G.addEventListener("animationend", () => p.value[V].splice(0, 1)), V % g.channels;
      }
      return -1;
    }
    function w(G) {
      const N = G.offsetWidth || parseInt(G.style.width), V = G.getBoundingClientRect().right || n.value.getBoundingClientRect().right + N;
      return n.value.getBoundingClientRect().right - V;
    }
    function P() {
      clearInterval(a), a = 0;
    }
    function C() {
      let G = [];
      n.value.addEventListener("mousemove", (N) => {
        let V = N.target;
        V.className.includes("dm") || (V = V.closest(".dm") || V), V.className.includes("dm") && (V.classList.add("pause"), G.push(V));
      }), n.value.addEventListener("mouseout", (N) => {
        let V = N.target;
        V.className.includes("dm") || (V = V.closest(".dm") || V), V.className.includes("dm") && (V.classList.remove("pause"), G.forEach((j) => {
          j.classList.remove("pause");
        }), G = []);
      });
    }
    function T() {
      P(), c.value = 0;
    }
    function x() {
      u.value = 0, v();
    }
    function L() {
      p.value = {}, n.value.innerHTML = "", h.value = !0, d.value = !1, T();
    }
    function I() {
      h.value = !0;
    }
    function R(G) {
      if (c.value === f.value.length)
        return f.value.push(G), f.value.length - 1;
      {
        const N = c.value % f.value.length;
        return f.value.splice(N, 0, G), N + 1;
      }
    }
    function B(G) {
      return f.value.push(G), f.value.length - 1;
    }
    function D() {
      return !h.value;
    }
    function k() {
      d.value = !1;
    }
    function F() {
      d.value = !0;
    }
    function U() {
      E();
      const G = n.value.getElementsByClassName("dm");
      for (let N = 0; N < G.length; N++) {
        const V = G[N];
        V.style.setProperty("--dm-scroll-width", `-${s.value + V.offsetWidth * 2}px`), V.style.left = `${s.value}px`, V.style.animationDuration = `${s.value / m.speeds}s`;
      }
    }
    return {
      // element
      container: r,
      dmContainer: n,
      // variable
      hidden: d,
      paused: h,
      danmuList: f,
      // function
      getPlayState: D,
      resize: U,
      play: A,
      pause: I,
      stop: L,
      show: k,
      hide: F,
      reset: x,
      add: R,
      push: B,
      insert: y
    };
  }
});
const Mm = {
  ref: "container",
  class: "vue-danmaku"
};
function Bm(i, e, t, r, n, s) {
  return X(), le(
    "div",
    Mm,
    [
      se(
        "div",
        {
          ref: "dmContainer",
          class: Ee(["danmus", { show: !i.hidden }, { paused: i.paused }])
        },
        null,
        2
        /* CLASS */
      ),
      it(i.$slots, "default")
    ],
    512
    /* NEED_PATCH */
  );
}
function Fm(i, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(!i || typeof document > "u")) {
    var r = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
    n.type = "text/css", t === "top" && r.firstChild ? r.insertBefore(n, r.firstChild) : r.appendChild(n), n.styleSheet ? n.styleSheet.cssText = i : n.appendChild(document.createTextNode(i));
  }
}
var Nm = `.vue-danmaku {
  position: relative;
  overflow: hidden;
}
.vue-danmaku .danmus {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  -webkit-transition: all 0.3s;
  transition: all 0.3s;
}
.vue-danmaku .danmus.show {
  opacity: 1;
}
.vue-danmaku .danmus.paused .dm.move {
  animation-play-state: paused;
}
.vue-danmaku .danmus .dm {
  position: absolute;
  font-size: 20px;
  color: #ddd;
  white-space: pre;
  transform: translateX(0);
  transform-style: preserve-3d;
}
.vue-danmaku .danmus .dm.move {
  will-change: transform;
  animation-name: moveLeft;
  animation-timing-function: linear;
  animation-play-state: running;
}
.vue-danmaku .danmus .dm.pause {
  animation-play-state: paused;
  z-index: 10;
}
@keyframes moveLeft {
  from {
    transform: translateX(0);
  }
  to {
    transform: translateX(var(--dm-scroll-width));
  }
}
@-webkit-keyframes moveLeft {
  from {
    -webkit-transform: translateX(0);
  }
  to {
    -webkit-transform: translateX(var(--dm-scroll-width));
  }
}`;
Fm(Nm);
ks.render = Bm;
ks.__file = "src/lib/Danmaku.vue";
function Um(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Ll = { exports: {} };
(function(i, e) {
  (function(t) {
    var r = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, n = /^(?=([^\/?#]*))\1([^]*)$/, s = /(?:\/|^)\.(?=\/)/g, o = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, a = {
      // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
      // E.g
      // With opts.alwaysNormalize = false (default, spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
      // With opts.alwaysNormalize = true (not spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
      buildAbsoluteURL: function(l, u, c) {
        if (c = c || {}, l = l.trim(), u = u.trim(), !u) {
          if (!c.alwaysNormalize)
            return l;
          var d = a.parseURL(l);
          if (!d)
            throw new Error("Error trying to parse base URL.");
          return d.path = a.normalizePath(
            d.path
          ), a.buildURLFromParts(d);
        }
        var h = a.parseURL(u);
        if (!h)
          throw new Error("Error trying to parse relative URL.");
        if (h.scheme)
          return c.alwaysNormalize ? (h.path = a.normalizePath(h.path), a.buildURLFromParts(h)) : u;
        var p = a.parseURL(l);
        if (!p)
          throw new Error("Error trying to parse base URL.");
        if (!p.netLoc && p.path && p.path[0] !== "/") {
          var f = n.exec(p.path);
          p.netLoc = f[1], p.path = f[2];
        }
        p.netLoc && !p.path && (p.path = "/");
        var g = {
          // 2c) Otherwise, the embedded URL inherits the scheme of
          // the base URL.
          scheme: p.scheme,
          netLoc: h.netLoc,
          path: null,
          params: h.params,
          query: h.query,
          fragment: h.fragment
        };
        if (!h.netLoc && (g.netLoc = p.netLoc, h.path[0] !== "/"))
          if (!h.path)
            g.path = p.path, h.params || (g.params = p.params, h.query || (g.query = p.query));
          else {
            var m = p.path, v = m.substring(0, m.lastIndexOf("/") + 1) + h.path;
            g.path = a.normalizePath(v);
          }
        return g.path === null && (g.path = c.alwaysNormalize ? a.normalizePath(h.path) : h.path), a.buildURLFromParts(g);
      },
      parseURL: function(l) {
        var u = r.exec(l);
        return u ? {
          scheme: u[1] || "",
          netLoc: u[2] || "",
          path: u[3] || "",
          params: u[4] || "",
          query: u[5] || "",
          fragment: u[6] || ""
        } : null;
      },
      normalizePath: function(l) {
        for (l = l.split("").reverse().join("").replace(s, ""); l.length !== (l = l.replace(o, "")).length; )
          ;
        return l.split("").reverse().join("");
      },
      buildURLFromParts: function(l) {
        return l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment;
      }
    };
    i.exports = a;
  })();
})(Ll);
var Ds = Ll.exports;
function Vo(i, e) {
  var t = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(n) {
      return Object.getOwnPropertyDescriptor(i, n).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Tt(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Vo(Object(t), !0).forEach(function(r) {
      Km(i, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : Vo(Object(t)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return i;
}
function Km(i, e, t) {
  return e = Vm(e), e in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function et() {
  return et = Object.assign ? Object.assign.bind() : function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]);
    }
    return i;
  }, et.apply(this, arguments);
}
function Gm(i, e) {
  if (typeof i != "object" || i === null)
    return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(i, e || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function Vm(i) {
  var e = Gm(i, "string");
  return typeof e == "symbol" ? e : String(e);
}
const de = Number.isFinite || function(i) {
  return typeof i == "number" && isFinite(i);
};
let O = /* @__PURE__ */ function(i) {
  return i.MEDIA_ATTACHING = "hlsMediaAttaching", i.MEDIA_ATTACHED = "hlsMediaAttached", i.MEDIA_DETACHING = "hlsMediaDetaching", i.MEDIA_DETACHED = "hlsMediaDetached", i.BUFFER_RESET = "hlsBufferReset", i.BUFFER_CODECS = "hlsBufferCodecs", i.BUFFER_CREATED = "hlsBufferCreated", i.BUFFER_APPENDING = "hlsBufferAppending", i.BUFFER_APPENDED = "hlsBufferAppended", i.BUFFER_EOS = "hlsBufferEos", i.BUFFER_FLUSHING = "hlsBufferFlushing", i.BUFFER_FLUSHED = "hlsBufferFlushed", i.MANIFEST_LOADING = "hlsManifestLoading", i.MANIFEST_LOADED = "hlsManifestLoaded", i.MANIFEST_PARSED = "hlsManifestParsed", i.LEVEL_SWITCHING = "hlsLevelSwitching", i.LEVEL_SWITCHED = "hlsLevelSwitched", i.LEVEL_LOADING = "hlsLevelLoading", i.LEVEL_LOADED = "hlsLevelLoaded", i.LEVEL_UPDATED = "hlsLevelUpdated", i.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", i.LEVELS_UPDATED = "hlsLevelsUpdated", i.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", i.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", i.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", i.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", i.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", i.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", i.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", i.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", i.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", i.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", i.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", i.CUES_PARSED = "hlsCuesParsed", i.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", i.INIT_PTS_FOUND = "hlsInitPtsFound", i.FRAG_LOADING = "hlsFragLoading", i.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", i.FRAG_LOADED = "hlsFragLoaded", i.FRAG_DECRYPTED = "hlsFragDecrypted", i.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", i.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", i.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", i.FRAG_PARSED = "hlsFragParsed", i.FRAG_BUFFERED = "hlsFragBuffered", i.FRAG_CHANGED = "hlsFragChanged", i.FPS_DROP = "hlsFpsDrop", i.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", i.ERROR = "hlsError", i.DESTROYING = "hlsDestroying", i.KEY_LOADING = "hlsKeyLoading", i.KEY_LOADED = "hlsKeyLoaded", i.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", i.BACK_BUFFER_REACHED = "hlsBackBufferReached", i;
}({}), fe = /* @__PURE__ */ function(i) {
  return i.NETWORK_ERROR = "networkError", i.MEDIA_ERROR = "mediaError", i.KEY_SYSTEM_ERROR = "keySystemError", i.MUX_ERROR = "muxError", i.OTHER_ERROR = "otherError", i;
}({}), W = /* @__PURE__ */ function(i) {
  return i.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", i.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", i.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", i.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", i.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", i.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", i.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", i.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", i.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", i.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", i.MANIFEST_LOAD_ERROR = "manifestLoadError", i.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", i.MANIFEST_PARSING_ERROR = "manifestParsingError", i.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", i.LEVEL_EMPTY_ERROR = "levelEmptyError", i.LEVEL_LOAD_ERROR = "levelLoadError", i.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", i.LEVEL_PARSING_ERROR = "levelParsingError", i.LEVEL_SWITCH_ERROR = "levelSwitchError", i.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", i.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", i.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", i.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", i.FRAG_LOAD_ERROR = "fragLoadError", i.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", i.FRAG_DECRYPT_ERROR = "fragDecryptError", i.FRAG_PARSING_ERROR = "fragParsingError", i.FRAG_GAP = "fragGap", i.REMUX_ALLOC_ERROR = "remuxAllocError", i.KEY_LOAD_ERROR = "keyLoadError", i.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", i.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", i.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", i.BUFFER_APPEND_ERROR = "bufferAppendError", i.BUFFER_APPENDING_ERROR = "bufferAppendingError", i.BUFFER_STALLED_ERROR = "bufferStalledError", i.BUFFER_FULL_ERROR = "bufferFullError", i.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", i.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", i.INTERNAL_EXCEPTION = "internalException", i.INTERNAL_ABORTED = "aborted", i.UNKNOWN = "unknown", i;
}({});
const yr = function() {
}, $n = {
  trace: yr,
  debug: yr,
  log: yr,
  warn: yr,
  info: yr,
  error: yr
};
let li = $n;
function Hm(i) {
  const e = self.console[i];
  return e ? e.bind(self.console, `[${i}] >`) : yr;
}
function jm(i, ...e) {
  e.forEach(function(t) {
    li[t] = i[t] ? i[t].bind(i) : Hm(t);
  });
}
function Wm(i, e) {
  if (self.console && i === !0 || typeof i == "object") {
    jm(
      i,
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      "debug",
      "log",
      "info",
      "warn",
      "error"
    );
    try {
      li.log(`Debug logs enabled for "${e}" in hls.js version 1.4.3`);
    } catch {
      li = $n;
    }
  } else
    li = $n;
}
const K = li, Qm = /^(\d+)x(\d+)$/, Ho = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class We {
  constructor(e) {
    typeof e == "string" && (e = We.parseAttrList(e));
    for (const t in e)
      e.hasOwnProperty(t) && (t.substring(0, 2) === "X-" && (this.clientAttrs = this.clientAttrs || [], this.clientAttrs.push(t)), this[t] = e[t]);
  }
  decimalInteger(e) {
    const t = parseInt(this[e], 10);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let t = (this[e] || "0x").slice(2);
      t = (t.length & 1 ? "0" : "") + t;
      const r = new Uint8Array(t.length / 2);
      for (let n = 0; n < t.length / 2; n++)
        r[n] = parseInt(t.slice(n * 2, n * 2 + 2), 16);
      return r;
    } else
      return null;
  }
  hexadecimalIntegerAsNumber(e) {
    const t = parseInt(this[e], 16);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e]);
  }
  optionalFloat(e, t) {
    const r = this[e];
    return r ? parseFloat(r) : t;
  }
  enumeratedString(e) {
    return this[e];
  }
  bool(e) {
    return this[e] === "YES";
  }
  decimalResolution(e) {
    const t = Qm.exec(this[e]);
    if (t !== null)
      return {
        width: parseInt(t[1], 10),
        height: parseInt(t[2], 10)
      };
  }
  static parseAttrList(e) {
    let t;
    const r = {}, n = '"';
    for (Ho.lastIndex = 0; (t = Ho.exec(e)) !== null; ) {
      let s = t[2];
      s.indexOf(n) === 0 && s.lastIndexOf(n) === s.length - 1 && (s = s.slice(1, -1));
      const o = t[1].trim();
      r[o] = s;
    }
    return r;
  }
}
function Jm(i) {
  return i !== "ID" && i !== "CLASS" && i !== "START-DATE" && i !== "DURATION" && i !== "END-DATE" && i !== "END-ON-NEXT";
}
function Ym(i) {
  return i === "SCTE35-OUT" || i === "SCTE35-IN";
}
class Cl {
  constructor(e, t) {
    if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) {
      const r = t.attr;
      for (const n in r)
        if (Object.prototype.hasOwnProperty.call(e, n) && e[n] !== r[n]) {
          K.warn(`DATERANGE tag attribute: "${n}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = n;
          break;
        }
      e = et(new We({}), r, e);
    }
    if (this.attr = e, this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
      const r = new Date(this.attr["END-DATE"]);
      de(r.getTime()) && (this._endDate = r);
    }
  }
  get id() {
    return this.attr.ID;
  }
  get class() {
    return this.attr.CLASS;
  }
  get startDate() {
    return this._startDate;
  }
  get endDate() {
    if (this._endDate)
      return this._endDate;
    const e = this.duration;
    return e !== null ? new Date(this._startDate.getTime() + e * 1e3) : null;
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const e = this.attr.decimalFloatingPoint("DURATION");
      if (de(e))
        return e;
    } else if (this._endDate)
      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    return null;
  }
  get plannedDuration() {
    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null;
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT");
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && de(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
  }
}
class cn {
  constructor() {
    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
      start: 0,
      first: 0,
      end: 0
    }, this.parsing = {
      start: 0,
      end: 0
    }, this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  }
}
var Ke = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIOVIDEO: "audiovideo"
};
class Rl {
  // baseurl is the URL to the playlist
  // relurl is the portion of the URL that comes from inside the playlist.
  // Holds the types of data this fragment supports
  constructor(e) {
    this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = {
      [Ke.AUDIO]: null,
      [Ke.VIDEO]: null,
      [Ke.AUDIOVIDEO]: null
    }, this.baseurl = e;
  }
  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
  setByteRange(e, t) {
    const r = e.split("@", 2), n = [];
    r.length === 1 ? n[0] = t ? t.byteRangeEndOffset : 0 : n[0] = parseInt(r[1]), n[1] = parseInt(r[0]) + n[0], this._byteRange = n;
  }
  get byteRange() {
    return this._byteRange ? this._byteRange : [];
  }
  get byteRangeStartOffset() {
    return this.byteRange[0];
  }
  get byteRangeEndOffset() {
    return this.byteRange[1];
  }
  get url() {
    return !this._url && this.baseurl && this.relurl && (this._url = Ds.buildAbsoluteURL(this.baseurl, this.relurl, {
      alwaysNormalize: !0
    })), this._url || "";
  }
  set url(e) {
    this._url = e;
  }
}
class In extends Rl {
  // EXTINF has to be present for a m3u8 to be considered valid
  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'
  // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption
  // core difference from the private field _decryptdata is the lack of the initialized IV
  // _decryptdata will set the IV for this segment based on the segment number in the fragment
  // A string representing the fragment type
  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading
  // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading
  // The level/track index to which the fragment belongs
  // The continuity counter of the fragment
  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.
  // Set by `updateFragPTSDTS` in level-helper
  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
  // Load/parse timing information
  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered
  // #EXTINF  segment title
  // The Media Initialization Section for this segment
  // Fragment is the last fragment in the media playlist
  // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded
  constructor(e, t) {
    super(t), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new cn(), this.urlId = 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.type = e;
  }
  get decryptdata() {
    const {
      levelkeys: e
    } = this;
    if (!e && !this._decryptdata)
      return null;
    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
      const t = this.levelkeys.identity;
      if (t)
        this._decryptdata = t.getDecryptData(this.sn);
      else {
        const r = Object.keys(this.levelkeys);
        if (r.length === 1)
          return this._decryptdata = this.levelkeys[r[0]].getDecryptData(this.sn);
      }
    }
    return this._decryptdata;
  }
  get end() {
    return this.start + this.duration;
  }
  get endProgramDateTime() {
    if (this.programDateTime === null || !de(this.programDateTime))
      return null;
    const e = de(this.duration) ? this.duration : 0;
    return this.programDateTime + e * 1e3;
  }
  get encrypted() {
    var e;
    if ((e = this._decryptdata) != null && e.encrypted)
      return !0;
    if (this.levelkeys) {
      const t = Object.keys(this.levelkeys), r = t.length;
      if (r > 1 || r === 1 && this.levelkeys[t[0]].encrypted)
        return !0;
    }
    return !1;
  }
  setKeyFormat(e) {
    if (this.levelkeys) {
      const t = this.levelkeys[e];
      t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn));
    }
  }
  abortRequests() {
    var e, t;
    (e = this.loader) == null || e.abort(), (t = this.keyLoader) == null || t.abort();
  }
  setElementaryStreamInfo(e, t, r, n, s, o = !1) {
    const {
      elementaryStreams: a
    } = this, l = a[e];
    if (!l) {
      a[e] = {
        startPTS: t,
        endPTS: r,
        startDTS: n,
        endDTS: s,
        partial: o
      };
      return;
    }
    l.startPTS = Math.min(l.startPTS, t), l.endPTS = Math.max(l.endPTS, r), l.startDTS = Math.min(l.startDTS, n), l.endDTS = Math.max(l.endDTS, s);
  }
  clearElementaryStreamInfo() {
    const {
      elementaryStreams: e
    } = this;
    e[Ke.AUDIO] = null, e[Ke.VIDEO] = null, e[Ke.AUDIOVIDEO] = null;
  }
}
class zm extends Rl {
  constructor(e, t, r, n, s) {
    super(r), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new cn(), this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = n;
    const o = e.enumeratedString("BYTERANGE");
    o && this.setByteRange(o, s), s && (this.fragOffset = s.fragOffset + s.duration);
  }
  get start() {
    return this.fragment.start + this.fragOffset;
  }
  get end() {
    return this.start + this.duration;
  }
  get loaded() {
    const {
      elementaryStreams: e
    } = this;
    return !!(e.audio || e.video || e.audiovideo);
  }
}
const qm = 10;
class Zm {
  // Manifest reload synchronization
  constructor(e) {
    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e;
  }
  reloaded(e) {
    if (!e) {
      this.advanced = !0, this.updated = !0;
      return;
    }
    const t = this.lastPartSn - e.lastPartSn, r = this.lastPartIndex - e.lastPartIndex;
    this.updated = this.endSN !== e.endSN || !!r || !!t, this.advanced = this.endSN > e.endSN || t > 0 || t === 0 && r > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * 0.6) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay;
  }
  get hasProgramDateTime() {
    return this.fragments.length ? de(this.fragments[this.fragments.length - 1].programDateTime) : !1;
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || qm;
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime;
    return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1;
  }
  get edge() {
    return this.partEnd || this.fragmentEnd;
  }
  get partEnd() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;
  }
  get fragmentEnd() {
    var e;
    return (e = this.fragments) != null && e.length ? this.fragments[this.fragments.length - 1].end : 0;
  }
  get age() {
    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;
  }
  get lastPartIndex() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1;
  }
  get lastPartSn() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;
  }
}
function Os(i) {
  return Uint8Array.from(atob(i), (e) => e.charCodeAt(0));
}
function Xm(i) {
  const e = wl(i).subarray(0, 16), t = new Uint8Array(16);
  return t.set(e, 16 - e.length), t;
}
function $m(i) {
  const e = function(r, n, s) {
    const o = r[n];
    r[n] = r[s], r[s] = o;
  };
  e(i, 0, 3), e(i, 1, 2), e(i, 4, 5), e(i, 6, 7);
}
function ev(i) {
  const e = i.split(":");
  let t = null;
  if (e[0] === "data" && e.length === 2) {
    const r = e[1].split(";"), n = r[r.length - 1].split(",");
    if (n.length === 2) {
      const s = n[0] === "base64", o = n[1];
      s ? (r.splice(-1, 1), t = Os(o)) : t = Xm(o);
    }
  }
  return t;
}
function wl(i) {
  return Uint8Array.from(unescape(encodeURIComponent(i)), (e) => e.charCodeAt(0));
}
var Qe = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.fps",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "com.widevine.alpha"
}, At = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.streamingkeydelivery",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function jo(i) {
  switch (i) {
    case At.FAIRPLAY:
      return Qe.FAIRPLAY;
    case At.PLAYREADY:
      return Qe.PLAYREADY;
    case At.WIDEVINE:
      return Qe.WIDEVINE;
    case At.CLEARKEY:
      return Qe.CLEARKEY;
  }
}
var kl = {
  WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
};
function tv(i) {
  if (i === kl.WIDEVINE)
    return Qe.WIDEVINE;
}
function Wo(i) {
  switch (i) {
    case Qe.FAIRPLAY:
      return At.FAIRPLAY;
    case Qe.PLAYREADY:
      return At.PLAYREADY;
    case Qe.WIDEVINE:
      return At.WIDEVINE;
    case Qe.CLEARKEY:
      return At.CLEARKEY;
  }
}
function bn(i) {
  const {
    drmSystems: e,
    widevineLicenseUrl: t
  } = i, r = e ? [Qe.FAIRPLAY, Qe.WIDEVINE, Qe.PLAYREADY, Qe.CLEARKEY].filter((n) => !!e[n]) : [];
  return !r[Qe.WIDEVINE] && t && r.push(Qe.WIDEVINE), r;
}
const Dl = function() {
  return typeof self < "u" && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
}();
function rv(i, e, t, r) {
  let n;
  switch (i) {
    case Qe.FAIRPLAY:
      n = ["cenc", "sinf"];
      break;
    case Qe.WIDEVINE:
    case Qe.PLAYREADY:
      n = ["cenc"];
      break;
    case Qe.CLEARKEY:
      n = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${i}`);
  }
  return iv(n, e, t, r);
}
function iv(i, e, t, r) {
  return [{
    initDataTypes: i,
    persistentState: r.persistentState || "not-allowed",
    distinctiveIdentifier: r.distinctiveIdentifier || "not-allowed",
    sessionTypes: r.sessionTypes || [r.sessionType || "temporary"],
    audioCapabilities: e.map((s) => ({
      contentType: `audio/mp4; codecs="${s}"`,
      robustness: r.audioRobustness || "",
      encryptionScheme: r.audioEncryptionScheme || null
    })),
    videoCapabilities: t.map((s) => ({
      contentType: `video/mp4; codecs="${s}"`,
      robustness: r.videoRobustness || "",
      encryptionScheme: r.videoEncryptionScheme || null
    }))
  }];
}
function Tr(i, e, t) {
  return Uint8Array.prototype.slice ? i.slice(e, t) : new Uint8Array(Array.prototype.slice.call(i, e, t));
}
const Ps = (i, e) => e + 10 <= i.length && i[e] === 73 && i[e + 1] === 68 && i[e + 2] === 51 && i[e + 3] < 255 && i[e + 4] < 255 && i[e + 6] < 128 && i[e + 7] < 128 && i[e + 8] < 128 && i[e + 9] < 128, Ol = (i, e) => e + 10 <= i.length && i[e] === 51 && i[e + 1] === 68 && i[e + 2] === 73 && i[e + 3] < 255 && i[e + 4] < 255 && i[e + 6] < 128 && i[e + 7] < 128 && i[e + 8] < 128 && i[e + 9] < 128, Yi = (i, e) => {
  const t = e;
  let r = 0;
  for (; Ps(i, e); ) {
    r += 10;
    const n = dn(i, e + 6);
    r += n, Ol(i, e + 10) && (r += 10), e += r;
  }
  if (r > 0)
    return i.subarray(t, t + r);
}, dn = (i, e) => {
  let t = 0;
  return t = (i[e] & 127) << 21, t |= (i[e + 1] & 127) << 14, t |= (i[e + 2] & 127) << 7, t |= i[e + 3] & 127, t;
}, nv = (i, e) => Ps(i, e) && dn(i, e + 6) + 10 <= i.length - e, sv = (i) => {
  const e = Ml(i);
  for (let t = 0; t < e.length; t++) {
    const r = e[t];
    if (Pl(r))
      return dv(r);
  }
}, Pl = (i) => i && i.key === "PRIV" && i.info === "com.apple.streaming.transportStreamTimestamp", ov = (i) => {
  const e = String.fromCharCode(i[0], i[1], i[2], i[3]), t = dn(i, 4), r = 10;
  return {
    type: e,
    size: t,
    data: i.subarray(r, r + t)
  };
}, Ml = (i) => {
  let e = 0;
  const t = [];
  for (; Ps(i, e); ) {
    const r = dn(i, e + 6);
    e += 10;
    const n = e + r;
    for (; e + 8 < n; ) {
      const s = ov(i.subarray(e)), o = av(s);
      o && t.push(o), e += s.size + 10;
    }
    Ol(i, e) && (e += 10);
  }
  return t;
}, av = (i) => i.type === "PRIV" ? lv(i) : i.type[0] === "W" ? cv(i) : uv(i), lv = (i) => {
  if (i.size < 2)
    return;
  const e = Yt(i.data, !0), t = new Uint8Array(i.data.subarray(e.length + 1));
  return {
    key: i.type,
    info: e,
    data: t.buffer
  };
}, uv = (i) => {
  if (i.size < 2)
    return;
  if (i.type === "TXXX") {
    let t = 1;
    const r = Yt(i.data.subarray(t), !0);
    t += r.length + 1;
    const n = Yt(i.data.subarray(t));
    return {
      key: i.type,
      info: r,
      data: n
    };
  }
  const e = Yt(i.data.subarray(1));
  return {
    key: i.type,
    data: e
  };
}, cv = (i) => {
  if (i.type === "WXXX") {
    if (i.size < 2)
      return;
    let t = 1;
    const r = Yt(i.data.subarray(t), !0);
    t += r.length + 1;
    const n = Yt(i.data.subarray(t));
    return {
      key: i.type,
      info: r,
      data: n
    };
  }
  const e = Yt(i.data);
  return {
    key: i.type,
    data: e
  };
}, dv = (i) => {
  if (i.data.byteLength === 8) {
    const e = new Uint8Array(i.data), t = e[3] & 1;
    let r = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
    return r /= 45, t && (r += 4772185884e-2), Math.round(r);
  }
}, Yt = (i, e = !1) => {
  const t = hv();
  if (t) {
    const u = t.decode(i);
    if (e) {
      const c = u.indexOf("\0");
      return c !== -1 ? u.substring(0, c) : u;
    }
    return u.replace(/\0/g, "");
  }
  const r = i.length;
  let n, s, o, a = "", l = 0;
  for (; l < r; ) {
    if (n = i[l++], n === 0 && e)
      return a;
    if (n === 0 || n === 3)
      continue;
    switch (n >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        a += String.fromCharCode(n);
        break;
      case 12:
      case 13:
        s = i[l++], a += String.fromCharCode((n & 31) << 6 | s & 63);
        break;
      case 14:
        s = i[l++], o = i[l++], a += String.fromCharCode((n & 15) << 12 | (s & 63) << 6 | (o & 63) << 0);
        break;
    }
  }
  return a;
};
let Ln;
function hv() {
  return !Ln && typeof self.TextDecoder < "u" && (Ln = new self.TextDecoder("utf-8")), Ln;
}
const Vt = {
  hexDump: function(i) {
    let e = "";
    for (let t = 0; t < i.length; t++) {
      let r = i[t].toString(16);
      r.length < 2 && (r = "0" + r), e += r;
    }
    return e;
  }
}, zi = Math.pow(2, 32) - 1, fv = [].push, Bl = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};
function ot(i) {
  return String.fromCharCode.apply(null, i);
}
function Fl(i, e) {
  const t = i[e] << 8 | i[e + 1];
  return t < 0 ? 65536 + t : t;
}
function me(i, e) {
  const t = Nl(i, e);
  return t < 0 ? 4294967296 + t : t;
}
function Nl(i, e) {
  return i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3];
}
function Cn(i, e, t) {
  i[e] = t >> 24, i[e + 1] = t >> 16 & 255, i[e + 2] = t >> 8 & 255, i[e + 3] = t & 255;
}
function Pe(i, e) {
  const t = [];
  if (!e.length)
    return t;
  const r = i.byteLength;
  for (let n = 0; n < r; ) {
    const s = me(i, n), o = ot(i.subarray(n + 4, n + 8)), a = s > 1 ? n + s : r;
    if (o === e[0])
      if (e.length === 1)
        t.push(i.subarray(n + 8, a));
      else {
        const l = Pe(i.subarray(n + 8, a), e.slice(1));
        l.length && fv.apply(t, l);
      }
    n = a;
  }
  return t;
}
function pv(i) {
  const e = [], t = i[0];
  let r = 8;
  const n = me(i, r);
  r += 4;
  const s = 0, o = 0;
  t === 0 ? r += 8 : r += 16, r += 2;
  let a = i.length + o;
  const l = Fl(i, r);
  r += 2;
  for (let u = 0; u < l; u++) {
    let c = r;
    const d = me(i, c);
    c += 4;
    const h = d & 2147483647;
    if ((d & 2147483648) >>> 31 === 1)
      return K.warn("SIDX has hierarchical references (not supported)"), null;
    const f = me(i, c);
    c += 4, e.push({
      referenceSize: h,
      subsegmentDuration: f,
      // unscaled
      info: {
        duration: f / n,
        start: a,
        end: a + h - 1
      }
    }), a += h, c += 4, r = c;
  }
  return {
    earliestPresentationTime: s,
    timescale: n,
    version: t,
    referencesCount: l,
    references: e
  };
}
function Ul(i) {
  const e = [], t = Pe(i, ["moov", "trak"]);
  for (let n = 0; n < t.length; n++) {
    const s = t[n], o = Pe(s, ["tkhd"])[0];
    if (o) {
      let a = o[0], l = a === 0 ? 12 : 20;
      const u = me(o, l), c = Pe(s, ["mdia", "mdhd"])[0];
      if (c) {
        a = c[0], l = a === 0 ? 12 : 20;
        const d = me(c, l), h = Pe(s, ["mdia", "hdlr"])[0];
        if (h) {
          const p = ot(h.subarray(8, 12)), f = {
            soun: Ke.AUDIO,
            vide: Ke.VIDEO
          }[p];
          if (f) {
            const g = Pe(s, ["mdia", "minf", "stbl", "stsd"])[0];
            let m;
            g && (m = ot(g.subarray(12, 16))), e[u] = {
              timescale: d,
              type: f
            }, e[f] = {
              timescale: d,
              id: u,
              codec: m
            };
          }
        }
      }
    }
  }
  return Pe(i, ["moov", "mvex", "trex"]).forEach((n) => {
    const s = me(n, 4), o = e[s];
    o && (o.default = {
      duration: me(n, 12),
      flags: me(n, 20)
    });
  }), e;
}
function gv(i, e) {
  if (!i || !e)
    return i;
  const t = e.keyId;
  return t && e.isCommonEncryption && Pe(i, ["moov", "trak"]).forEach((n) => {
    const o = Pe(n, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
    let a = Pe(o, ["enca"]);
    const l = a.length > 0;
    l || (a = Pe(o, ["encv"])), a.forEach((u) => {
      const c = l ? u.subarray(28) : u.subarray(78);
      Pe(c, ["sinf"]).forEach((h) => {
        const p = Kl(h);
        if (p) {
          const f = p.subarray(8, 24);
          f.some((g) => g !== 0) || (K.log(`[eme] Patching keyId in 'enc${l ? "a" : "v"}>sinf>>tenc' box: ${Vt.hexDump(f)} -> ${Vt.hexDump(t)}`), p.set(t, 8));
        }
      });
    });
  }), i;
}
function Kl(i) {
  const e = Pe(i, ["schm"])[0];
  if (e) {
    const t = ot(e.subarray(4, 8));
    if (t === "cbcs" || t === "cenc")
      return Pe(i, ["schi", "tenc"])[0];
  }
  return K.error("[eme] missing 'schm' box"), null;
}
function mv(i, e) {
  return Pe(e, ["moof", "traf"]).reduce((t, r) => {
    const n = Pe(r, ["tfdt"])[0], s = n[0], o = Pe(r, ["tfhd"]).reduce((a, l) => {
      const u = me(l, 4), c = i[u];
      if (c) {
        let d = me(n, 4);
        if (s === 1) {
          if (d === zi)
            return K.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), a;
          d *= zi + 1, d += me(n, 8);
        }
        const h = c.timescale || 9e4, p = d / h;
        if (isFinite(p) && (a === null || p < a))
          return p;
      }
      return a;
    }, null);
    return o !== null && isFinite(o) && (t === null || o < t) ? o : t;
  }, null);
}
function vv(i, e) {
  let t = 0, r = 0, n = 0;
  const s = Pe(i, ["moof", "traf"]);
  for (let o = 0; o < s.length; o++) {
    const a = s[o], l = Pe(a, ["tfhd"])[0], u = me(l, 4), c = e[u];
    if (!c)
      continue;
    const d = c.default, h = me(l, 0) | (d == null ? void 0 : d.flags);
    let p = d == null ? void 0 : d.duration;
    h & 8 && (h & 2 ? p = me(l, 12) : p = me(l, 8));
    const f = c.timescale || 9e4, g = Pe(a, ["trun"]);
    for (let m = 0; m < g.length; m++) {
      if (t = yv(g[m]), !t && p) {
        const v = me(g[m], 4);
        t = p * v;
      }
      c.type === Ke.VIDEO ? r += t / f : c.type === Ke.AUDIO && (n += t / f);
    }
  }
  if (r === 0 && n === 0) {
    let o = 0;
    const a = Pe(i, ["sidx"]);
    for (let l = 0; l < a.length; l++) {
      const u = pv(a[l]);
      u != null && u.references && (o += u.references.reduce((c, d) => c + d.info.duration || 0, 0));
    }
    return o;
  }
  return r || n;
}
function yv(i) {
  const e = me(i, 0);
  let t = 8;
  e & 1 && (t += 4), e & 4 && (t += 4);
  let r = 0;
  const n = me(i, 4);
  for (let s = 0; s < n; s++) {
    if (e & 256) {
      const o = me(i, t);
      r += o, t += 4;
    }
    e & 512 && (t += 4), e & 1024 && (t += 4), e & 2048 && (t += 4);
  }
  return r;
}
function Ev(i, e, t) {
  Pe(e, ["moof", "traf"]).forEach((r) => {
    Pe(r, ["tfhd"]).forEach((n) => {
      const s = me(n, 4), o = i[s];
      if (!o)
        return;
      const a = o.timescale || 9e4;
      Pe(r, ["tfdt"]).forEach((l) => {
        const u = l[0];
        let c = me(l, 4);
        if (u === 0)
          c -= t * a, c = Math.max(c, 0), Cn(l, 4, c);
        else {
          c *= Math.pow(2, 32), c += me(l, 8), c -= t * a, c = Math.max(c, 0);
          const d = Math.floor(c / (zi + 1)), h = Math.floor(c % (zi + 1));
          Cn(l, 4, d), Cn(l, 8, h);
        }
      });
    });
  });
}
function Av(i) {
  const e = {
    valid: null,
    remainder: null
  }, t = Pe(i, ["moof"]);
  if (t) {
    if (t.length < 2)
      return e.remainder = i, e;
  } else
    return e;
  const r = t[t.length - 1];
  return e.valid = Tr(i, 0, r.byteOffset - 8), e.remainder = Tr(i, r.byteOffset - 8), e;
}
function Lr(i, e) {
  const t = new Uint8Array(i.length + e.length);
  return t.set(i), t.set(e, i.length), t;
}
function Qo(i, e) {
  const t = [], r = e.samples, n = e.timescale, s = e.id;
  let o = !1;
  return Pe(r, ["moof"]).map((l) => {
    const u = l.byteOffset - 8;
    Pe(l, ["traf"]).map((d) => {
      const h = Pe(d, ["tfdt"]).map((p) => {
        const f = p[0];
        let g = me(p, 4);
        return f === 1 && (g *= Math.pow(2, 32), g += me(p, 8)), g / n;
      })[0];
      return h !== void 0 && (i = h), Pe(d, ["tfhd"]).map((p) => {
        const f = me(p, 4), g = me(p, 0) & 16777215, m = (g & 1) !== 0, v = (g & 2) !== 0, E = (g & 8) !== 0;
        let A = 0;
        const _ = (g & 16) !== 0;
        let y = 0;
        const S = (g & 32) !== 0;
        let b = 8;
        f === s && (m && (b += 8), v && (b += 4), E && (A = me(p, b), b += 4), _ && (y = me(p, b), b += 4), S && (b += 4), e.type === "video" && (o = _v(e.codec)), Pe(d, ["trun"]).map((w) => {
          const P = w[0], C = me(w, 0) & 16777215, T = (C & 1) !== 0;
          let x = 0;
          const L = (C & 4) !== 0, I = (C & 256) !== 0;
          let R = 0;
          const B = (C & 512) !== 0;
          let D = 0;
          const k = (C & 1024) !== 0, F = (C & 2048) !== 0;
          let U = 0;
          const G = me(w, 4);
          let N = 8;
          T && (x = me(w, N), N += 4), L && (N += 4);
          let V = x + u;
          for (let j = 0; j < G; j++) {
            if (I ? (R = me(w, N), N += 4) : R = A, B ? (D = me(w, N), N += 4) : D = y, k && (N += 4), F && (P === 0 ? U = me(w, N) : U = Nl(w, N), N += 4), e.type === Ke.VIDEO) {
              let ee = 0;
              for (; ee < D; ) {
                const Y = me(r, V);
                if (V += 4, xv(o, r[V])) {
                  const te = r.subarray(V, V + Y);
                  Gl(te, o ? 2 : 1, i + U / n, t);
                }
                V += Y, ee += Y + 4;
              }
            }
            i += R / n;
          }
        }));
      });
    });
  }), t;
}
function _v(i) {
  if (!i)
    return !1;
  const e = i.indexOf("."), t = e < 0 ? i : i.substring(0, e);
  return t === "hvc1" || t === "hev1" || // Dolby Vision
  t === "dvh1" || t === "dvhe";
}
function xv(i, e) {
  if (i) {
    const t = e >> 1 & 63;
    return t === 39 || t === 40;
  } else
    return (e & 31) === 6;
}
function Gl(i, e, t, r) {
  const n = Vl(i);
  let s = 0;
  s += e;
  let o = 0, a = 0, l = !1, u = 0;
  for (; s < n.length; ) {
    o = 0;
    do {
      if (s >= n.length)
        break;
      u = n[s++], o += u;
    } while (u === 255);
    a = 0;
    do {
      if (s >= n.length)
        break;
      u = n[s++], a += u;
    } while (u === 255);
    const c = n.length - s;
    if (!l && o === 4 && s < n.length) {
      if (l = !0, n[s++] === 181) {
        const h = Fl(n, s);
        if (s += 2, h === 49) {
          const p = me(n, s);
          if (s += 4, p === 1195456820) {
            const f = n[s++];
            if (f === 3) {
              const g = n[s++], m = 31 & g, v = 64 & g, E = v ? 2 + m * 3 : 0, A = new Uint8Array(E);
              if (v) {
                A[0] = g;
                for (let _ = 1; _ < E; _++)
                  A[_] = n[s++];
              }
              r.push({
                type: f,
                payloadType: o,
                pts: t,
                bytes: A
              });
            }
          }
        }
      }
    } else if (o === 5 && a < c) {
      if (l = !0, a > 16) {
        const d = [];
        for (let f = 0; f < 16; f++) {
          const g = n[s++].toString(16);
          d.push(g.length == 1 ? "0" + g : g), (f === 3 || f === 5 || f === 7 || f === 9) && d.push("-");
        }
        const h = a - 16, p = new Uint8Array(h);
        for (let f = 0; f < h; f++)
          p[f] = n[s++];
        r.push({
          payloadType: o,
          pts: t,
          uuid: d.join(""),
          userData: Yt(p),
          userDataBytes: p
        });
      }
    } else if (a < c)
      s += a;
    else if (a > c)
      break;
  }
}
function Vl(i) {
  const e = i.byteLength, t = [];
  let r = 1;
  for (; r < e - 2; )
    i[r] === 0 && i[r + 1] === 0 && i[r + 2] === 3 ? (t.push(r + 2), r += 2) : r++;
  if (t.length === 0)
    return i;
  const n = e - t.length, s = new Uint8Array(n);
  let o = 0;
  for (r = 0; r < n; o++, r++)
    o === t[0] && (o++, t.shift()), s[r] = i[o];
  return s;
}
function Sv(i) {
  const e = i[0];
  let t = "", r = "", n = 0, s = 0, o = 0, a = 0, l = 0, u = 0;
  if (e === 0) {
    for (; ot(i.subarray(u, u + 1)) !== "\0"; )
      t += ot(i.subarray(u, u + 1)), u += 1;
    for (t += ot(i.subarray(u, u + 1)), u += 1; ot(i.subarray(u, u + 1)) !== "\0"; )
      r += ot(i.subarray(u, u + 1)), u += 1;
    r += ot(i.subarray(u, u + 1)), u += 1, n = me(i, 12), s = me(i, 16), a = me(i, 20), l = me(i, 24), u = 28;
  } else if (e === 1) {
    u += 4, n = me(i, u), u += 4;
    const d = me(i, u);
    u += 4;
    const h = me(i, u);
    for (u += 4, o = 2 ** 32 * d + h, Number.isSafeInteger(o) || (o = Number.MAX_SAFE_INTEGER, K.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), a = me(i, u), u += 4, l = me(i, u), u += 4; ot(i.subarray(u, u + 1)) !== "\0"; )
      t += ot(i.subarray(u, u + 1)), u += 1;
    for (t += ot(i.subarray(u, u + 1)), u += 1; ot(i.subarray(u, u + 1)) !== "\0"; )
      r += ot(i.subarray(u, u + 1)), u += 1;
    r += ot(i.subarray(u, u + 1)), u += 1;
  }
  const c = i.subarray(u, i.byteLength);
  return {
    schemeIdUri: t,
    value: r,
    timeScale: n,
    presentationTime: o,
    presentationTimeDelta: s,
    eventDuration: a,
    id: l,
    payload: c
  };
}
function Tv(i, ...e) {
  const t = e.length;
  let r = 8, n = t;
  for (; n--; )
    r += e[n].byteLength;
  const s = new Uint8Array(r);
  for (s[0] = r >> 24 & 255, s[1] = r >> 16 & 255, s[2] = r >> 8 & 255, s[3] = r & 255, s.set(i, 4), n = 0, r = 8; n < t; n++)
    s.set(e[n], r), r += e[n].byteLength;
  return s;
}
function Iv(i, e, t) {
  if (i.byteLength !== 16)
    throw new RangeError("Invalid system id");
  let r, n;
  if (e) {
    r = 1, n = new Uint8Array(e.length * 16);
    for (let a = 0; a < e.length; a++) {
      const l = e[a];
      if (l.byteLength !== 16)
        throw new RangeError("Invalid key");
      n.set(l, a * 16);
    }
  } else
    r = 0, n = new Uint8Array();
  let s;
  r > 0 ? (s = new Uint8Array(4), e.length > 0 && new DataView(s.buffer).setUint32(0, e.length, !1)) : s = new Uint8Array();
  const o = new Uint8Array(4);
  return t && t.byteLength > 0 && new DataView(o.buffer).setUint32(0, t.byteLength, !1), Tv(
    [112, 115, 115, 104],
    new Uint8Array([
      r,
      0,
      0,
      0
      // Flags
    ]),
    i,
    // 16 bytes
    s,
    n,
    o,
    t || new Uint8Array()
  );
}
function bv(i) {
  if (!(i instanceof ArrayBuffer) || i.byteLength < 32)
    return null;
  const e = {
    version: 0,
    systemId: "",
    kids: null,
    data: null
  }, t = new DataView(i), r = t.getUint32(0);
  if (i.byteLength !== r && r > 44 || t.getUint32(4) !== 1886614376 || (e.version = t.getUint32(8) >>> 24, e.version > 1))
    return null;
  e.systemId = Vt.hexDump(new Uint8Array(i, 12, 16));
  const s = t.getUint32(28);
  if (e.version === 0) {
    if (r - 32 < s)
      return null;
    e.data = new Uint8Array(i, 32, s);
  } else if (e.version === 1) {
    e.kids = [];
    for (let o = 0; o < s; o++)
      e.kids.push(new Uint8Array(i, 32 + o * 16, 16));
  }
  return e;
}
let Ci = {};
class yi {
  static clearKeyUriToKeyIdMap() {
    Ci = {};
  }
  constructor(e, t, r, n = [1], s = null) {
    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = r, this.keyFormatVersions = n, this.iv = s, this.encrypted = e ? e !== "NONE" : !1, this.isCommonEncryption = this.encrypted && e !== "AES-128";
  }
  isSupported() {
    if (this.method) {
      if (this.method === "AES-128" || this.method === "NONE")
        return !0;
      if (this.keyFormat === "identity")
        return this.method === "SAMPLE-AES";
      switch (this.keyFormat) {
        case At.FAIRPLAY:
        case At.WIDEVINE:
        case At.PLAYREADY:
        case At.CLEARKEY:
          return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
      }
    }
    return !1;
  }
  getDecryptData(e) {
    if (!this.encrypted || !this.uri)
      return null;
    if (this.method === "AES-128" && this.uri && !this.iv) {
      typeof e != "number" && (this.method === "AES-128" && !this.iv && K.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0);
      const r = Lv(e);
      return new yi(this.method, this.uri, "identity", this.keyFormatVersions, r);
    }
    const t = ev(this.uri);
    if (t)
      switch (this.keyFormat) {
        case At.WIDEVINE:
          this.pssh = t, t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6));
          break;
        case At.PLAYREADY: {
          const r = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
          this.pssh = Iv(r, null, t);
          const n = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2), s = String.fromCharCode.apply(null, Array.from(n)), o = s.substring(s.indexOf("<"), s.length), u = new DOMParser().parseFromString(o, "text/xml").getElementsByTagName("KID")[0];
          if (u) {
            const c = u.childNodes[0] ? u.childNodes[0].nodeValue : u.getAttribute("VALUE");
            if (c) {
              const d = Os(c).subarray(0, 16);
              $m(d), this.keyId = d;
            }
          }
          break;
        }
        default: {
          let r = t.subarray(0, 16);
          if (r.length !== 16) {
            const n = new Uint8Array(16);
            n.set(r, 16 - r.length), r = n;
          }
          this.keyId = r;
          break;
        }
      }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let r = Ci[this.uri];
      if (!r) {
        const n = Object.keys(Ci).length % Number.MAX_SAFE_INTEGER;
        r = new Uint8Array(16), new DataView(r.buffer, 12, 4).setUint32(0, n), Ci[this.uri] = r;
      }
      this.keyId = r;
    }
    return this;
  }
}
function Lv(i) {
  const e = new Uint8Array(16);
  for (let t = 12; t < 16; t++)
    e[t] = i >> 8 * (15 - t) & 255;
  return e;
}
const Hl = /\{\$([a-zA-Z0-9-_]+)\}/g;
function Jo(i) {
  return Hl.test(i);
}
function yt(i, e, t) {
  if (i.variableList !== null || i.hasVariableRefs)
    for (let r = t.length; r--; ) {
      const n = t[r], s = e[n];
      s && (e[n] = es(i, s));
    }
}
function es(i, e) {
  if (i.variableList !== null || i.hasVariableRefs) {
    const t = i.variableList;
    return e.replace(Hl, (r) => {
      const n = r.substring(2, r.length - 1), s = t == null ? void 0 : t[n];
      return s === void 0 ? (i.playlistParsingError || (i.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${n}"`)), r) : s;
    });
  }
  return e;
}
function Yo(i, e, t) {
  let r = i.variableList;
  r || (i.variableList = r = {});
  let n, s;
  if ("QUERYPARAM" in e) {
    n = e.QUERYPARAM;
    try {
      const o = new self.URL(t).searchParams;
      if (o.has(n))
        s = o.get(n);
      else
        throw new Error(`"${n}" does not match any query parameter in URI: "${t}"`);
    } catch (o) {
      i.playlistParsingError || (i.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${o.message}`));
    }
  } else
    n = e.NAME, s = e.VALUE;
  n in r ? i.playlistParsingError || (i.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${n}"`)) : r[n] = s || "";
}
function Cv(i, e, t) {
  const r = e.IMPORT;
  if (t && r in t) {
    let n = i.variableList;
    n || (i.variableList = n = {}), n[r] = t[r];
  } else
    i.playlistParsingError || (i.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`));
}
function hn() {
  if (!(typeof self > "u"))
    return self.MediaSource || self.WebKitMediaSource;
}
const Rv = {
  audio: {
    a3ds: !0,
    "ac-3": !0,
    "ac-4": !0,
    alac: !0,
    alaw: !0,
    dra1: !0,
    "dts+": !0,
    "dts-": !0,
    dtsc: !0,
    dtse: !0,
    dtsh: !0,
    "ec-3": !0,
    enca: !0,
    g719: !0,
    g726: !0,
    m4ae: !0,
    mha1: !0,
    mha2: !0,
    mhm1: !0,
    mhm2: !0,
    mlpa: !0,
    mp4a: !0,
    "raw ": !0,
    Opus: !0,
    opus: !0,
    // browsers expect this to be lowercase despite MP4RA says 'Opus'
    samr: !0,
    sawb: !0,
    sawp: !0,
    sevc: !0,
    sqcp: !0,
    ssmv: !0,
    twos: !0,
    ulaw: !0
  },
  video: {
    avc1: !0,
    avc2: !0,
    avc3: !0,
    avc4: !0,
    avcp: !0,
    av01: !0,
    drac: !0,
    dva1: !0,
    dvav: !0,
    dvh1: !0,
    dvhe: !0,
    encv: !0,
    hev1: !0,
    hvc1: !0,
    mjp2: !0,
    mp4v: !0,
    mvc1: !0,
    mvc2: !0,
    mvc3: !0,
    mvc4: !0,
    resv: !0,
    rv60: !0,
    s263: !0,
    svc1: !0,
    svc2: !0,
    "vc-1": !0,
    vp08: !0,
    vp09: !0
  },
  text: {
    stpp: !0,
    wvtt: !0
  }
}, zo = hn();
function wv(i, e) {
  const t = Rv[e];
  return !!t && t[i.slice(0, 4)] === !0;
}
function Rn(i, e) {
  var t;
  return (t = zo == null ? void 0 : zo.isTypeSupported(`${e || "video"}/mp4;codecs="${i}"`)) != null ? t : !1;
}
const qo = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, Zo = /#EXT-X-MEDIA:(.*)/g, kv = /^#EXT(?:INF|-X-TARGETDURATION):/m, Xo = new RegExp([
  /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
  /(?!#) *(\S[\S ]*)/.source,
  // segment URI, group 3 => the URI (note newline is not eaten)
  /#EXT-X-BYTERANGE:*(.+)/.source,
  // next segment's byterange, group 4 => range spec (x@y)
  /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
  // next segment's program date/time group 5 => the datetime spec
  /#.*/.source
  // All other non-segment oriented tags will match with all groups empty
].join("|"), "g"), Dv = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class Kt {
  static findGroup(e, t) {
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.id === t)
        return n;
    }
  }
  static convertAVC1ToAVCOTI(e) {
    const t = e.split(".");
    if (t.length > 2) {
      let r = t.shift() + ".";
      return r += parseInt(t.shift()).toString(16), r += ("000" + parseInt(t.shift()).toString(16)).slice(-4), r;
    }
    return e;
  }
  static resolve(e, t) {
    return Ds.buildAbsoluteURL(t, e, {
      alwaysNormalize: !0
    });
  }
  static isMediaPlaylist(e) {
    return kv.test(e);
  }
  static parseMasterPlaylist(e, t) {
    const r = Jo(e), n = {
      contentSteering: null,
      levels: [],
      playlistParsingError: null,
      sessionData: null,
      sessionKeys: null,
      startTimeOffset: null,
      variableList: null,
      hasVariableRefs: r
    }, s = [];
    qo.lastIndex = 0;
    let o;
    for (; (o = qo.exec(e)) != null; )
      if (o[1]) {
        var a;
        const u = new We(o[1]);
        yt(n, u, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
        const c = es(n, o[2]), d = {
          attrs: u,
          bitrate: u.decimalInteger("AVERAGE-BANDWIDTH") || u.decimalInteger("BANDWIDTH"),
          name: u.NAME,
          url: Kt.resolve(c, t)
        }, h = u.decimalResolution("RESOLUTION");
        h && (d.width = h.width, d.height = h.height), Ov((u.CODECS || "").split(/[ ,]+/).filter((p) => p), d), d.videoCodec && d.videoCodec.indexOf("avc1") !== -1 && (d.videoCodec = Kt.convertAVC1ToAVCOTI(d.videoCodec)), (a = d.unknownCodecs) != null && a.length || s.push(d), n.levels.push(d);
      } else if (o[3]) {
        const u = o[3], c = o[4];
        switch (u) {
          case "SESSION-DATA": {
            const d = new We(c);
            yt(n, d, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
            const h = d["DATA-ID"];
            h && (n.sessionData === null && (n.sessionData = {}), n.sessionData[h] = d);
            break;
          }
          case "SESSION-KEY": {
            const d = $o(c, t, n);
            d.encrypted && d.isSupported() ? (n.sessionKeys === null && (n.sessionKeys = []), n.sessionKeys.push(d)) : K.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${c}"`);
            break;
          }
          case "DEFINE": {
            {
              const d = new We(c);
              yt(n, d, ["NAME", "VALUE", "QUERYPARAM"]), Yo(n, d, t);
            }
            break;
          }
          case "CONTENT-STEERING": {
            const d = new We(c);
            yt(n, d, ["SERVER-URI", "PATHWAY-ID"]), n.contentSteering = {
              uri: Kt.resolve(d["SERVER-URI"], t),
              pathwayId: d["PATHWAY-ID"] || "."
            };
            break;
          }
          case "START": {
            n.startTimeOffset = ea(c);
            break;
          }
        }
      }
    const l = s.length > 0 && s.length < n.levels.length;
    return n.levels = l ? s : n.levels, n.levels.length === 0 && (n.playlistParsingError = new Error("no levels found in manifest")), n;
  }
  static parseMasterPlaylistMedia(e, t, r) {
    let n;
    const s = {}, o = r.levels, a = {
      AUDIO: o.map((u) => ({
        id: u.attrs.AUDIO,
        audioCodec: u.audioCodec
      })),
      SUBTITLES: o.map((u) => ({
        id: u.attrs.SUBTITLES,
        textCodec: u.textCodec
      })),
      "CLOSED-CAPTIONS": []
    };
    let l = 0;
    for (Zo.lastIndex = 0; (n = Zo.exec(e)) !== null; ) {
      const u = new We(n[1]), c = u.TYPE;
      if (c) {
        const d = a[c], h = s[c] || [];
        s[c] = h, yt(r, u, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
        const p = {
          attrs: u,
          bitrate: 0,
          id: l++,
          groupId: u["GROUP-ID"] || "",
          instreamId: u["INSTREAM-ID"],
          name: u.NAME || u.LANGUAGE || "",
          type: c,
          default: u.bool("DEFAULT"),
          autoselect: u.bool("AUTOSELECT"),
          forced: u.bool("FORCED"),
          lang: u.LANGUAGE,
          url: u.URI ? Kt.resolve(u.URI, t) : ""
        };
        if (d != null && d.length) {
          const f = Kt.findGroup(d, p.groupId) || d[0];
          ta(p, f, "audioCodec"), ta(p, f, "textCodec");
        }
        h.push(p);
      }
    }
    return s;
  }
  static parseLevelPlaylist(e, t, r, n, s, o) {
    const a = new Zm(t), l = a.fragments;
    let u = null, c = 0, d = 0, h = 0, p = 0, f = null, g = new In(n, t), m, v, E, A = -1, _ = !1;
    for (Xo.lastIndex = 0, a.m3u8 = e, a.hasVariableRefs = Jo(e); (m = Xo.exec(e)) !== null; ) {
      _ && (_ = !1, g = new In(n, t), g.start = h, g.sn = c, g.cc = p, g.level = r, u && (g.initSegment = u, g.rawProgramDateTime = u.rawProgramDateTime, u.rawProgramDateTime = null));
      const w = m[1];
      if (w) {
        g.duration = parseFloat(w);
        const P = (" " + m[2]).slice(1);
        g.title = P || null, g.tagList.push(P ? ["INF", w, P] : ["INF", w]);
      } else if (m[3]) {
        if (de(g.duration)) {
          g.start = h, E && na(g, E, a), g.sn = c, g.level = r, g.cc = p, g.urlId = s, l.push(g);
          const P = (" " + m[3]).slice(1);
          g.relurl = es(a, P), ra(g, f), f = g, h += g.duration, c++, d = 0, _ = !0;
        }
      } else if (m[4]) {
        const P = (" " + m[4]).slice(1);
        f ? g.setByteRange(P, f) : g.setByteRange(P);
      } else if (m[5])
        g.rawProgramDateTime = (" " + m[5]).slice(1), g.tagList.push(["PROGRAM-DATE-TIME", g.rawProgramDateTime]), A === -1 && (A = l.length);
      else {
        if (m = m[0].match(Dv), !m) {
          K.warn("No matches on slow regex match for level playlist!");
          continue;
        }
        for (v = 1; v < m.length && !(typeof m[v] < "u"); v++)
          ;
        const P = (" " + m[v]).slice(1), C = (" " + m[v + 1]).slice(1), T = m[v + 2] ? (" " + m[v + 2]).slice(1) : "";
        switch (P) {
          case "PLAYLIST-TYPE":
            a.type = C.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            c = a.startSN = parseInt(C);
            break;
          case "SKIP": {
            const x = new We(C);
            yt(a, x, ["RECENTLY-REMOVED-DATERANGES"]);
            const L = x.decimalInteger("SKIPPED-SEGMENTS");
            if (de(L)) {
              a.skippedSegments = L;
              for (let R = L; R--; )
                l.unshift(null);
              c += L;
            }
            const I = x.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            I && (a.recentlyRemovedDateranges = I.split("	"));
            break;
          }
          case "TARGETDURATION":
            a.targetduration = Math.max(parseInt(C), 1);
            break;
          case "VERSION":
            a.version = parseInt(C);
            break;
          case "EXTM3U":
            break;
          case "ENDLIST":
            a.live = !1;
            break;
          case "#":
            (C || T) && g.tagList.push(T ? [C, T] : [C]);
            break;
          case "DISCONTINUITY":
            p++, g.tagList.push(["DIS"]);
            break;
          case "GAP":
            g.gap = !0, g.tagList.push([P]);
            break;
          case "BITRATE":
            g.tagList.push([P, C]);
            break;
          case "DATERANGE": {
            const x = new We(C);
            yt(a, x, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]), yt(a, x, x.clientAttrs);
            const L = new Cl(x, a.dateRanges[x.ID]);
            L.isValid || a.skippedSegments ? a.dateRanges[L.id] = L : K.warn(`Ignoring invalid DATERANGE tag: "${C}"`), g.tagList.push(["EXT-X-DATERANGE", C]);
            break;
          }
          case "DEFINE": {
            {
              const x = new We(C);
              yt(a, x, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]), "IMPORT" in x ? Cv(a, x, o) : Yo(a, x, t);
            }
            break;
          }
          case "DISCONTINUITY-SEQUENCE":
            p = parseInt(C);
            break;
          case "KEY": {
            const x = $o(C, t, a);
            if (x.isSupported()) {
              if (x.method === "NONE") {
                E = void 0;
                break;
              }
              E || (E = {}), E[x.keyFormat] && (E = et({}, E)), E[x.keyFormat] = x;
            } else
              K.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${C}"`);
            break;
          }
          case "START":
            a.startTimeOffset = ea(C);
            break;
          case "MAP": {
            const x = new We(C);
            if (yt(a, x, ["BYTERANGE", "URI"]), g.duration) {
              const L = new In(n, t);
              ia(L, x, r, E), u = L, g.initSegment = u, u.rawProgramDateTime && !g.rawProgramDateTime && (g.rawProgramDateTime = u.rawProgramDateTime);
            } else
              ia(g, x, r, E), u = g, _ = !0;
            break;
          }
          case "SERVER-CONTROL": {
            const x = new We(C);
            a.canBlockReload = x.bool("CAN-BLOCK-RELOAD"), a.canSkipUntil = x.optionalFloat("CAN-SKIP-UNTIL", 0), a.canSkipDateRanges = a.canSkipUntil > 0 && x.bool("CAN-SKIP-DATERANGES"), a.partHoldBack = x.optionalFloat("PART-HOLD-BACK", 0), a.holdBack = x.optionalFloat("HOLD-BACK", 0);
            break;
          }
          case "PART-INF": {
            const x = new We(C);
            a.partTarget = x.decimalFloatingPoint("PART-TARGET");
            break;
          }
          case "PART": {
            let x = a.partList;
            x || (x = a.partList = []);
            const L = d > 0 ? x[x.length - 1] : void 0, I = d++, R = new We(C);
            yt(a, R, ["BYTERANGE", "URI"]);
            const B = new zm(R, g, t, I, L);
            x.push(B), g.duration += B.duration;
            break;
          }
          case "PRELOAD-HINT": {
            const x = new We(C);
            yt(a, x, ["URI"]), a.preloadHint = x;
            break;
          }
          case "RENDITION-REPORT": {
            const x = new We(C);
            yt(a, x, ["URI"]), a.renditionReports = a.renditionReports || [], a.renditionReports.push(x);
            break;
          }
          default:
            K.warn(`line parsed but not handled: ${m}`);
            break;
        }
      }
    }
    f && !f.relurl ? (l.pop(), h -= f.duration, a.partList && (a.fragmentHint = f)) : a.partList && (ra(g, f), g.cc = p, a.fragmentHint = g, E && na(g, E, a));
    const y = l.length, S = l[0], b = l[y - 1];
    if (h += a.skippedSegments * a.targetduration, h > 0 && y && b) {
      a.averagetargetduration = h / y;
      const w = b.sn;
      a.endSN = w !== "initSegment" ? w : 0, a.live || (b.endList = !0), S && (a.startCC = S.cc);
    } else
      a.endSN = 0, a.startCC = 0;
    return a.fragmentHint && (h += a.fragmentHint.duration), a.totalduration = h, a.endCC = p, A > 0 && Pv(l, A), a;
  }
}
function $o(i, e, t) {
  var r, n;
  const s = new We(i);
  yt(t, s, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
  const o = (r = s.METHOD) != null ? r : "", a = s.URI, l = s.hexadecimalInteger("IV"), u = s.KEYFORMATVERSIONS, c = (n = s.KEYFORMAT) != null ? n : "identity";
  a && s.IV && !l && K.error(`Invalid IV: ${s.IV}`);
  const d = a ? Kt.resolve(a, e) : "", h = (u || "1").split("/").map(Number).filter(Number.isFinite);
  return new yi(o, d, c, h, l);
}
function ea(i) {
  const t = new We(i).decimalFloatingPoint("TIME-OFFSET");
  return de(t) ? t : null;
}
function Ov(i, e) {
  ["video", "audio", "text"].forEach((t) => {
    const r = i.filter((n) => wv(n, t));
    if (r.length) {
      const n = r.filter((s) => s.lastIndexOf("avc1", 0) === 0 || s.lastIndexOf("mp4a", 0) === 0);
      e[`${t}Codec`] = n.length > 0 ? n[0] : r[0], i = i.filter((s) => r.indexOf(s) === -1);
    }
  }), e.unknownCodecs = i;
}
function ta(i, e, t) {
  const r = e[t];
  r && (i[t] = r);
}
function Pv(i, e) {
  let t = i[e];
  for (let r = e; r--; ) {
    const n = i[r];
    if (!n)
      return;
    n.programDateTime = t.programDateTime - n.duration * 1e3, t = n;
  }
}
function ra(i, e) {
  i.rawProgramDateTime ? i.programDateTime = Date.parse(i.rawProgramDateTime) : e != null && e.programDateTime && (i.programDateTime = e.endProgramDateTime), de(i.programDateTime) || (i.programDateTime = null, i.rawProgramDateTime = null);
}
function ia(i, e, t, r) {
  i.relurl = e.URI, e.BYTERANGE && i.setByteRange(e.BYTERANGE), i.level = t, i.sn = "initSegment", r && (i.levelkeys = r), i.initSegment = null;
}
function na(i, e, t) {
  i.levelkeys = e;
  const {
    encryptedFragments: r
  } = t;
  (!r.length || r[r.length - 1].levelkeys !== e) && Object.keys(e).some((n) => e[n].isCommonEncryption) && r.push(i);
}
var Be = {
  MANIFEST: "manifest",
  LEVEL: "level",
  AUDIO_TRACK: "audioTrack",
  SUBTITLE_TRACK: "subtitleTrack"
}, ge = {
  MAIN: "main",
  AUDIO: "audio",
  SUBTITLE: "subtitle"
};
function sa(i) {
  const {
    type: e
  } = i;
  switch (e) {
    case Be.AUDIO_TRACK:
      return ge.AUDIO;
    case Be.SUBTITLE_TRACK:
      return ge.SUBTITLE;
    default:
      return ge.MAIN;
  }
}
function wn(i, e) {
  let t = i.url;
  return (t === void 0 || t.indexOf("data:") === 0) && (t = e.url), t;
}
class Mv {
  constructor(e) {
    this.hls = void 0, this.loaders = /* @__PURE__ */ Object.create(null), this.variableList = null, this.hls = e, this.registerListeners();
  }
  startLoad(e) {
  }
  stopLoad() {
    this.destroyInternalLoaders();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.LEVEL_LOADING, this.onLevelLoading, this), e.on(O.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(O.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.LEVEL_LOADING, this.onLevelLoading, this), e.off(O.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(O.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
  }
  /**
   * Returns defaults or configured loader-type overloads (pLoader and loader config params)
   */
  createInternalLoader(e) {
    const t = this.hls.config, r = t.pLoader, n = t.loader, s = r || n, o = new s(t);
    return this.loaders[e.type] = o, o;
  }
  getInternalLoader(e) {
    return this.loaders[e.type];
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e];
  }
  /**
   * Call `destroy` on all internal loader instances mapped (one per context type)
   */
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const t = this.loaders[e];
      t && t.destroy(), this.resetInternalLoader(e);
    }
  }
  destroy() {
    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders();
  }
  onManifestLoading(e, t) {
    const {
      url: r
    } = t;
    this.variableList = null, this.load({
      id: null,
      level: 0,
      responseType: "text",
      type: Be.MANIFEST,
      url: r,
      deliveryDirectives: null
    });
  }
  onLevelLoading(e, t) {
    const {
      id: r,
      level: n,
      url: s,
      deliveryDirectives: o
    } = t;
    this.load({
      id: r,
      level: n,
      responseType: "text",
      type: Be.LEVEL,
      url: s,
      deliveryDirectives: o
    });
  }
  onAudioTrackLoading(e, t) {
    const {
      id: r,
      groupId: n,
      url: s,
      deliveryDirectives: o
    } = t;
    this.load({
      id: r,
      groupId: n,
      level: null,
      responseType: "text",
      type: Be.AUDIO_TRACK,
      url: s,
      deliveryDirectives: o
    });
  }
  onSubtitleTrackLoading(e, t) {
    const {
      id: r,
      groupId: n,
      url: s,
      deliveryDirectives: o
    } = t;
    this.load({
      id: r,
      groupId: n,
      level: null,
      responseType: "text",
      type: Be.SUBTITLE_TRACK,
      url: s,
      deliveryDirectives: o
    });
  }
  load(e) {
    var t;
    const r = this.hls.config;
    let n = this.getInternalLoader(e);
    if (n) {
      const u = n.context;
      if (u && u.url === e.url) {
        K.trace("[playlist-loader]: playlist request ongoing");
        return;
      }
      K.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), n.abort();
    }
    let s;
    if (e.type === Be.MANIFEST ? s = r.manifestLoadPolicy.default : s = et({}, r.playlistLoadPolicy.default, {
      timeoutRetry: null,
      errorRetry: null
    }), n = this.createInternalLoader(e), (t = e.deliveryDirectives) != null && t.part) {
      let u;
      if (e.type === Be.LEVEL && e.level !== null ? u = this.hls.levels[e.level].details : e.type === Be.AUDIO_TRACK && e.id !== null ? u = this.hls.audioTracks[e.id].details : e.type === Be.SUBTITLE_TRACK && e.id !== null && (u = this.hls.subtitleTracks[e.id].details), u) {
        const c = u.partTarget, d = u.targetduration;
        if (c && d) {
          const h = Math.max(c * 3, d * 0.8) * 1e3;
          s = et({}, s, {
            maxTimeToFirstByteMs: Math.min(h, s.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(h, s.maxTimeToFirstByteMs)
          });
        }
      }
    }
    const o = s.errorRetry || s.timeoutRetry || {}, a = {
      loadPolicy: s,
      timeout: s.maxLoadTimeMs,
      maxRetry: o.maxNumRetry || 0,
      retryDelay: o.retryDelayMs || 0,
      maxRetryDelay: o.maxRetryDelayMs || 0
    }, l = {
      onSuccess: (u, c, d, h) => {
        const p = this.getInternalLoader(d);
        this.resetInternalLoader(d.type);
        const f = u.data;
        if (f.indexOf("#EXTM3U") !== 0) {
          this.handleManifestParsingError(u, d, new Error("no EXTM3U delimiter"), h || null, c);
          return;
        }
        c.parsing.start = performance.now(), Kt.isMediaPlaylist(f) ? this.handleTrackOrLevelPlaylist(u, c, d, h || null, p) : this.handleMasterPlaylist(u, c, d, h);
      },
      onError: (u, c, d, h) => {
        this.handleNetworkError(c, d, !1, u, h);
      },
      onTimeout: (u, c, d) => {
        this.handleNetworkError(c, d, !0, void 0, u);
      }
    };
    n.load(e, a, l);
  }
  handleMasterPlaylist(e, t, r, n) {
    const s = this.hls, o = e.data, a = wn(e, r), l = Kt.parseMasterPlaylist(o, a);
    if (l.playlistParsingError) {
      this.handleManifestParsingError(e, r, l.playlistParsingError, n, t);
      return;
    }
    const {
      contentSteering: u,
      levels: c,
      sessionData: d,
      sessionKeys: h,
      startTimeOffset: p,
      variableList: f
    } = l;
    this.variableList = f;
    const {
      AUDIO: g = [],
      SUBTITLES: m,
      "CLOSED-CAPTIONS": v
    } = Kt.parseMasterPlaylistMedia(o, a, l);
    g.length && !g.some((A) => !A.url) && c[0].audioCodec && !c[0].attrs.AUDIO && (K.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), g.unshift({
      type: "main",
      name: "main",
      groupId: "main",
      default: !1,
      autoselect: !1,
      forced: !1,
      id: -1,
      attrs: new We({}),
      bitrate: 0,
      url: ""
    })), s.trigger(O.MANIFEST_LOADED, {
      levels: c,
      audioTracks: g,
      subtitles: m,
      captions: v,
      contentSteering: u,
      url: a,
      stats: t,
      networkDetails: n,
      sessionData: d,
      sessionKeys: h,
      startTimeOffset: p,
      variableList: f
    });
  }
  handleTrackOrLevelPlaylist(e, t, r, n, s) {
    const o = this.hls, {
      id: a,
      level: l,
      type: u
    } = r, c = wn(e, r), d = de(a) ? a : 0, h = de(l) ? l : d, p = sa(r), f = Kt.parseLevelPlaylist(e.data, c, h, p, d, this.variableList);
    if (u === Be.MANIFEST) {
      const g = {
        attrs: new We({}),
        bitrate: 0,
        details: f,
        name: "",
        url: c
      };
      o.trigger(O.MANIFEST_LOADED, {
        levels: [g],
        audioTracks: [],
        url: c,
        stats: t,
        networkDetails: n,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      });
    }
    t.parsing.end = performance.now(), r.levelDetails = f, this.handlePlaylistLoaded(f, e, t, r, n, s);
  }
  handleManifestParsingError(e, t, r, n, s) {
    this.hls.trigger(O.ERROR, {
      type: fe.NETWORK_ERROR,
      details: W.MANIFEST_PARSING_ERROR,
      fatal: t.type === Be.MANIFEST,
      url: e.url,
      err: r,
      error: r,
      reason: r.message,
      response: e,
      context: t,
      networkDetails: n,
      stats: s
    });
  }
  handleNetworkError(e, t, r = !1, n, s) {
    let o = `A network ${r ? "timeout" : "error" + (n ? " (status " + n.code + ")" : "")} occurred while loading ${e.type}`;
    e.type === Be.LEVEL ? o += `: ${e.level} id: ${e.id}` : (e.type === Be.AUDIO_TRACK || e.type === Be.SUBTITLE_TRACK) && (o += ` id: ${e.id} group-id: "${e.groupId}"`);
    const a = new Error(o);
    K.warn(`[playlist-loader]: ${o}`);
    let l = W.UNKNOWN, u = !1;
    const c = this.getInternalLoader(e);
    switch (e.type) {
      case Be.MANIFEST:
        l = r ? W.MANIFEST_LOAD_TIMEOUT : W.MANIFEST_LOAD_ERROR, u = !0;
        break;
      case Be.LEVEL:
        l = r ? W.LEVEL_LOAD_TIMEOUT : W.LEVEL_LOAD_ERROR, u = !1;
        break;
      case Be.AUDIO_TRACK:
        l = r ? W.AUDIO_TRACK_LOAD_TIMEOUT : W.AUDIO_TRACK_LOAD_ERROR, u = !1;
        break;
      case Be.SUBTITLE_TRACK:
        l = r ? W.SUBTITLE_TRACK_LOAD_TIMEOUT : W.SUBTITLE_LOAD_ERROR, u = !1;
        break;
    }
    c && this.resetInternalLoader(e.type);
    const d = {
      type: fe.NETWORK_ERROR,
      details: l,
      fatal: u,
      url: e.url,
      loader: c,
      context: e,
      error: a,
      networkDetails: t,
      stats: s
    };
    if (n) {
      const h = (t == null ? void 0 : t.url) || e.url;
      d.response = Tt({
        url: h,
        data: void 0
      }, n);
    }
    this.hls.trigger(O.ERROR, d);
  }
  handlePlaylistLoaded(e, t, r, n, s, o) {
    const a = this.hls, {
      type: l,
      level: u,
      id: c,
      groupId: d,
      deliveryDirectives: h
    } = n, p = wn(t, n), f = sa(n), g = typeof n.level == "number" && f === ge.MAIN ? u : void 0;
    if (!e.fragments.length) {
      const v = new Error("No Segments found in Playlist");
      a.trigger(O.ERROR, {
        type: fe.NETWORK_ERROR,
        details: W.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: p,
        error: v,
        reason: v.message,
        response: t,
        context: n,
        level: g,
        parent: f,
        networkDetails: s,
        stats: r
      });
      return;
    }
    e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
    const m = e.playlistParsingError;
    if (m) {
      a.trigger(O.ERROR, {
        type: fe.NETWORK_ERROR,
        details: W.LEVEL_PARSING_ERROR,
        fatal: !1,
        url: p,
        error: m,
        reason: m.message,
        response: t,
        context: n,
        level: g,
        parent: f,
        networkDetails: s,
        stats: r
      });
      return;
    }
    switch (e.live && o && (o.getCacheAge && (e.ageHeader = o.getCacheAge() || 0), (!o.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), l) {
      case Be.MANIFEST:
      case Be.LEVEL:
        a.trigger(O.LEVEL_LOADED, {
          details: e,
          level: g || 0,
          id: c || 0,
          stats: r,
          networkDetails: s,
          deliveryDirectives: h
        });
        break;
      case Be.AUDIO_TRACK:
        a.trigger(O.AUDIO_TRACK_LOADED, {
          details: e,
          id: c || 0,
          groupId: d || "",
          stats: r,
          networkDetails: s,
          deliveryDirectives: h
        });
        break;
      case Be.SUBTITLE_TRACK:
        a.trigger(O.SUBTITLE_TRACK_LOADED, {
          details: e,
          id: c || 0,
          groupId: d || "",
          stats: r,
          networkDetails: s,
          deliveryDirectives: h
        });
        break;
    }
  }
}
function jl(i, e) {
  let t;
  try {
    t = new Event("addtrack");
  } catch {
    t = document.createEvent("Event"), t.initEvent("addtrack", !1, !1);
  }
  t.track = i, e.dispatchEvent(t);
}
function Wl(i, e) {
  const t = i.mode;
  if (t === "disabled" && (i.mode = "hidden"), i.cues && !i.cues.getCueById(e.id))
    try {
      if (i.addCue(e), !i.cues.getCueById(e.id))
        throw new Error(`addCue is failed for: ${e}`);
    } catch (r) {
      K.debug(`[texttrack-utils]: ${r}`);
      const n = new self.TextTrackCue(e.startTime, e.endTime, e.text);
      n.id = e.id, i.addCue(n);
    }
  t === "disabled" && (i.mode = t);
}
function Kr(i) {
  const e = i.mode;
  if (e === "disabled" && (i.mode = "hidden"), i.cues)
    for (let t = i.cues.length; t--; )
      i.removeCue(i.cues[t]);
  e === "disabled" && (i.mode = e);
}
function ts(i, e, t, r) {
  const n = i.mode;
  if (n === "disabled" && (i.mode = "hidden"), i.cues && i.cues.length > 0) {
    const s = Fv(i.cues, e, t);
    for (let o = 0; o < s.length; o++)
      (!r || r(s[o])) && i.removeCue(s[o]);
  }
  n === "disabled" && (i.mode = n);
}
function Bv(i, e) {
  if (e < i[0].startTime)
    return 0;
  const t = i.length - 1;
  if (e > i[t].endTime)
    return -1;
  let r = 0, n = t;
  for (; r <= n; ) {
    const s = Math.floor((n + r) / 2);
    if (e < i[s].startTime)
      n = s - 1;
    else if (e > i[s].startTime && r < t)
      r = s + 1;
    else
      return s;
  }
  return i[r].startTime - e < e - i[n].startTime ? r : n;
}
function Fv(i, e, t) {
  const r = [], n = Bv(i, e);
  if (n > -1)
    for (let s = n, o = i.length; s < o; s++) {
      const a = i[s];
      if (a.startTime >= e && a.endTime <= t)
        r.push(a);
      else if (a.startTime > t)
        return r;
    }
  return r;
}
var Ft = {
  audioId3: "org.id3",
  dateRange: "com.apple.quicktime.HLS",
  emsg: "https://aomedia.org/emsg/ID3"
};
const Nv = 0.25;
function rs() {
  if (!(typeof self > "u"))
    return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;
}
const Ri = (() => {
  const i = rs();
  try {
    new i(0, Number.POSITIVE_INFINITY, "");
  } catch {
    return Number.MAX_VALUE;
  }
  return Number.POSITIVE_INFINITY;
})();
function kn(i, e) {
  return i.getTime() / 1e3 - e;
}
function Uv(i) {
  return Uint8Array.from(i.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
}
class Kv {
  constructor(e) {
    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners();
  }
  destroy() {
    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null;
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(O.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(O.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(O.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(O.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  // Add ID3 metatadata text track.
  onMediaAttached(e, t) {
    this.media = t.media;
  }
  onMediaDetaching() {
    this.id3Track && (Kr(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {});
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {};
  }
  createTrack(e) {
    const t = this.getID3Track(e.textTracks);
    return t.mode = "hidden", t;
  }
  getID3Track(e) {
    if (this.media) {
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        if (r.kind === "metadata" && r.label === "id3")
          return jl(r, this.media), r;
      }
      return this.media.addTextTrack("metadata", "id3");
    }
  }
  onFragParsingMetadata(e, t) {
    if (!this.media)
      return;
    const {
      hls: {
        config: {
          enableEmsgMetadataCues: r,
          enableID3MetadataCues: n
        }
      }
    } = this;
    if (!r && !n)
      return;
    const {
      samples: s
    } = t;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const o = rs();
    for (let a = 0; a < s.length; a++) {
      const l = s[a].type;
      if (l === Ft.emsg && !r || !n)
        continue;
      const u = Ml(s[a].data);
      if (u) {
        const c = s[a].pts;
        let d = c + s[a].duration;
        d > Ri && (d = Ri), d - c <= 0 && (d = c + Nv);
        for (let p = 0; p < u.length; p++) {
          const f = u[p];
          if (!Pl(f)) {
            this.updateId3CueEnds(c);
            const g = new o(c, d, "");
            g.value = f, l && (g.type = l), this.id3Track.addCue(g);
          }
        }
      }
    }
  }
  updateId3CueEnds(e) {
    var t;
    const r = (t = this.id3Track) == null ? void 0 : t.cues;
    if (r)
      for (let n = r.length; n--; ) {
        const s = r[n];
        s.startTime < e && s.endTime === Ri && (s.endTime = e);
      }
  }
  onBufferFlushing(e, {
    startOffset: t,
    endOffset: r,
    type: n
  }) {
    const {
      id3Track: s,
      hls: o
    } = this;
    if (!o)
      return;
    const {
      config: {
        enableEmsgMetadataCues: a,
        enableID3MetadataCues: l
      }
    } = o;
    if (s && (a || l)) {
      let u;
      n === "audio" ? u = (c) => c.type === Ft.audioId3 && l : n === "video" ? u = (c) => c.type === Ft.emsg && a : u = (c) => c.type === Ft.audioId3 && l || c.type === Ft.emsg && a, ts(s, t, r, u);
    }
  }
  onLevelUpdated(e, {
    details: t
  }) {
    if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues)
      return;
    const {
      dateRangeCuesAppended: r,
      id3Track: n
    } = this, {
      dateRanges: s
    } = t, o = Object.keys(s);
    if (n) {
      const c = Object.keys(r).filter((d) => !o.includes(d));
      for (let d = c.length; d--; ) {
        const h = c[d];
        Object.keys(r[h].cues).forEach((p) => {
          n.removeCue(r[h].cues[p]);
        }), delete r[h];
      }
    }
    const a = t.fragments[t.fragments.length - 1];
    if (o.length === 0 || !de(a == null ? void 0 : a.programDateTime))
      return;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const l = a.programDateTime / 1e3 - a.start, u = rs();
    for (let c = 0; c < o.length; c++) {
      const d = o[c], h = s[d], p = r[d], f = (p == null ? void 0 : p.cues) || {};
      let g = (p == null ? void 0 : p.durationKnown) || !1;
      const m = kn(h.startDate, l);
      let v = Ri;
      const E = h.endDate;
      if (E)
        v = kn(E, l), g = !0;
      else if (h.endOnNext && !g) {
        const _ = o.reduce((y, S) => {
          const b = s[S];
          return b.class === h.class && b.id !== S && b.startDate > h.startDate && y.push(b), y;
        }, []).sort((y, S) => y.startDate.getTime() - S.startDate.getTime())[0];
        _ && (v = kn(_.startDate, l), g = !0);
      }
      const A = Object.keys(h.attr);
      for (let _ = 0; _ < A.length; _++) {
        const y = A[_];
        if (!Jm(y))
          continue;
        let S = f[y];
        if (S)
          g && !p.durationKnown && (S.endTime = v);
        else {
          let b = h.attr[y];
          S = new u(m, v, ""), Ym(y) && (b = Uv(b)), S.value = {
            key: y,
            data: b
          }, S.type = Ft.dateRange, S.id = d, this.id3Track.addCue(S), f[y] = S;
        }
      }
      r[d] = {
        cues: f,
        dateRange: h,
        durationKnown: g
      };
    }
  }
}
class Gv {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners();
  }
  get latency() {
    return this._latency || 0;
  }
  get maxLatency() {
    const {
      config: e,
      levelDetails: t
    } = this;
    return e.liveMaxLatencyDuration !== void 0 ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0;
  }
  get targetLatency() {
    const {
      levelDetails: e
    } = this;
    if (e === null)
      return null;
    const {
      holdBack: t,
      partHoldBack: r,
      targetduration: n
    } = e, {
      liveSyncDuration: s,
      liveSyncDurationCount: o,
      lowLatencyMode: a
    } = this.config, l = this.hls.userConfig;
    let u = a && r || t;
    (l.liveSyncDuration || l.liveSyncDurationCount || u === 0) && (u = s !== void 0 ? s : o * n);
    const c = n, d = 1;
    return u + Math.min(this.stallCount * d, c);
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge(), t = this.targetLatency, r = this.levelDetails;
    if (e === null || t === null || r === null)
      return null;
    const n = r.edge, s = e - t - this.edgeStalled, o = n - r.totalduration, a = n - (this.config.lowLatencyMode && r.partTarget || r.targetduration);
    return Math.min(Math.max(o, s), a);
  }
  get drift() {
    const {
      levelDetails: e
    } = this;
    return e === null ? 1 : e.drift;
  }
  get edgeStalled() {
    const {
      levelDetails: e
    } = this;
    if (e === null)
      return 0;
    const t = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
    return Math.max(e.age - t, 0);
  }
  get forwardBufferLength() {
    const {
      media: e,
      levelDetails: t
    } = this;
    if (!e || !t)
      return 0;
    const r = e.buffered.length;
    return (r ? e.buffered.end(r - 1) : t.edge) - this.currentTime;
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null;
  }
  registerListeners() {
    this.hls.on(O.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(O.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(O.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(O.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(O.ERROR, this.onError, this);
  }
  unregisterListeners() {
    this.hls.off(O.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(O.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(O.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(O.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(O.ERROR, this.onError, this);
  }
  onMediaAttached(e, t) {
    this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler);
  }
  onMediaDetaching() {
    this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null);
  }
  onManifestLoading() {
    this.levelDetails = null, this._latency = null, this.stallCount = 0;
  }
  onLevelUpdated(e, {
    details: t
  }) {
    this.levelDetails = t, t.advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler);
  }
  onError(e, t) {
    var r;
    t.details === W.BUFFER_STALLED_ERROR && (this.stallCount++, (r = this.levelDetails) != null && r.live && K.warn("[playback-rate-controller]: Stall detected, adjusting target latency"));
  }
  timeupdate() {
    const {
      media: e,
      levelDetails: t
    } = this;
    if (!e || !t)
      return;
    this.currentTime = e.currentTime;
    const r = this.computeLatency();
    if (r === null)
      return;
    this._latency = r;
    const {
      lowLatencyMode: n,
      maxLiveSyncPlaybackRate: s
    } = this.config;
    if (!n || s === 1)
      return;
    const o = this.targetLatency;
    if (o === null)
      return;
    const a = r - o, l = Math.min(this.maxLatency, o + t.targetduration), u = a < l;
    if (t.live && u && a > 0.05 && this.forwardBufferLength > 1) {
      const c = Math.min(2, Math.max(1, s)), d = Math.round(2 / (1 + Math.exp(-0.75 * a - this.edgeStalled)) * 20) / 20;
      e.playbackRate = Math.min(c, Math.max(1, d));
    } else
      e.playbackRate !== 1 && e.playbackRate !== 0 && (e.playbackRate = 1);
  }
  estimateLiveEdge() {
    const {
      levelDetails: e
    } = this;
    return e === null ? null : e.edge + e.age;
  }
  computeLatency() {
    const e = this.estimateLiveEdge();
    return e === null ? null : e - this.currentTime;
  }
}
const is = ["NONE", "TYPE-0", "TYPE-1", null];
var ui = {
  No: "",
  Yes: "YES",
  v2: "v2"
};
function Vv(i, e) {
  const {
    canSkipUntil: t,
    canSkipDateRanges: r,
    endSN: n
  } = i, s = e !== void 0 ? e - n : 0;
  return t && s < t ? r ? ui.v2 : ui.Yes : ui.No;
}
class oa {
  constructor(e, t, r) {
    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = r;
  }
  addDirectives(e) {
    const t = new self.URL(e);
    return this.msn !== void 0 && t.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href;
  }
}
class Ei {
  constructor(e) {
    this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.unknownCodecs = e.unknownCodecs, this.codecSet = [e.videoCodec, e.audioCodec].filter((t) => t).join(",").replace(/\.[^.,]+/g, "");
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate);
  }
  get attrs() {
    return this._attrs[this._urlId];
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || ".";
  }
  get uri() {
    return this.url[this._urlId] || "";
  }
  get urlId() {
    return this._urlId;
  }
  set urlId(e) {
    const t = e % this.url.length;
    this._urlId !== t && (this.fragmentError = 0, this.loadError = 0, this.details = void 0, this._urlId = t);
  }
  get audioGroupId() {
    var e;
    return (e = this.audioGroupIds) == null ? void 0 : e[this.urlId];
  }
  get textGroupId() {
    var e;
    return (e = this.textGroupIds) == null ? void 0 : e[this.urlId];
  }
  addFallback(e) {
    this.url.push(e.url), this._attrs.push(e.attrs);
  }
}
function Dn(i, e) {
  const t = e.startPTS;
  if (de(t)) {
    let r = 0, n;
    e.sn > i.sn ? (r = t - i.start, n = i) : (r = i.start - t, n = e), n.duration !== r && (n.duration = r);
  } else
    e.sn > i.sn ? i.cc === e.cc && i.minEndPTS ? e.start = i.start + (i.minEndPTS - i.start) : e.start = i.start + i.duration : e.start = Math.max(i.start - e.duration, 0);
}
function Ql(i, e, t, r, n, s) {
  r - t <= 0 && (K.warn("Fragment should have a positive duration", e), r = t + e.duration, s = n + e.duration);
  let a = t, l = r;
  const u = e.startPTS, c = e.endPTS;
  if (de(u)) {
    const m = Math.abs(u - t);
    de(e.deltaPTS) ? e.deltaPTS = Math.max(m, e.deltaPTS) : e.deltaPTS = m, a = Math.max(t, u), t = Math.min(t, u), n = Math.min(n, e.startDTS), l = Math.min(r, c), r = Math.max(r, c), s = Math.max(s, e.endDTS);
  }
  const d = t - e.start;
  e.start !== 0 && (e.start = t), e.duration = r - e.start, e.startPTS = t, e.maxStartPTS = a, e.startDTS = n, e.endPTS = r, e.minEndPTS = l, e.endDTS = s;
  const h = e.sn;
  if (!i || h < i.startSN || h > i.endSN)
    return 0;
  let p;
  const f = h - i.startSN, g = i.fragments;
  for (g[f] = e, p = f; p > 0; p--)
    Dn(g[p], g[p - 1]);
  for (p = f; p < g.length - 1; p++)
    Dn(g[p], g[p + 1]);
  return i.fragmentHint && Dn(g[g.length - 1], i.fragmentHint), i.PTSKnown = i.alignedSliding = !0, d;
}
function Hv(i, e) {
  let t = null;
  const r = i.fragments;
  for (let l = r.length - 1; l >= 0; l--) {
    const u = r[l].initSegment;
    if (u) {
      t = u;
      break;
    }
  }
  i.fragmentHint && delete i.fragmentHint.endPTS;
  let n = 0, s;
  if (Qv(i, e, (l, u) => {
    l.relurl && (n = l.cc - u.cc), de(l.startPTS) && de(l.endPTS) && (u.start = u.startPTS = l.startPTS, u.startDTS = l.startDTS, u.maxStartPTS = l.maxStartPTS, u.endPTS = l.endPTS, u.endDTS = l.endDTS, u.minEndPTS = l.minEndPTS, u.duration = l.endPTS - l.startPTS, u.duration && (s = u), e.PTSKnown = e.alignedSliding = !0), u.elementaryStreams = l.elementaryStreams, u.loader = l.loader, u.stats = l.stats, u.urlId = l.urlId, l.initSegment && (u.initSegment = l.initSegment, t = l.initSegment);
  }), t && (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach((u) => {
    var c;
    (!u.initSegment || u.initSegment.relurl === ((c = t) == null ? void 0 : c.relurl)) && (u.initSegment = t);
  }), e.skippedSegments)
    if (e.deltaUpdateFailed = e.fragments.some((l) => !l), e.deltaUpdateFailed) {
      K.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let l = e.skippedSegments; l--; )
        e.fragments.shift();
      e.startSN = e.fragments[0].sn, e.startCC = e.fragments[0].cc;
    } else
      e.canSkipDateRanges && (e.dateRanges = jv(i.dateRanges, e.dateRanges, e.recentlyRemovedDateranges));
  const o = e.fragments;
  if (n) {
    K.warn("discontinuity sliding from playlist, take drift into account");
    for (let l = 0; l < o.length; l++)
      o[l].cc += n;
  }
  e.skippedSegments && (e.startCC = e.fragments[0].cc), Wv(i.partList, e.partList, (l, u) => {
    u.elementaryStreams = l.elementaryStreams, u.stats = l.stats;
  }), s ? Ql(e, s, s.startPTS, s.endPTS, s.startDTS, s.endDTS) : Jl(i, e), o.length && (e.totalduration = e.edge - o[0].start), e.driftStartTime = i.driftStartTime, e.driftStart = i.driftStart;
  const a = e.advancedDateTime;
  if (e.advanced && a) {
    const l = e.edge;
    e.driftStart || (e.driftStartTime = a, e.driftStart = l), e.driftEndTime = a, e.driftEnd = l;
  } else
    e.driftEndTime = i.driftEndTime, e.driftEnd = i.driftEnd, e.advancedDateTime = i.advancedDateTime;
}
function jv(i, e, t) {
  const r = et({}, i);
  return t && t.forEach((n) => {
    delete r[n];
  }), Object.keys(e).forEach((n) => {
    const s = new Cl(e[n].attr, r[n]);
    s.isValid ? r[n] = s : K.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(e[n].attr)}"`);
  }), r;
}
function Wv(i, e, t) {
  if (i && e) {
    let r = 0;
    for (let n = 0, s = i.length; n <= s; n++) {
      const o = i[n], a = e[n + r];
      o && a && o.index === a.index && o.fragment.sn === a.fragment.sn ? t(o, a) : r--;
    }
  }
}
function Qv(i, e, t) {
  const r = e.skippedSegments, n = Math.max(i.startSN, e.startSN) - e.startSN, s = (i.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(i.endSN, e.endSN)) - e.startSN, o = e.startSN - i.startSN, a = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, l = i.fragmentHint ? i.fragments.concat(i.fragmentHint) : i.fragments;
  for (let u = n; u <= s; u++) {
    const c = l[o + u];
    let d = a[u];
    r && !d && u < r && (d = e.fragments[u] = c), c && d && t(c, d);
  }
}
function Jl(i, e) {
  const t = e.startSN + e.skippedSegments - i.startSN, r = i.fragments;
  t < 0 || t >= r.length || ns(e, r[t].start);
}
function ns(i, e) {
  if (e) {
    const t = i.fragments;
    for (let r = i.skippedSegments; r < t.length; r++)
      t[r].start += e;
    i.fragmentHint && (i.fragmentHint.start += e);
  }
}
function Jv(i, e = 1 / 0) {
  let t = 1e3 * i.targetduration;
  if (i.updated) {
    const r = i.fragments, n = 4;
    if (r.length && t * n > e) {
      const s = r[r.length - 1].duration * 1e3;
      s < t && (t = s);
    }
  } else
    t /= 2;
  return Math.round(t);
}
function Yv(i, e, t) {
  if (!(i != null && i.details))
    return null;
  const r = i.details;
  let n = r.fragments[e - r.startSN];
  return n || (n = r.fragmentHint, n && n.sn === e) ? n : e < r.startSN && t && t.sn === e ? t : null;
}
function aa(i, e, t) {
  var r;
  return i != null && i.details ? Yl((r = i.details) == null ? void 0 : r.partList, e, t) : null;
}
function Yl(i, e, t) {
  if (i)
    for (let r = i.length; r--; ) {
      const n = i[r];
      if (n.index === t && n.fragment.sn === e)
        return n;
    }
  return null;
}
function qi(i) {
  switch (i.details) {
    case W.FRAG_LOAD_TIMEOUT:
    case W.KEY_LOAD_TIMEOUT:
    case W.LEVEL_LOAD_TIMEOUT:
    case W.MANIFEST_LOAD_TIMEOUT:
      return !0;
  }
  return !1;
}
function la(i, e) {
  const t = qi(e);
  return i.default[`${t ? "timeout" : "error"}Retry`];
}
function Ms(i, e) {
  const t = i.backoff === "linear" ? 1 : Math.pow(2, e);
  return Math.min(t * i.retryDelayMs, i.maxRetryDelayMs);
}
function ua(i) {
  return Tt(Tt({}, i), {
    errorRetry: null,
    timeoutRetry: null
  });
}
function Zi(i, e, t, r) {
  return !!i && e < i.maxNumRetry && (zv(r) || !!t);
}
function zv(i) {
  return i === 0 && navigator.onLine === !1 || !!i && (i < 400 || i > 499);
}
const zl = {
  /**
   * Searches for an item in an array which matches a certain condition.
   * This requires the condition to only match one item in the array,
   * and for the array to be ordered.
   *
   * @param list The array to search.
   * @param comparisonFn
   *      Called and provided a candidate item as the first argument.
   *      Should return:
   *          > -1 if the item should be located at a lower index than the provided item.
   *          > 1 if the item should be located at a higher index than the provided item.
   *          > 0 if the item is the item you're looking for.
   *
   * @returns the object if found, otherwise returns null
   */
  search: function(i, e) {
    let t = 0, r = i.length - 1, n = null, s = null;
    for (; t <= r; ) {
      n = (t + r) / 2 | 0, s = i[n];
      const o = e(s);
      if (o > 0)
        t = n + 1;
      else if (o < 0)
        r = n - 1;
      else
        return s;
    }
    return null;
  }
};
function qv(i, e, t) {
  if (e === null || !Array.isArray(i) || !i.length || !de(e))
    return null;
  const r = i[0].programDateTime;
  if (e < (r || 0))
    return null;
  const n = i[i.length - 1].endProgramDateTime;
  if (e >= (n || 0))
    return null;
  t = t || 0;
  for (let s = 0; s < i.length; ++s) {
    const o = i[s];
    if (Zv(e, t, o))
      return o;
  }
  return null;
}
function Ai(i, e, t = 0, r = 0) {
  let n = null;
  if (i ? n = e[i.sn - e[0].sn + 1] || null : t === 0 && e[0].start === 0 && (n = e[0]), n && ss(t, r, n) === 0)
    return n;
  const s = zl.search(e, ss.bind(null, t, r));
  return s && (s !== i || !n) ? s : n;
}
function ss(i = 0, e = 0, t) {
  if (t.start <= i && t.start + t.duration > i)
    return 0;
  const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0));
  return t.start + t.duration - r <= i ? 1 : t.start - r > i && t.start ? -1 : 0;
}
function Zv(i, e, t) {
  const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3;
  return (t.endProgramDateTime || 0) - r > i;
}
function Xv(i, e) {
  return zl.search(i, (t) => t.cc < e ? 1 : t.cc > e ? -1 : 0);
}
const $v = 3e5;
var Et = {
  DoNothing: 0,
  SendEndCallback: 1,
  SendAlternateToPenaltyBox: 2,
  RemoveAlternatePermanently: 3,
  InsertDiscontinuity: 4,
  RetryRequest: 5
}, Mt = {
  None: 0,
  MoveAllAlternatesMatchingHost: 1,
  MoveAllAlternatesMatchingHDCP: 2,
  SwitchToSDR: 4
};
class ey {
  constructor(e) {
    this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = K.log.bind(K, "[info]:"), this.warn = K.warn.bind(K, "[warning]:"), this.error = K.error.bind(K, "[error]:"), this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(O.ERROR, this.onError, this), e.on(O.MANIFEST_LOADING, this.onManifestLoading, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(O.ERROR, this.onError, this), e.off(O.ERROR, this.onErrorOut, this), e.off(O.MANIFEST_LOADING, this.onManifestLoading, this));
  }
  destroy() {
    this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {};
  }
  startLoad(e) {
    this.playlistError = 0;
  }
  stopLoad() {
  }
  getVariantLevelIndex(e) {
    return (e == null ? void 0 : e.type) === ge.MAIN ? e.level : this.hls.loadLevel;
  }
  onManifestLoading() {
    this.playlistError = 0, this.penalizedRenditions = {};
  }
  onError(e, t) {
    var r;
    if (t.fatal)
      return;
    const n = this.hls, s = t.context;
    switch (t.details) {
      case W.FRAG_LOAD_ERROR:
      case W.FRAG_LOAD_TIMEOUT:
      case W.KEY_LOAD_ERROR:
      case W.KEY_LOAD_TIMEOUT:
        t.errorAction = this.getFragRetryOrSwitchAction(t);
        return;
      case W.FRAG_GAP:
      case W.FRAG_PARSING_ERROR:
      case W.FRAG_DECRYPT_ERROR: {
        t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = Et.SendAlternateToPenaltyBox;
        return;
      }
      case W.LEVEL_EMPTY_ERROR:
      case W.LEVEL_PARSING_ERROR:
        {
          var o, a;
          const l = t.parent === ge.MAIN ? t.level : n.loadLevel;
          t.details === W.LEVEL_EMPTY_ERROR && ((o = t.context) != null && (a = o.levelDetails) != null && a.live) ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, l) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, l));
        }
        return;
      case W.LEVEL_LOAD_ERROR:
      case W.LEVEL_LOAD_TIMEOUT:
        typeof (s == null ? void 0 : s.level) == "number" && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, s.level));
        return;
      case W.AUDIO_TRACK_LOAD_ERROR:
      case W.AUDIO_TRACK_LOAD_TIMEOUT:
      case W.SUBTITLE_LOAD_ERROR:
      case W.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (s) {
          const l = n.levels[n.loadLevel];
          if (l && (s.type === Be.AUDIO_TRACK && s.groupId === l.audioGroupId || s.type === Be.SUBTITLE_TRACK && s.groupId === l.textGroupId)) {
            t.errorAction = this.getPlaylistRetryOrSwitchAction(t, n.loadLevel), t.errorAction.action = Et.SendAlternateToPenaltyBox, t.errorAction.flags = Mt.MoveAllAlternatesMatchingHost;
            return;
          }
        }
        return;
      case W.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        {
          const l = n.levels[n.loadLevel], u = l == null ? void 0 : l.attrs["HDCP-LEVEL"];
          u && (t.errorAction = {
            action: Et.SendAlternateToPenaltyBox,
            flags: Mt.MoveAllAlternatesMatchingHDCP,
            hdcpLevel: u
          });
        }
        return;
      case W.BUFFER_ADD_CODEC_ERROR:
      case W.REMUX_ALLOC_ERROR:
        t.errorAction = this.getLevelSwitchAction(t, (r = t.level) != null ? r : n.loadLevel);
        return;
      case W.INTERNAL_EXCEPTION:
      case W.BUFFER_APPENDING_ERROR:
      case W.BUFFER_APPEND_ERROR:
      case W.BUFFER_FULL_ERROR:
      case W.LEVEL_SWITCH_ERROR:
      case W.BUFFER_STALLED_ERROR:
      case W.BUFFER_SEEK_OVER_HOLE:
      case W.BUFFER_NUDGE_ON_STALL:
        t.errorAction = {
          action: Et.DoNothing,
          flags: Mt.None
        };
        return;
    }
    if (t.type === fe.KEY_SYSTEM_ERROR) {
      const l = this.getVariantLevelIndex(t.frag);
      t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, l);
      return;
    }
  }
  getPlaylistRetryOrSwitchAction(e, t) {
    var r;
    const n = this.hls, s = la(n.config.playlistLoadPolicy, e), o = this.playlistError++, a = (r = e.response) == null ? void 0 : r.code;
    if (Zi(s, o, qi(e), a))
      return {
        action: Et.RetryRequest,
        flags: Mt.None,
        retryConfig: s,
        retryCount: o
      };
    const u = this.getLevelSwitchAction(e, t);
    return s && (u.retryConfig = s, u.retryCount = o), u;
  }
  getFragRetryOrSwitchAction(e) {
    const t = this.hls, r = this.getVariantLevelIndex(e.frag), n = t.levels[r], {
      fragLoadPolicy: s,
      keyLoadPolicy: o
    } = t.config, a = la(e.details.startsWith("key") ? o : s, e), l = t.levels.reduce((d, h) => d + h.fragmentError, 0);
    if (n) {
      var u;
      e.details !== W.FRAG_GAP && n.fragmentError++;
      const d = (u = e.response) == null ? void 0 : u.code;
      if (Zi(a, l, qi(e), d))
        return {
          action: Et.RetryRequest,
          flags: Mt.None,
          retryConfig: a,
          retryCount: l
        };
    }
    const c = this.getLevelSwitchAction(e, r);
    return a && (c.retryConfig = a, c.retryCount = l), c;
  }
  getLevelSwitchAction(e, t) {
    const r = this.hls;
    t == null && (t = r.loadLevel);
    const n = this.hls.levels[t];
    if (n && (n.loadError++, r.autoLevelEnabled)) {
      var s, o;
      let a = -1;
      const l = r.levels, u = (s = e.frag) == null ? void 0 : s.type, {
        type: c,
        groupId: d
      } = (o = e.context) != null ? o : {};
      for (let h = l.length; h--; ) {
        const p = (h + r.loadLevel) % l.length;
        if (p !== r.loadLevel && l[p].loadError === 0) {
          const f = l[p];
          if (e.details === W.FRAG_GAP && e.frag) {
            const g = l[p].details;
            if (g) {
              const m = Ai(e.frag, g.fragments, e.frag.start);
              if (m != null && m.gap)
                continue;
            }
          } else {
            if (c === Be.AUDIO_TRACK && d === f.audioGroupId || c === Be.SUBTITLE_TRACK && d === f.textGroupId)
              continue;
            if (u === ge.AUDIO && n.audioGroupId === f.audioGroupId || u === ge.SUBTITLE && n.textGroupId === f.textGroupId)
              continue;
          }
          a = p;
          break;
        }
      }
      if (a > -1 && r.loadLevel !== a)
        return e.levelRetry = !0, {
          action: Et.SendAlternateToPenaltyBox,
          flags: Mt.None,
          nextAutoLevel: a
        };
    }
    return {
      action: Et.SendAlternateToPenaltyBox,
      flags: Mt.MoveAllAlternatesMatchingHost
    };
  }
  onErrorOut(e, t) {
    var r;
    switch ((r = t.errorAction) == null ? void 0 : r.action) {
      case Et.DoNothing:
        break;
      case Et.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(t), !t.errorAction.resolved && t.details !== W.FRAG_GAP && (t.fatal = !0);
        break;
    }
    if (t.fatal) {
      this.hls.stopLoad();
      return;
    }
  }
  sendAlternateToPenaltyBox(e) {
    const t = this.hls, r = e.errorAction;
    if (!r)
      return;
    const {
      flags: n,
      hdcpLevel: s,
      nextAutoLevel: o
    } = r;
    switch (n) {
      case Mt.None:
        this.switchLevel(e, o);
        break;
      case Mt.MoveAllAlternatesMatchingHost:
        r.resolved || (r.resolved = this.redundantFailover(e));
        break;
      case Mt.MoveAllAlternatesMatchingHDCP:
        s && (t.maxHdcpLevel = is[is.indexOf(s) - 1], r.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`);
        break;
    }
    r.resolved || this.switchLevel(e, o);
  }
  switchLevel(e, t) {
    t !== void 0 && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel);
  }
  redundantFailover(e) {
    const {
      hls: t,
      penalizedRenditions: r
    } = this, n = e.parent === ge.MAIN ? e.level : t.loadLevel, s = t.levels[n], o = s.url.length, a = e.frag ? e.frag.urlId : s.urlId;
    s.urlId === a && (!e.frag || s.details) && this.penalizeRendition(s, e);
    for (let l = 1; l < o; l++) {
      const u = (a + l) % o, c = r[u];
      if (!c || ty(c, e, r[a]))
        return this.warn(`Switching to Redundant Stream ${u + 1}/${o}: "${s.url[u]}" after ${e.details}`), this.playlistError = 0, t.levels.forEach((d) => {
          d.urlId = u;
        }), t.nextLoadLevel = n, !0;
    }
    return !1;
  }
  penalizeRendition(e, t) {
    const {
      penalizedRenditions: r
    } = this, n = r[e.urlId] || {
      lastErrorPerfMs: 0,
      errors: [],
      details: void 0
    };
    n.lastErrorPerfMs = performance.now(), n.errors.push(t), n.details = e.details, r[e.urlId] = n;
  }
}
function ty(i, e, t) {
  if (performance.now() - i.lastErrorPerfMs > $v)
    return !0;
  const r = i.details;
  if (e.details === W.FRAG_GAP && r && e.frag) {
    const n = e.frag.start, s = Ai(null, r.fragments, n);
    if (s && !s.gap)
      return !0;
  }
  if (t && i.errors.length < t.errors.length) {
    const n = i.errors[i.errors.length - 1];
    if (r && n.frag && e.frag && Math.abs(n.frag.start - e.frag.start) > r.targetduration * 3)
      return !0;
  }
  return !1;
}
class Bs {
  constructor(e, t) {
    this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = K.log.bind(K, `${t}:`), this.warn = K.warn.bind(K, `${t}:`), this.hls = e;
  }
  destroy() {
    this.clearTimer(), this.hls = this.log = this.warn = null;
  }
  clearTimer() {
    clearTimeout(this.timer), this.timer = -1;
  }
  startLoad() {
    this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist();
  }
  stopLoad() {
    this.canLoad = !1, this.clearTimer();
  }
  switchParams(e, t) {
    const r = t == null ? void 0 : t.renditionReports;
    if (r) {
      let n = -1;
      for (let s = 0; s < r.length; s++) {
        const o = r[s];
        let a;
        try {
          a = new self.URL(o.URI, t.url).href;
        } catch (l) {
          K.warn(`Could not construct new URL for Rendition Report: ${l}`), a = o.URI || "";
        }
        if (a === e) {
          n = s;
          break;
        } else
          a === e.substring(0, a.length) && (n = s);
      }
      if (n !== -1) {
        const s = r[n], o = parseInt(s["LAST-MSN"]) || (t == null ? void 0 : t.lastPartSn);
        let a = parseInt(s["LAST-PART"]) || (t == null ? void 0 : t.lastPartIndex);
        if (this.hls.config.lowLatencyMode) {
          const l = Math.min(t.age - t.partTarget, t.targetduration);
          a >= 0 && l > t.partTarget && (a += 1);
        }
        return new oa(o, a >= 0 ? a : void 0, ui.No);
      }
    }
  }
  loadPlaylist(e) {
    this.requestScheduled === -1 && (this.requestScheduled = self.performance.now());
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);
  }
  shouldReloadPlaylist(e) {
    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(e);
  }
  playlistLoaded(e, t, r) {
    const {
      details: n,
      stats: s
    } = t, o = self.performance.now(), a = s.loading.first ? Math.max(0, o - s.loading.first) : 0;
    if (n.advancedDateTime = Date.now() - a, n.live || r != null && r.live) {
      if (n.reloaded(r), r && this.log(`live playlist ${e} ${n.advanced ? "REFRESHED " + n.lastPartSn + "-" + n.lastPartIndex : "MISSED"}`), r && n.fragments.length > 0 && Hv(r, n), !this.canLoad || !n.live)
        return;
      let l, u, c;
      if (n.canBlockReload && n.endSN && n.advanced) {
        const m = this.hls.config.lowLatencyMode, v = n.lastPartSn, E = n.endSN, A = n.lastPartIndex, _ = A !== -1, y = v === E, S = m ? 0 : A;
        _ ? (u = y ? E + 1 : v, c = y ? S : A + 1) : u = E + 1;
        const b = n.age, w = b + n.ageHeader;
        let P = Math.min(w - n.partTarget, n.targetduration * 1.5);
        if (P > 0) {
          if (r && P > r.tuneInGoal)
            this.warn(`CDN Tune-in goal increased from: ${r.tuneInGoal} to: ${P} with playlist age: ${n.age}`), P = 0;
          else {
            const C = Math.floor(P / n.targetduration);
            if (u += C, c !== void 0) {
              const T = Math.round(P % n.targetduration / n.partTarget);
              c += T;
            }
            this.log(`CDN Tune-in age: ${n.ageHeader}s last advanced ${b.toFixed(2)}s goal: ${P} skip sn ${C} to part ${c}`);
          }
          n.tuneInGoal = P;
        }
        if (l = this.getDeliveryDirectives(n, t.deliveryDirectives, u, c), m || !y) {
          this.loadPlaylist(l);
          return;
        }
      } else
        n.canBlockReload && (l = this.getDeliveryDirectives(n, t.deliveryDirectives, u, c));
      const d = this.hls.mainForwardBufferInfo, h = d ? d.end - d.len : 0, p = (n.edge - h) * 1e3, f = Jv(n, p);
      n.updated && o > this.requestScheduled + f && (this.requestScheduled = s.loading.start), u !== void 0 && n.canBlockReload ? this.requestScheduled = s.loading.first + f - (n.partTarget * 1e3 || 1e3) : this.requestScheduled === -1 || this.requestScheduled + f < o ? this.requestScheduled = o : this.requestScheduled - o <= 0 && (this.requestScheduled += f);
      let g = this.requestScheduled - o;
      g = Math.max(0, g), this.log(`reload live playlist ${e} in ${Math.round(g)} ms`), this.timer = self.setTimeout(() => this.loadPlaylist(l), g);
    } else
      this.clearTimer();
  }
  getDeliveryDirectives(e, t, r, n) {
    let s = Vv(e, r);
    return t != null && t.skip && e.deltaUpdateFailed && (r = t.msn, n = t.part, s = ui.No), new oa(r, n, s);
  }
  checkRetry(e) {
    const t = e.details, r = qi(e), n = e.errorAction, {
      action: s,
      retryCount: o = 0,
      retryConfig: a
    } = n || {}, l = !!n && !!a && (s === Et.RetryRequest || !n.resolved && s === Et.SendAlternateToPenaltyBox);
    if (l) {
      var u;
      if (this.requestScheduled = -1, r && (u = e.context) != null && u.deliveryDirectives)
        this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist();
      else {
        const c = Ms(a, o);
        this.timer = self.setTimeout(() => this.loadPlaylist(), c), this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after "${t}" in ${c}ms`);
      }
      e.levelRetry = !0, n.resolved = !0;
    }
    return l;
  }
}
let On;
class ry extends Bs {
  constructor(e, t) {
    super(e, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(O.LEVEL_LOADED, this.onLevelLoaded, this), e.on(O.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(O.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(O.FRAG_LOADED, this.onFragLoaded, this), e.on(O.ERROR, this.onError, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(O.LEVEL_LOADED, this.onLevelLoaded, this), e.off(O.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(O.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(O.FRAG_LOADED, this.onFragLoaded, this), e.off(O.ERROR, this.onError, this);
  }
  destroy() {
    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy();
  }
  startLoad() {
    this._levels.forEach((t) => {
      t.loadError = 0, t.fragmentError = 0;
    }), super.startLoad();
  }
  resetLevels() {
    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [];
  }
  onManifestLoading(e, t) {
    this.resetLevels();
  }
  onManifestLoaded(e, t) {
    const r = [], n = {};
    let s;
    t.levels.forEach((o) => {
      var a;
      const l = o.attrs;
      ((a = o.audioCodec) == null ? void 0 : a.indexOf("mp4a.40.34")) !== -1 && (On || (On = /chrome|firefox/i.test(navigator.userAgent)), On && (o.audioCodec = void 0));
      const {
        AUDIO: u,
        CODECS: c,
        "FRAME-RATE": d,
        "PATHWAY-ID": h,
        RESOLUTION: p,
        SUBTITLES: f
      } = l, m = `${`${h || "."}-`}${o.bitrate}-${p}-${d}-${c}`;
      s = n[m], s ? s.addFallback(o) : (s = new Ei(o), n[m] = s, r.push(s)), Xi(s, "audio", u), Xi(s, "text", f);
    }), this.filterAndSortMediaOptions(r, t);
  }
  filterAndSortMediaOptions(e, t) {
    let r = [], n = [], s = !1, o = !1, a = !1, l = e.filter(({
      audioCodec: p,
      videoCodec: f,
      width: g,
      height: m,
      unknownCodecs: v
    }) => (s || (s = !!(g && m)), o || (o = !!f), a || (a = !!p), !(v != null && v.length) && (!p || Rn(p, "audio")) && (!f || Rn(f, "video"))));
    if ((s || o) && a && (l = l.filter(({
      videoCodec: p,
      width: f,
      height: g
    }) => !!p || !!(f && g))), l.length === 0) {
      Promise.resolve().then(() => {
        if (this.hls) {
          const p = new Error("no level with compatible codecs found in manifest");
          this.hls.trigger(O.ERROR, {
            type: fe.MEDIA_ERROR,
            details: W.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            url: t.url,
            error: p,
            reason: p.message
          });
        }
      });
      return;
    }
    t.audioTracks && (r = t.audioTracks.filter((p) => !p.audioCodec || Rn(p.audioCodec, "audio")), ca(r)), t.subtitles && (n = t.subtitles, ca(n));
    const u = l.slice(0);
    l.sort((p, f) => p.attrs["HDCP-LEVEL"] !== f.attrs["HDCP-LEVEL"] ? (p.attrs["HDCP-LEVEL"] || "") > (f.attrs["HDCP-LEVEL"] || "") ? 1 : -1 : p.bitrate !== f.bitrate ? p.bitrate - f.bitrate : p.attrs["FRAME-RATE"] !== f.attrs["FRAME-RATE"] ? p.attrs.decimalFloatingPoint("FRAME-RATE") - f.attrs.decimalFloatingPoint("FRAME-RATE") : p.attrs.SCORE !== f.attrs.SCORE ? p.attrs.decimalFloatingPoint("SCORE") - f.attrs.decimalFloatingPoint("SCORE") : s && p.height !== f.height ? p.height - f.height : 0);
    let c = u[0];
    if (this.steering && (l = this.steering.filterParsedLevels(l), l.length !== u.length)) {
      for (let p = 0; p < u.length; p++)
        if (u[p].pathwayId === l[0].pathwayId) {
          c = u[p];
          break;
        }
    }
    this._levels = l;
    for (let p = 0; p < l.length; p++)
      if (l[p] === c) {
        this._firstLevel = p, this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ${c.bitrate}`);
        break;
      }
    const d = a && !o, h = {
      levels: l,
      audioTracks: r,
      subtitleTracks: n,
      sessionData: t.sessionData,
      sessionKeys: t.sessionKeys,
      firstLevel: this._firstLevel,
      stats: t.stats,
      audio: a,
      video: o,
      altAudio: !d && r.some((p) => !!p.url)
    };
    this.hls.trigger(O.MANIFEST_PARSED, h), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition);
  }
  get levels() {
    return this._levels.length === 0 ? null : this._levels;
  }
  get level() {
    return this.currentLevelIndex;
  }
  set level(e) {
    const t = this._levels;
    if (t.length === 0)
      return;
    if (e < 0 || e >= t.length) {
      const c = new Error("invalid level idx"), d = e < 0;
      if (this.hls.trigger(O.ERROR, {
        type: fe.OTHER_ERROR,
        details: W.LEVEL_SWITCH_ERROR,
        level: e,
        fatal: d,
        error: c,
        reason: c.message
      }), d)
        return;
      e = Math.min(e, t.length - 1);
    }
    const r = this.currentLevelIndex, n = this.currentLevel, s = n ? n.attrs["PATHWAY-ID"] : void 0, o = t[e], a = o.attrs["PATHWAY-ID"];
    if (this.currentLevelIndex = e, this.currentLevel = o, r === e && o.details && n && s === a)
      return;
    this.log(`Switching to level ${e}${a ? " with Pathway " + a : ""} from level ${r}${s ? " with Pathway " + s : ""}`);
    const l = et({}, o, {
      level: e,
      maxBitrate: o.maxBitrate,
      attrs: o.attrs,
      uri: o.uri,
      urlId: o.urlId
    });
    delete l._attrs, delete l._urlId, this.hls.trigger(O.LEVEL_SWITCHING, l);
    const u = o.details;
    if (!u || u.live) {
      const c = this.switchParams(o.uri, n == null ? void 0 : n.details);
      this.loadPlaylist(c);
    }
  }
  get manualLevel() {
    return this.manualLevelIndex;
  }
  set manualLevel(e) {
    this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e);
  }
  get firstLevel() {
    return this._firstLevel;
  }
  set firstLevel(e) {
    this._firstLevel = e;
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const e = this.hls.config.startLevel;
      return e !== void 0 ? e : this._firstLevel;
    } else
      return this._startLevel;
  }
  set startLevel(e) {
    this._startLevel = e;
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === Be.LEVEL && t.context.level === this.level && this.checkRetry(t);
  }
  // reset errors on the successful load of a fragment
  onFragLoaded(e, {
    frag: t
  }) {
    if (t !== void 0 && t.type === ge.MAIN) {
      const r = this._levels[t.level];
      r !== void 0 && (r.loadError = 0);
    }
  }
  onLevelLoaded(e, t) {
    var r;
    const {
      level: n,
      details: s
    } = t, o = this._levels[n];
    if (!o) {
      var a;
      this.warn(`Invalid level index ${n}`), (a = t.deliveryDirectives) != null && a.skip && (s.deltaUpdateFailed = !0);
      return;
    }
    n === this.currentLevelIndex ? (o.fragmentError === 0 && (o.loadError = 0), this.playlistLoaded(n, t, o.details)) : (r = t.deliveryDirectives) != null && r.skip && (s.deltaUpdateFailed = !0);
  }
  onAudioTrackSwitched(e, t) {
    const r = this.currentLevel;
    if (!r)
      return;
    const n = this.hls.audioTracks[t.id].groupId;
    if (r.audioGroupIds && r.audioGroupId !== n) {
      let s = -1;
      for (let o = 0; o < r.audioGroupIds.length; o++)
        if (r.audioGroupIds[o] === n) {
          s = o;
          break;
        }
      s !== -1 && s !== r.urlId && (r.urlId = s, this.canLoad && this.startLoad());
    }
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const t = this.currentLevelIndex, r = this.currentLevel;
    if (r && this.shouldLoadPlaylist(r)) {
      const n = r.urlId;
      let s = r.uri;
      if (e)
        try {
          s = e.addDirectives(s);
        } catch (a) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${a}`);
        }
      const o = r.attrs["PATHWAY-ID"];
      this.log(`Loading level index ${t}${(e == null ? void 0 : e.msn) !== void 0 ? " at sn " + e.msn + " part " + e.part : ""} with${o ? " Pathway " + o : ""} URI ${n + 1}/${r.url.length} ${s}`), this.clearTimer(), this.hls.trigger(O.LEVEL_LOADING, {
        url: s,
        level: t,
        id: n,
        deliveryDirectives: e || null
      });
    }
  }
  get nextLoadLevel() {
    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
  }
  set nextLoadLevel(e) {
    this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e);
  }
  removeLevel(e, t) {
    const r = (s, o) => o !== t, n = this._levels.filter((s, o) => o !== e ? !0 : s.url.length > 1 && t !== void 0 ? (s.url = s.url.filter(r), s.audioGroupIds && (s.audioGroupIds = s.audioGroupIds.filter(r)), s.textGroupIds && (s.textGroupIds = s.textGroupIds.filter(r)), s.urlId = 0, !0) : (this.steering && this.steering.removeLevel(s), !1));
    this.hls.trigger(O.LEVELS_UPDATED, {
      levels: n
    });
  }
  onLevelsUpdated(e, {
    levels: t
  }) {
    t.forEach((r, n) => {
      const {
        details: s
      } = r;
      s != null && s.fragments && s.fragments.forEach((o) => {
        o.level = n;
      });
    }), this._levels = t;
  }
}
function Xi(i, e, t) {
  t && (e === "audio" ? (i.audioGroupIds || (i.audioGroupIds = []), i.audioGroupIds[i.url.length - 1] = t) : e === "text" && (i.textGroupIds || (i.textGroupIds = []), i.textGroupIds[i.url.length - 1] = t));
}
function ca(i) {
  const e = {};
  i.forEach((t) => {
    const r = t.groupId || "";
    t.id = e[r] = e[r] || 0, e[r]++;
  });
}
var at = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK"
};
class iy {
  constructor(e) {
    this.activePartLists = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.fragments = /* @__PURE__ */ Object.create(null), this.timeRanges = /* @__PURE__ */ Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.BUFFER_APPENDED, this.onBufferAppended, this), e.on(O.FRAG_BUFFERED, this.onFragBuffered, this), e.on(O.FRAG_LOADED, this.onFragLoaded, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.BUFFER_APPENDED, this.onBufferAppended, this), e.off(O.FRAG_BUFFERED, this.onFragBuffered, this), e.off(O.FRAG_LOADED, this.onFragLoaded, this);
  }
  destroy() {
    this._unregisterListeners(), this.fragments = // @ts-ignore
    this.activePartLists = // @ts-ignore
    this.endListFragments = this.timeRanges = null;
  }
  /**
   * Return a Fragment or Part with an appended range that matches the position and levelType
   * Otherwise, return null
   */
  getAppendedFrag(e, t) {
    const r = this.activePartLists[t];
    if (r)
      for (let n = r.length; n--; ) {
        const s = r[n];
        if (!s)
          break;
        const o = s.end;
        if (s.start <= e && o !== null && e <= o)
          return s;
      }
    return this.getBufferedFrag(e, t);
  }
  /**
   * Return a buffered Fragment that matches the position and levelType.
   * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
   * If not found any Fragment, return null
   */
  getBufferedFrag(e, t) {
    const {
      fragments: r
    } = this, n = Object.keys(r);
    for (let s = n.length; s--; ) {
      const o = r[n[s]];
      if ((o == null ? void 0 : o.body.type) === t && o.buffered) {
        const a = o.body;
        if (a.start <= e && e <= a.end)
          return a;
      }
    }
    return null;
  }
  /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   */
  detectEvictedFragments(e, t, r, n) {
    this.timeRanges && (this.timeRanges[e] = t);
    const s = (n == null ? void 0 : n.fragment.sn) || -1;
    Object.keys(this.fragments).forEach((o) => {
      const a = this.fragments[o];
      if (!a || s >= a.body.sn)
        return;
      if (!a.buffered && !a.loaded) {
        a.body.type === r && this.removeFragment(a.body);
        return;
      }
      const l = a.range[e];
      l && l.time.some((u) => {
        const c = !this.isTimeBuffered(u.startPTS, u.endPTS, t);
        return c && this.removeFragment(a.body), c;
      });
    });
  }
  /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   */
  detectPartialFragments(e) {
    const t = this.timeRanges, {
      frag: r,
      part: n
    } = e;
    if (!t || r.sn === "initSegment")
      return;
    const s = Dr(r), o = this.fragments[s];
    if (!o)
      return;
    const a = !r.relurl;
    Object.keys(t).forEach((l) => {
      const u = r.elementaryStreams[l];
      if (!u)
        return;
      const c = t[l], d = a || u.partial === !0;
      o.range[l] = this.getBufferedTimes(r, n, d, c);
    }), o.loaded = null, Object.keys(o.range).length ? (o.buffered = !0, o.body.endList && (this.endListFragments[o.body.type] = o), wi(o) || this.removeParts(r.sn - 1, r.type)) : this.removeFragment(o.body);
  }
  removeParts(e, t) {
    const r = this.activePartLists[t];
    r && (this.activePartLists[t] = r.filter((n) => n.fragment.sn >= e));
  }
  fragBuffered(e, t) {
    const r = Dr(e);
    let n = this.fragments[r];
    !n && t && (n = this.fragments[r] = {
      body: e,
      appendedPTS: null,
      loaded: null,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    }, e.gap && (this.hasGaps = !0)), n && (n.loaded = null, n.buffered = !0);
  }
  getBufferedTimes(e, t, r, n) {
    const s = {
      time: [],
      partial: r
    }, o = e.start, a = e.end, l = e.minEndPTS || a, u = e.maxStartPTS || o;
    for (let c = 0; c < n.length; c++) {
      const d = n.start(c) - this.bufferPadding, h = n.end(c) + this.bufferPadding;
      if (u >= d && l <= h) {
        s.time.push({
          startPTS: Math.max(o, n.start(c)),
          endPTS: Math.min(a, n.end(c))
        });
        break;
      } else if (o < h && a > d)
        s.partial = !0, s.time.push({
          startPTS: Math.max(o, n.start(c)),
          endPTS: Math.min(a, n.end(c))
        });
      else if (a <= d)
        break;
    }
    return s;
  }
  /**
   * Gets the partial fragment for a certain time
   */
  getPartialFragment(e) {
    let t = null, r, n, s, o = 0;
    const {
      bufferPadding: a,
      fragments: l
    } = this;
    return Object.keys(l).forEach((u) => {
      const c = l[u];
      c && wi(c) && (n = c.body.start - a, s = c.body.end + a, e >= n && e <= s && (r = Math.min(e - n, s - e), o <= r && (t = c.body, o = r)));
    }), t;
  }
  isEndListAppended(e) {
    const t = this.endListFragments[e];
    return t !== void 0 && (t.buffered || wi(t));
  }
  getState(e) {
    const t = Dr(e), r = this.fragments[t];
    return r ? r.buffered ? wi(r) ? at.PARTIAL : at.OK : at.APPENDING : at.NOT_LOADED;
  }
  isTimeBuffered(e, t, r) {
    let n, s;
    for (let o = 0; o < r.length; o++) {
      if (n = r.start(o) - this.bufferPadding, s = r.end(o) + this.bufferPadding, e >= n && t <= s)
        return !0;
      if (t <= n)
        return !1;
    }
    return !1;
  }
  onFragLoaded(e, t) {
    const {
      frag: r,
      part: n
    } = t;
    if (r.sn === "initSegment" || r.bitrateTest)
      return;
    const s = n ? null : t, o = Dr(r);
    this.fragments[o] = {
      body: r,
      appendedPTS: null,
      loaded: s,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    };
  }
  onBufferAppended(e, t) {
    const {
      frag: r,
      part: n,
      timeRanges: s
    } = t;
    if (r.sn === "initSegment")
      return;
    const o = r.type;
    if (n) {
      let a = this.activePartLists[o];
      a || (this.activePartLists[o] = a = []), a.push(n);
    }
    this.timeRanges = s, Object.keys(s).forEach((a) => {
      const l = s[a];
      this.detectEvictedFragments(a, l, o, n);
    });
  }
  onFragBuffered(e, t) {
    this.detectPartialFragments(t);
  }
  hasFragment(e) {
    const t = Dr(e);
    return !!this.fragments[t];
  }
  hasParts(e) {
    var t;
    return !!((t = this.activePartLists[e]) != null && t.length);
  }
  removeFragmentsInRange(e, t, r, n, s) {
    n && !this.hasGaps || Object.keys(this.fragments).forEach((o) => {
      const a = this.fragments[o];
      if (!a)
        return;
      const l = a.body;
      l.type !== r || n && !l.gap || l.start < t && l.end > e && (a.buffered || s) && this.removeFragment(l);
    });
  }
  removeFragment(e) {
    const t = Dr(e);
    e.stats.loaded = 0, e.clearElementaryStreamInfo();
    const r = this.activePartLists[e.type];
    if (r) {
      const n = e.sn;
      this.activePartLists[e.type] = r.filter((s) => s.fragment.sn !== n);
    }
    delete this.fragments[t], e.endList && delete this.endListFragments[e.type];
  }
  removeAllFragments() {
    this.fragments = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.activePartLists = /* @__PURE__ */ Object.create(null), this.hasGaps = !1;
  }
}
function wi(i) {
  var e, t, r;
  return i.buffered && (i.body.gap || ((e = i.range.video) == null ? void 0 : e.partial) || ((t = i.range.audio) == null ? void 0 : t.partial) || ((r = i.range.audiovideo) == null ? void 0 : r.partial));
}
function Dr(i) {
  return `${i.type}_${i.level}_${i.urlId}_${i.sn}`;
}
const da = Math.pow(2, 17);
class ny {
  constructor(e) {
    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e;
  }
  destroy() {
    this.loader && (this.loader.destroy(), this.loader = null);
  }
  abort() {
    this.loader && this.loader.abort();
  }
  load(e, t) {
    const r = e.url;
    if (!r)
      return Promise.reject(new er({
        type: fe.NETWORK_ERROR,
        details: W.FRAG_LOAD_ERROR,
        fatal: !1,
        frag: e,
        error: new Error(`Fragment does not have a ${r ? "part list" : "url"}`),
        networkDetails: null
      }));
    this.abort();
    const n = this.config, s = n.fLoader, o = n.loader;
    return new Promise((a, l) => {
      if (this.loader && this.loader.destroy(), e.gap) {
        l(fa(e));
        return;
      }
      const u = this.loader = e.loader = s ? new s(n) : new o(n), c = ha(e), d = ua(n.fragLoadPolicy.default), h = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: e.sn === "initSegment" ? 1 / 0 : da
      };
      e.stats = u.stats, u.load(c, h, {
        onSuccess: (p, f, g, m) => {
          this.resetLoader(e, u);
          let v = p.data;
          g.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(v.slice(0, 16)), v = v.slice(16)), a({
            frag: e,
            part: null,
            payload: v,
            networkDetails: m
          });
        },
        onError: (p, f, g, m) => {
          this.resetLoader(e, u), l(new er({
            type: fe.NETWORK_ERROR,
            details: W.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            response: Tt({
              url: r,
              data: void 0
            }, p),
            error: new Error(`HTTP Error ${p.code} ${p.text}`),
            networkDetails: g,
            stats: m
          }));
        },
        onAbort: (p, f, g) => {
          this.resetLoader(e, u), l(new er({
            type: fe.NETWORK_ERROR,
            details: W.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            error: new Error("Aborted"),
            networkDetails: g,
            stats: p
          }));
        },
        onTimeout: (p, f, g) => {
          this.resetLoader(e, u), l(new er({
            type: fe.NETWORK_ERROR,
            details: W.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            error: new Error(`Timeout after ${h.timeout}ms`),
            networkDetails: g,
            stats: p
          }));
        },
        onProgress: (p, f, g, m) => {
          t && t({
            frag: e,
            part: null,
            payload: g,
            networkDetails: m
          });
        }
      });
    });
  }
  loadPart(e, t, r) {
    this.abort();
    const n = this.config, s = n.fLoader, o = n.loader;
    return new Promise((a, l) => {
      if (this.loader && this.loader.destroy(), e.gap || t.gap) {
        l(fa(e, t));
        return;
      }
      const u = this.loader = e.loader = s ? new s(n) : new o(n), c = ha(e, t), d = ua(n.fragLoadPolicy.default), h = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: da
      };
      t.stats = u.stats, u.load(c, h, {
        onSuccess: (p, f, g, m) => {
          this.resetLoader(e, u), this.updateStatsFromPart(e, t);
          const v = {
            frag: e,
            part: t,
            payload: p.data,
            networkDetails: m
          };
          r(v), a(v);
        },
        onError: (p, f, g, m) => {
          this.resetLoader(e, u), l(new er({
            type: fe.NETWORK_ERROR,
            details: W.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            part: t,
            response: Tt({
              url: c.url,
              data: void 0
            }, p),
            error: new Error(`HTTP Error ${p.code} ${p.text}`),
            networkDetails: g,
            stats: m
          }));
        },
        onAbort: (p, f, g) => {
          e.stats.aborted = t.stats.aborted, this.resetLoader(e, u), l(new er({
            type: fe.NETWORK_ERROR,
            details: W.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            part: t,
            error: new Error("Aborted"),
            networkDetails: g,
            stats: p
          }));
        },
        onTimeout: (p, f, g) => {
          this.resetLoader(e, u), l(new er({
            type: fe.NETWORK_ERROR,
            details: W.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            part: t,
            error: new Error(`Timeout after ${h.timeout}ms`),
            networkDetails: g,
            stats: p
          }));
        }
      });
    });
  }
  updateStatsFromPart(e, t) {
    const r = e.stats, n = t.stats, s = n.total;
    if (r.loaded += n.loaded, s) {
      const l = Math.round(e.duration / t.duration), u = Math.min(Math.round(r.loaded / s), l), d = (l - u) * Math.round(r.loaded / u);
      r.total = r.loaded + d;
    } else
      r.total = Math.max(r.loaded, r.total);
    const o = r.loading, a = n.loading;
    o.start ? o.first += a.first - a.start : (o.start = a.start, o.first = a.first), o.end = a.end;
  }
  resetLoader(e, t) {
    e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy();
  }
}
function ha(i, e = null) {
  const t = e || i, r = {
    frag: i,
    part: e,
    responseType: "arraybuffer",
    url: t.url,
    headers: {},
    rangeStart: 0,
    rangeEnd: 0
  }, n = t.byteRangeStartOffset, s = t.byteRangeEndOffset;
  if (de(n) && de(s)) {
    var o;
    let a = n, l = s;
    if (i.sn === "initSegment" && ((o = i.decryptdata) == null ? void 0 : o.method) === "AES-128") {
      const u = s - n;
      u % 16 && (l = s + (16 - u % 16)), n !== 0 && (r.resetIV = !0, a = n - 16);
    }
    r.rangeStart = a, r.rangeEnd = l;
  }
  return r;
}
function fa(i, e) {
  const t = new Error(`GAP ${i.gap ? "tag" : "attribute"} found`), r = {
    type: fe.MEDIA_ERROR,
    details: W.FRAG_GAP,
    fatal: !1,
    frag: i,
    error: t,
    networkDetails: null
  };
  return e && (r.part = e), (e || i).stats.aborted = !0, new er(r);
}
class er extends Error {
  constructor(e) {
    super(e.error.message), this.data = void 0, this.data = e;
  }
}
class sy {
  constructor(e) {
    this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e;
  }
  abort(e) {
    for (const t in this.keyUriToKeyInfo) {
      const r = this.keyUriToKeyInfo[t].loader;
      if (r) {
        if (e && e !== r.context.frag.type)
          return;
        r.abort();
      }
    }
  }
  detach() {
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e];
      (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e];
    }
  }
  destroy() {
    this.detach();
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e].loader;
      t && t.destroy();
    }
    this.keyUriToKeyInfo = {};
  }
  createKeyLoadError(e, t = W.KEY_LOAD_ERROR, r, n, s) {
    return new er({
      type: fe.NETWORK_ERROR,
      details: t,
      fatal: !1,
      frag: e,
      response: s,
      error: r,
      networkDetails: n
    });
  }
  loadClear(e, t) {
    if (this.emeController && this.config.emeEnabled) {
      const {
        sn: r,
        cc: n
      } = e;
      for (let s = 0; s < t.length; s++) {
        const o = t[s];
        if (n <= o.cc && (r === "initSegment" || o.sn === "initSegment" || r < o.sn)) {
          this.emeController.selectKeySystemFormat(o).then((a) => {
            o.setKeyFormat(a);
          });
          break;
        }
      }
    }
  }
  load(e) {
    return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then((t) => this.loadInternal(e, t)) : this.loadInternal(e);
  }
  loadInternal(e, t) {
    var r, n;
    t && e.setKeyFormat(t);
    const s = e.decryptdata;
    if (!s) {
      const u = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading");
      return Promise.reject(this.createKeyLoadError(e, W.KEY_LOAD_ERROR, u));
    }
    const o = s.uri;
    if (!o)
      return Promise.reject(this.createKeyLoadError(e, W.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${o}"`)));
    let a = this.keyUriToKeyInfo[o];
    if ((r = a) != null && r.decryptdata.key)
      return s.key = a.decryptdata.key, Promise.resolve({
        frag: e,
        keyInfo: a
      });
    if ((n = a) != null && n.keyLoadPromise) {
      var l;
      switch ((l = a.mediaKeySessionContext) == null ? void 0 : l.keyStatus) {
        case void 0:
        case "status-pending":
        case "usable":
        case "usable-in-future":
          return a.keyLoadPromise.then((u) => (s.key = u.keyInfo.decryptdata.key, {
            frag: e,
            keyInfo: a
          }));
      }
    }
    switch (a = this.keyUriToKeyInfo[o] = {
      decryptdata: s,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    }, s.method) {
      case "ISO-23001-7":
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        return s.keyFormat === "identity" ? this.loadKeyHTTP(a, e) : this.loadKeyEME(a, e);
      case "AES-128":
        return this.loadKeyHTTP(a, e);
      default:
        return Promise.reject(this.createKeyLoadError(e, W.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${s.method}"`)));
    }
  }
  loadKeyEME(e, t) {
    const r = {
      frag: t,
      keyInfo: e
    };
    if (this.emeController && this.config.emeEnabled) {
      const n = this.emeController.loadKey(r);
      if (n)
        return (e.keyLoadPromise = n.then((s) => (e.mediaKeySessionContext = s, r))).catch((s) => {
          throw e.keyLoadPromise = null, s;
        });
    }
    return Promise.resolve(r);
  }
  loadKeyHTTP(e, t) {
    const r = this.config, n = r.loader, s = new n(r);
    return t.keyLoader = e.loader = s, e.keyLoadPromise = new Promise((o, a) => {
      const l = {
        keyInfo: e,
        frag: t,
        responseType: "arraybuffer",
        url: e.decryptdata.uri
      }, u = r.keyLoadPolicy.default, c = {
        loadPolicy: u,
        timeout: u.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (h, p, f, g) => {
          const {
            frag: m,
            keyInfo: v,
            url: E
          } = f;
          if (!m.decryptdata || v !== this.keyUriToKeyInfo[E])
            return a(this.createKeyLoadError(m, W.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), g));
          v.decryptdata.key = m.decryptdata.key = new Uint8Array(h.data), m.keyLoader = null, v.loader = null, o({
            frag: m,
            keyInfo: v
          });
        },
        onError: (h, p, f, g) => {
          this.resetLoader(p), a(this.createKeyLoadError(t, W.KEY_LOAD_ERROR, new Error(`HTTP Error ${h.code} loading key ${h.text}`), f, Tt({
            url: l.url,
            data: void 0
          }, h)));
        },
        onTimeout: (h, p, f) => {
          this.resetLoader(p), a(this.createKeyLoadError(t, W.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), f));
        },
        onAbort: (h, p, f) => {
          this.resetLoader(p), a(this.createKeyLoadError(t, W.INTERNAL_ABORTED, new Error("key loading aborted"), f));
        }
      };
      s.load(l, c, d);
    });
  }
  resetLoader(e) {
    const {
      frag: t,
      keyInfo: r,
      url: n
    } = e, s = r.loader;
    t.keyLoader === s && (t.keyLoader = null, r.loader = null), delete this.keyUriToKeyInfo[n], s && s.destroy();
  }
}
class oy {
  constructor() {
    this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);
  }
  destroy() {
    this.onHandlerDestroying(), this.onHandlerDestroyed();
  }
  onHandlerDestroying() {
    this.clearNextTick(), this.clearInterval();
  }
  onHandlerDestroyed() {
  }
  hasInterval() {
    return !!this._tickInterval;
  }
  hasNextTick() {
    return !!this._tickTimer;
  }
  /**
   * @param millis - Interval time (ms)
   * @eturns True when interval has been scheduled, false when already scheduled (no effect)
   */
  setInterval(e) {
    return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0);
  }
  /**
   * @returns True when interval was cleared, false when none was set (no effect)
   */
  clearInterval() {
    return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1;
  }
  /**
   * @returns True when timeout was cleared, false when none was set (no effect)
   */
  clearNextTick() {
    return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1;
  }
  /**
   * Will call the subclass doTick implementation in this main loop tick
   * or in the next one (via setTimeout(,0)) in case it has already been called
   * in this tick (in case this is a re-entrant call).
   */
  tick() {
    this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);
  }
  tickImmediate() {
    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);
  }
  /**
   * For subclass to implement task logic
   * @abstract
   */
  doTick() {
  }
}
const ay = {
  length: 0,
  start: () => 0,
  end: () => 0
};
class je {
  /**
   * Return true if `media`'s buffered include `position`
   */
  static isBuffered(e, t) {
    try {
      if (e) {
        const r = je.getBuffered(e);
        for (let n = 0; n < r.length; n++)
          if (t >= r.start(n) && t <= r.end(n))
            return !0;
      }
    } catch {
    }
    return !1;
  }
  static bufferInfo(e, t, r) {
    try {
      if (e) {
        const n = je.getBuffered(e), s = [];
        let o;
        for (o = 0; o < n.length; o++)
          s.push({
            start: n.start(o),
            end: n.end(o)
          });
        return this.bufferedInfo(s, t, r);
      }
    } catch {
    }
    return {
      len: 0,
      start: t,
      end: t,
      nextStart: void 0
    };
  }
  static bufferedInfo(e, t, r) {
    t = Math.max(0, t), e.sort(function(u, c) {
      const d = u.start - c.start;
      return d || c.end - u.end;
    });
    let n = [];
    if (r)
      for (let u = 0; u < e.length; u++) {
        const c = n.length;
        if (c) {
          const d = n[c - 1].end;
          e[u].start - d < r ? e[u].end > d && (n[c - 1].end = e[u].end) : n.push(e[u]);
        } else
          n.push(e[u]);
      }
    else
      n = e;
    let s = 0, o, a = t, l = t;
    for (let u = 0; u < n.length; u++) {
      const c = n[u].start, d = n[u].end;
      if (t + r >= c && t < d)
        a = c, l = d, s = l - t;
      else if (t + r < c) {
        o = c;
        break;
      }
    }
    return {
      len: s,
      start: a || 0,
      end: l || 0,
      nextStart: o
    };
  }
  /**
   * Safe method to get buffered property.
   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
   */
  static getBuffered(e) {
    try {
      return e.buffered;
    } catch (t) {
      return K.log("failed to get media.buffered", t), ay;
    }
  }
}
class Fs {
  constructor(e, t, r, n = 0, s = -1, o = !1) {
    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = ki(), this.buffering = {
      audio: ki(),
      video: ki(),
      audiovideo: ki()
    }, this.level = e, this.sn = t, this.id = r, this.size = n, this.part = s, this.partial = o;
  }
}
function ki() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  };
}
function ql(i, e) {
  let t = null;
  for (let r = 0, n = i.length; r < n; r++) {
    const s = i[r];
    if (s && s.cc === e) {
      t = s;
      break;
    }
  }
  return t;
}
function ly(i, e, t) {
  return !!(e.details && (t.endCC > t.startCC || i && i.cc < t.startCC));
}
function uy(i, e, t = 0) {
  const r = i.fragments, n = e.fragments;
  if (!n.length || !r.length) {
    K.log("No fragments to align");
    return;
  }
  const s = ql(r, n[0].cc);
  if (!s || s && !s.startPTS) {
    K.log("No frag in previous level to align on");
    return;
  }
  return s;
}
function pa(i, e) {
  if (i) {
    const t = i.start + e;
    i.start = i.startPTS = t, i.endPTS = t + i.duration;
  }
}
function Ns(i, e) {
  const t = e.fragments;
  for (let r = 0, n = t.length; r < n; r++)
    pa(t[r], i);
  e.fragmentHint && pa(e.fragmentHint, i), e.alignedSliding = !0;
}
function cy(i, e, t) {
  e && (dy(i, t, e), !t.alignedSliding && e.details && hy(t, e.details), !t.alignedSliding && e.details && !t.skippedSegments && Jl(e.details, t));
}
function dy(i, e, t) {
  if (ly(i, t, e)) {
    const r = uy(t.details, e);
    r && de(r.start) && (K.log(`Adjusting PTS using last level due to CC increase within current level ${e.url}`), Ns(r.start, e));
  }
}
function hy(i, e) {
  if (!e.fragments.length || !i.hasProgramDateTime || !e.hasProgramDateTime)
    return;
  const t = e.fragments[0].programDateTime, r = i.fragments[0].programDateTime, n = (r - t) / 1e3 + e.fragments[0].start;
  n && de(n) && (K.log(`Adjusting PTS using programDateTime delta ${r - t}ms, sliding:${n.toFixed(3)} ${i.url} `), Ns(n, i));
}
function Zl(i, e) {
  if (!i.hasProgramDateTime || !e.hasProgramDateTime)
    return;
  const t = i.fragments, r = e.fragments;
  if (!t.length || !r.length)
    return;
  const n = Math.round(r.length / 2) - 1, s = r[n], o = ql(t, s.cc) || t[Math.round(t.length / 2) - 1], a = s.programDateTime, l = o.programDateTime;
  if (a === null || l === null)
    return;
  const u = (l - a) / 1e3 - (o.start - s.start);
  Ns(u, i);
}
class fy {
  constructor(e, t) {
    this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t;
  }
  decrypt(e, t) {
    return this.subtle.decrypt({
      name: "AES-CBC",
      iv: this.aesIV
    }, t, e);
  }
}
class py {
  constructor(e, t) {
    this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t;
  }
  expandKey() {
    return this.subtle.importKey("raw", this.key, {
      name: "AES-CBC"
    }, !1, ["encrypt", "decrypt"]);
  }
}
function gy(i) {
  const e = i.byteLength, t = e && new DataView(i.buffer).getUint8(e - 1);
  return t ? Tr(i, 0, e - t) : i;
}
class my {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();
  }
  // Using view.getUint32() also swaps the byte order.
  uint8ArrayToUint32Array_(e) {
    const t = new DataView(e), r = new Uint32Array(4);
    for (let n = 0; n < 4; n++)
      r[n] = t.getUint32(n * 4);
    return r;
  }
  initTable() {
    const e = this.sBox, t = this.invSBox, r = this.subMix, n = r[0], s = r[1], o = r[2], a = r[3], l = this.invSubMix, u = l[0], c = l[1], d = l[2], h = l[3], p = new Uint32Array(256);
    let f = 0, g = 0, m = 0;
    for (m = 0; m < 256; m++)
      m < 128 ? p[m] = m << 1 : p[m] = m << 1 ^ 283;
    for (m = 0; m < 256; m++) {
      let v = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
      v = v >>> 8 ^ v & 255 ^ 99, e[f] = v, t[v] = f;
      const E = p[f], A = p[E], _ = p[A];
      let y = p[v] * 257 ^ v * 16843008;
      n[f] = y << 24 | y >>> 8, s[f] = y << 16 | y >>> 16, o[f] = y << 8 | y >>> 24, a[f] = y, y = _ * 16843009 ^ A * 65537 ^ E * 257 ^ f * 16843008, u[v] = y << 24 | y >>> 8, c[v] = y << 16 | y >>> 16, d[v] = y << 8 | y >>> 24, h[v] = y, f ? (f = E ^ p[p[p[_ ^ E]]], g ^= p[p[g]]) : f = g = 1;
    }
  }
  expandKey(e) {
    const t = this.uint8ArrayToUint32Array_(e);
    let r = !0, n = 0;
    for (; n < t.length && r; )
      r = t[n] === this.key[n], n++;
    if (r)
      return;
    this.key = t;
    const s = this.keySize = t.length;
    if (s !== 4 && s !== 6 && s !== 8)
      throw new Error("Invalid aes key size=" + s);
    const o = this.ksRows = (s + 6 + 1) * 4;
    let a, l;
    const u = this.keySchedule = new Uint32Array(o), c = this.invKeySchedule = new Uint32Array(o), d = this.sBox, h = this.rcon, p = this.invSubMix, f = p[0], g = p[1], m = p[2], v = p[3];
    let E, A;
    for (a = 0; a < o; a++) {
      if (a < s) {
        E = u[a] = t[a];
        continue;
      }
      A = E, a % s === 0 ? (A = A << 8 | A >>> 24, A = d[A >>> 24] << 24 | d[A >>> 16 & 255] << 16 | d[A >>> 8 & 255] << 8 | d[A & 255], A ^= h[a / s | 0] << 24) : s > 6 && a % s === 4 && (A = d[A >>> 24] << 24 | d[A >>> 16 & 255] << 16 | d[A >>> 8 & 255] << 8 | d[A & 255]), u[a] = E = (u[a - s] ^ A) >>> 0;
    }
    for (l = 0; l < o; l++)
      a = o - l, l & 3 ? A = u[a] : A = u[a - 4], l < 4 || a <= 4 ? c[l] = A : c[l] = f[d[A >>> 24]] ^ g[d[A >>> 16 & 255]] ^ m[d[A >>> 8 & 255]] ^ v[d[A & 255]], c[l] = c[l] >>> 0;
  }
  // Adding this as a method greatly improves performance.
  networkToHostOrderSwap(e) {
    return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24;
  }
  decrypt(e, t, r) {
    const n = this.keySize + 6, s = this.invKeySchedule, o = this.invSBox, a = this.invSubMix, l = a[0], u = a[1], c = a[2], d = a[3], h = this.uint8ArrayToUint32Array_(r);
    let p = h[0], f = h[1], g = h[2], m = h[3];
    const v = new Int32Array(e), E = new Int32Array(v.length);
    let A, _, y, S, b, w, P, C, T, x, L, I, R, B;
    const D = this.networkToHostOrderSwap;
    for (; t < v.length; ) {
      for (T = D(v[t]), x = D(v[t + 1]), L = D(v[t + 2]), I = D(v[t + 3]), b = T ^ s[0], w = I ^ s[1], P = L ^ s[2], C = x ^ s[3], R = 4, B = 1; B < n; B++)
        A = l[b >>> 24] ^ u[w >> 16 & 255] ^ c[P >> 8 & 255] ^ d[C & 255] ^ s[R], _ = l[w >>> 24] ^ u[P >> 16 & 255] ^ c[C >> 8 & 255] ^ d[b & 255] ^ s[R + 1], y = l[P >>> 24] ^ u[C >> 16 & 255] ^ c[b >> 8 & 255] ^ d[w & 255] ^ s[R + 2], S = l[C >>> 24] ^ u[b >> 16 & 255] ^ c[w >> 8 & 255] ^ d[P & 255] ^ s[R + 3], b = A, w = _, P = y, C = S, R = R + 4;
      A = o[b >>> 24] << 24 ^ o[w >> 16 & 255] << 16 ^ o[P >> 8 & 255] << 8 ^ o[C & 255] ^ s[R], _ = o[w >>> 24] << 24 ^ o[P >> 16 & 255] << 16 ^ o[C >> 8 & 255] << 8 ^ o[b & 255] ^ s[R + 1], y = o[P >>> 24] << 24 ^ o[C >> 16 & 255] << 16 ^ o[b >> 8 & 255] << 8 ^ o[w & 255] ^ s[R + 2], S = o[C >>> 24] << 24 ^ o[b >> 16 & 255] << 16 ^ o[w >> 8 & 255] << 8 ^ o[P & 255] ^ s[R + 3], E[t] = D(A ^ p), E[t + 1] = D(S ^ f), E[t + 2] = D(y ^ g), E[t + 3] = D(_ ^ m), p = T, f = x, g = L, m = I, t = t + 4;
    }
    return E.buffer;
  }
}
const vy = 16;
class Us {
  constructor(e, {
    removePKCS7Padding: t = !0
  } = {}) {
    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t, t)
      try {
        const r = self.crypto;
        r && (this.subtle = r.subtle || r.webkitSubtle);
      } catch {
      }
    this.subtle === null && (this.useSoftware = !0);
  }
  destroy() {
    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null;
  }
  isSync() {
    return this.useSoftware;
  }
  flush() {
    const {
      currentResult: e,
      remainderData: t
    } = this;
    if (!e || t)
      return this.reset(), null;
    const r = new Uint8Array(e);
    return this.reset(), this.removePKCS7Padding ? gy(r) : r;
  }
  reset() {
    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);
  }
  decrypt(e, t, r) {
    return this.useSoftware ? new Promise((n, s) => {
      this.softwareDecrypt(new Uint8Array(e), t, r);
      const o = this.flush();
      o ? n(o.buffer) : s(new Error("[softwareDecrypt] Failed to decrypt data"));
    }) : this.webCryptoDecrypt(new Uint8Array(e), t, r);
  }
  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
  // data is handled in the flush() call
  softwareDecrypt(e, t, r) {
    const {
      currentIV: n,
      currentResult: s,
      remainderData: o
    } = this;
    this.logOnce("JS AES decrypt"), o && (e = Lr(o, e), this.remainderData = null);
    const a = this.getValidChunk(e);
    if (!a.length)
      return null;
    n && (r = n);
    let l = this.softwareDecrypter;
    l || (l = this.softwareDecrypter = new my()), l.expandKey(t);
    const u = s;
    return this.currentResult = l.decrypt(a.buffer, 0, r), this.currentIV = Tr(a, -16).buffer, u || null;
  }
  webCryptoDecrypt(e, t, r) {
    const n = this.subtle;
    return (this.key !== t || !this.fastAesKey) && (this.key = t, this.fastAesKey = new py(n, t)), this.fastAesKey.expandKey().then((s) => n ? (this.logOnce("WebCrypto AES decrypt"), new fy(n, new Uint8Array(r)).decrypt(e.buffer, s)) : Promise.reject(new Error("web crypto not initialized"))).catch((s) => (K.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${s.name}: ${s.message}`), this.onWebCryptoError(e, t, r)));
  }
  onWebCryptoError(e, t, r) {
    this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, r);
    const n = this.flush();
    if (n)
      return n.buffer;
    throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data");
  }
  getValidChunk(e) {
    let t = e;
    const r = e.length - e.length % vy;
    return r !== e.length && (t = Tr(e, 0, r), this.remainderData = Tr(e, r)), t;
  }
  logOnce(e) {
    this.logEnabled && (K.log(`[decrypter]: ${e}`), this.logEnabled = !1);
  }
}
const yy = {
  toString: function(i) {
    let e = "";
    const t = i.length;
    for (let r = 0; r < t; r++)
      e += `[${i.start(r).toFixed(3)}-${i.end(r).toFixed(3)}]`;
    return e;
  }
}, z = {
  STOPPED: "STOPPED",
  IDLE: "IDLE",
  KEY_LOADING: "KEY_LOADING",
  FRAG_LOADING: "FRAG_LOADING",
  FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
  WAITING_TRACK: "WAITING_TRACK",
  PARSING: "PARSING",
  PARSED: "PARSED",
  ENDED: "ENDED",
  ERROR: "ERROR",
  WAITING_INIT_PTS: "WAITING_INIT_PTS",
  WAITING_LEVEL: "WAITING_LEVEL"
};
class Ks extends oy {
  constructor(e, t, r, n, s) {
    super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = z.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = s, this.logPrefix = n, this.log = K.log.bind(K, `${n}:`), this.warn = K.warn.bind(K, `${n}:`), this.hls = e, this.fragmentLoader = new ny(e.config), this.keyLoader = r, this.fragmentTracker = t, this.config = e.config, this.decrypter = new Us(e.config), e.on(O.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  doTick() {
    this.onTickEnd();
  }
  onTickEnd() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLoad(e) {
  }
  stopLoad() {
    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
    const e = this.fragCurrent;
    e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = z.STOPPED;
  }
  _streamEnded(e, t) {
    if (t.live || e.nextStart || !e.end || !this.media)
      return !1;
    const r = t.partList;
    if (r != null && r.length) {
      const s = r[r.length - 1];
      return je.isBuffered(this.media, s.start + s.duration / 2);
    }
    const n = t.fragments[t.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(n);
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null) {
      var e;
      return (e = this.levels[this.levelLastLoaded]) == null ? void 0 : e.details;
    }
  }
  onMediaAttached(e, t) {
    const r = this.media = this.mediaBuffer = t.media;
    this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), r.addEventListener("seeking", this.onvseeking), r.addEventListener("ended", this.onvended);
    const n = this.config;
    this.levels && n.autoStartLoad && this.state === z.STOPPED && this.startLoad(n.startPosition);
  }
  onMediaDetaching() {
    const e = this.media;
    e != null && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();
  }
  onMediaSeeking() {
    const {
      config: e,
      fragCurrent: t,
      media: r,
      mediaBuffer: n,
      state: s
    } = this, o = r ? r.currentTime : 0, a = je.bufferInfo(n || r, o, e.maxBufferHole);
    if (this.log(`media seeking to ${de(o) ? o.toFixed(3) : o}, state: ${s}`), this.state === z.ENDED)
      this.resetLoadingState();
    else if (t) {
      const l = e.maxFragLookUpTolerance, u = t.start - l, c = t.start + t.duration + l;
      if (!a.len || c < a.start || u > a.end) {
        const d = o > c;
        (o < u || d) && (d && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null);
      }
    }
    r && (this.fragmentTracker.removeFragmentsInRange(o, 1 / 0, this.playlistType, !0), this.lastCurrentTime = o), !this.loadedmetadata && !a.len && (this.nextLoadPosition = this.startPosition = o), this.tickImmediate();
  }
  onMediaEnded() {
    this.startPosition = this.lastCurrentTime = 0;
  }
  onManifestLoaded(e, t) {
    this.startTimeOffset = t.startTimeOffset, this.initPTS = [];
  }
  onHandlerDestroying() {
    this.stopLoad(), super.onHandlerDestroying();
  }
  onHandlerDestroyed() {
    this.state = z.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed();
  }
  loadFragment(e, t, r) {
    this._loadFragForPlayback(e, t, r);
  }
  _loadFragForPlayback(e, t, r) {
    const n = (s) => {
      if (this.fragContextChanged(e)) {
        this.warn(`Fragment ${e.sn}${s.part ? " p: " + s.part.index : ""} of level ${e.level} was dropped during download.`), this.fragmentTracker.removeFragment(e);
        return;
      }
      e.stats.chunkCount++, this._handleFragmentLoadProgress(s);
    };
    this._doFragLoad(e, t, r, n).then((s) => {
      if (!s)
        return;
      const o = this.state;
      if (this.fragContextChanged(e)) {
        (o === z.FRAG_LOADING || !this.fragCurrent && o === z.PARSING) && (this.fragmentTracker.removeFragment(e), this.state = z.IDLE);
        return;
      }
      "payload" in s && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`), this.hls.trigger(O.FRAG_LOADED, s)), this._handleFragmentLoadComplete(s);
    }).catch((s) => {
      this.state === z.STOPPED || this.state === z.ERROR || (this.warn(s), this.resetFragmentLoading(e));
    });
  }
  clearTrackerIfNeeded(e) {
    var t;
    const {
      fragmentTracker: r
    } = this;
    if (r.getState(e) === at.APPENDING) {
      const s = e.type, o = this.getFwdBufferInfo(this.mediaBuffer, s), a = Math.max(e.duration, o ? o.len : this.config.maxBufferLength);
      this.reduceMaxBufferLength(a) && r.removeFragment(e);
    } else
      ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? r.removeAllFragments() : r.hasParts(e.type) && (r.detectPartialFragments({
        frag: e,
        part: null,
        stats: e.stats,
        id: e.type
      }), r.getState(e) === at.PARTIAL && r.removeFragment(e));
  }
  flushMainBuffer(e, t, r = null) {
    if (!(e - t))
      return;
    const n = {
      startOffset: e,
      endOffset: t,
      type: r
    };
    this.hls.trigger(O.BUFFER_FLUSHING, n);
  }
  _loadInitSegment(e, t) {
    this._doFragLoad(e, t).then((r) => {
      if (!r || this.fragContextChanged(e) || !this.levels)
        throw new Error("init load aborted");
      return r;
    }).then((r) => {
      const {
        hls: n
      } = this, {
        payload: s
      } = r, o = e.decryptdata;
      if (s && s.byteLength > 0 && o && o.key && o.iv && o.method === "AES-128") {
        const a = self.performance.now();
        return this.decrypter.decrypt(new Uint8Array(s), o.key.buffer, o.iv.buffer).catch((l) => {
          throw n.trigger(O.ERROR, {
            type: fe.MEDIA_ERROR,
            details: W.FRAG_DECRYPT_ERROR,
            fatal: !1,
            error: l,
            reason: l.message,
            frag: e
          }), l;
        }).then((l) => {
          const u = self.performance.now();
          return n.trigger(O.FRAG_DECRYPTED, {
            frag: e,
            payload: l,
            stats: {
              tstart: a,
              tdecrypt: u
            }
          }), r.payload = l, r;
        });
      }
      return r;
    }).then((r) => {
      const {
        fragCurrent: n,
        hls: s,
        levels: o
      } = this;
      if (!o)
        throw new Error("init load aborted, missing levels");
      const a = e.stats;
      this.state = z.IDLE, t.fragmentError = 0, e.data = new Uint8Array(r.payload), a.parsing.start = a.buffering.start = self.performance.now(), a.parsing.end = a.buffering.end = self.performance.now(), r.frag === n && s.trigger(O.FRAG_BUFFERED, {
        stats: a,
        frag: n,
        part: null,
        id: e.type
      }), this.tick();
    }).catch((r) => {
      this.state === z.STOPPED || this.state === z.ERROR || (this.warn(r), this.resetFragmentLoading(e));
    });
  }
  fragContextChanged(e) {
    const {
      fragCurrent: t
    } = this;
    return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId;
  }
  fragBufferedComplete(e, t) {
    var r, n, s, o;
    const a = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.playlistType === ge.MAIN ? "level" : "track"} ${e.level} (frag:[${((r = e.startPTS) != null ? r : NaN).toFixed(3)}-${((n = e.endPTS) != null ? n : NaN).toFixed(3)}] > buffer:${a ? yy.toString(je.getBuffered(a)) : "(detached)"})`), this.state = z.IDLE, a && (!this.loadedmetadata && e.type == ge.MAIN && a.buffered.length && ((s = this.fragCurrent) == null ? void 0 : s.sn) === ((o = this.fragPrevious) == null ? void 0 : o.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick());
  }
  seekToStartPos() {
  }
  _handleFragmentLoadComplete(e) {
    const {
      transmuxer: t
    } = this;
    if (!t)
      return;
    const {
      frag: r,
      part: n,
      partsLoaded: s
    } = e, o = !s || s.length === 0 || s.some((l) => !l), a = new Fs(r.level, r.sn, r.stats.chunkCount + 1, 0, n ? n.index : -1, !o);
    t.flush(a);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _handleFragmentLoadProgress(e) {
  }
  _doFragLoad(e, t, r = null, n) {
    var s;
    const o = t == null ? void 0 : t.details;
    if (!this.levels || !o)
      throw new Error(`frag load aborted, missing level${o ? "" : " detail"}s`);
    let a = null;
    if (e.encrypted && !((s = e.decryptdata) != null && s.key) ? (this.log(`Loading key for ${e.sn} of [${o.startSN}-${o.endSN}], ${this.logPrefix === "[stream-controller]" ? "level" : "track"} ${e.level}`), this.state = z.KEY_LOADING, this.fragCurrent = e, a = this.keyLoader.load(e).then((c) => {
      if (!this.fragContextChanged(c.frag))
        return this.hls.trigger(O.KEY_LOADED, c), this.state === z.KEY_LOADING && (this.state = z.IDLE), c;
    }), this.hls.trigger(O.KEY_LOADING, {
      frag: e
    }), this.fragCurrent === null && (a = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))) : !e.encrypted && o.encryptedFragments.length && this.keyLoader.loadClear(e, o.encryptedFragments), r = Math.max(e.start, r || 0), this.config.lowLatencyMode && e.sn !== "initSegment") {
      const c = o.partList;
      if (c && n) {
        r > e.end && o.fragmentHint && (e = o.fragmentHint);
        const d = this.getNextPart(c, e, r);
        if (d > -1) {
          const h = c[d];
          this.log(`Loading part sn: ${e.sn} p: ${h.index} cc: ${e.cc} of playlist [${o.startSN}-${o.endSN}] parts [0-${d}-${c.length - 1}] ${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${e.level}, target: ${parseFloat(r.toFixed(3))}`), this.nextLoadPosition = h.start + h.duration, this.state = z.FRAG_LOADING;
          let p;
          return a ? p = a.then((f) => !f || this.fragContextChanged(f.frag) ? null : this.doFragPartsLoad(e, h, t, n)).catch((f) => this.handleFragLoadError(f)) : p = this.doFragPartsLoad(e, h, t, n).catch((f) => this.handleFragLoadError(f)), this.hls.trigger(O.FRAG_LOADING, {
            frag: e,
            part: h,
            targetBufferTime: r
          }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : p;
        } else if (!e.url || this.loadedEndOfParts(c, r))
          return Promise.resolve(null);
      }
    }
    this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${o ? "of [" + o.startSN + "-" + o.endSN + "] " : ""}${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${e.level}, target: ${parseFloat(r.toFixed(3))}`), de(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = z.FRAG_LOADING;
    const l = this.config.progressive;
    let u;
    return l && a ? u = a.then((c) => !c || this.fragContextChanged(c == null ? void 0 : c.frag) ? null : this.fragmentLoader.load(e, n)).catch((c) => this.handleFragLoadError(c)) : u = Promise.all([this.fragmentLoader.load(e, l ? n : void 0), a]).then(([c]) => (!l && c && n && n(c), c)).catch((c) => this.handleFragLoadError(c)), this.hls.trigger(O.FRAG_LOADING, {
      frag: e,
      targetBufferTime: r
    }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : u;
  }
  doFragPartsLoad(e, t, r, n) {
    return new Promise((s, o) => {
      var a;
      const l = [], u = (a = r.details) == null ? void 0 : a.partList, c = (d) => {
        this.fragmentLoader.loadPart(e, d, n).then((h) => {
          l[d.index] = h;
          const p = h.part;
          this.hls.trigger(O.FRAG_LOADED, h);
          const f = aa(r, e.sn, d.index + 1) || Yl(u, e.sn, d.index + 1);
          if (f)
            c(f);
          else
            return s({
              frag: e,
              part: p,
              partsLoaded: l
            });
        }).catch(o);
      };
      c(t);
    });
  }
  handleFragLoadError(e) {
    if ("data" in e) {
      const t = e.data;
      e.data && t.details === W.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(O.ERROR, t);
    } else
      this.hls.trigger(O.ERROR, {
        type: fe.OTHER_ERROR,
        details: W.INTERNAL_EXCEPTION,
        err: e,
        error: e,
        fatal: !0
      });
    return null;
  }
  _handleTransmuxerFlush(e) {
    const t = this.getCurrentContext(e);
    if (!t || this.state !== z.PARSING) {
      !this.fragCurrent && this.state !== z.STOPPED && this.state !== z.ERROR && (this.state = z.IDLE);
      return;
    }
    const {
      frag: r,
      part: n,
      level: s
    } = t, o = self.performance.now();
    r.stats.parsing.end = o, n && (n.stats.parsing.end = o), this.updateLevelTiming(r, n, s, e.partial);
  }
  getCurrentContext(e) {
    const {
      levels: t,
      fragCurrent: r
    } = this, {
      level: n,
      sn: s,
      part: o
    } = e;
    if (!(t != null && t[n]))
      return this.warn(`Levels object was unset while buffering fragment ${s} of level ${n}. The current chunk will not be buffered.`), null;
    const a = t[n], l = o > -1 ? aa(a, s, o) : null, u = l ? l.fragment : Yv(a, s, r);
    return u ? (r && r !== u && (u.stats = r.stats), {
      frag: u,
      part: l,
      level: a
    }) : null;
  }
  bufferFragmentData(e, t, r, n) {
    var s;
    if (!e || this.state !== z.PARSING)
      return;
    const {
      data1: o,
      data2: a
    } = e;
    let l = o;
    if (o && a && (l = Lr(o, a)), !((s = l) != null && s.length))
      return;
    const u = {
      type: e.type,
      frag: t,
      part: r,
      chunkMeta: n,
      parent: t.type,
      data: l
    };
    this.hls.trigger(O.BUFFER_APPENDING, u), e.dropped && e.independent && !r && this.flushBufferGap(t);
  }
  flushBufferGap(e) {
    const t = this.media;
    if (!t)
      return;
    if (!je.isBuffered(t, t.currentTime)) {
      this.flushMainBuffer(0, e.start);
      return;
    }
    const r = t.currentTime, n = je.bufferInfo(t, r, 0), s = e.duration, o = Math.min(this.config.maxFragLookUpTolerance * 2, s * 0.25), a = Math.max(Math.min(e.start - o, n.end - o), r + o);
    e.start - a > o && this.flushMainBuffer(a, e.start);
  }
  getFwdBufferInfo(e, t) {
    const r = this.getLoadPosition();
    return de(r) ? this.getFwdBufferInfoAtPos(e, r, t) : null;
  }
  getFwdBufferInfoAtPos(e, t, r) {
    const {
      config: {
        maxBufferHole: n
      }
    } = this, s = je.bufferInfo(e, t, n);
    if (s.len === 0 && s.nextStart !== void 0) {
      const o = this.fragmentTracker.getBufferedFrag(t, r);
      if (o && s.nextStart < o.end)
        return je.bufferInfo(e, t, Math.max(s.nextStart, n));
    }
    return s;
  }
  getMaxBufferLength(e) {
    const {
      config: t
    } = this;
    let r;
    return e ? r = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : r = t.maxBufferLength, Math.min(r, t.maxMaxBufferLength);
  }
  reduceMaxBufferLength(e) {
    const t = this.config, r = e || t.maxBufferLength;
    return t.maxMaxBufferLength >= r ? (t.maxMaxBufferLength /= 2, this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`), !0) : !1;
  }
  getAppendedFrag(e, t = ge.MAIN) {
    const r = this.fragmentTracker.getAppendedFrag(e, ge.MAIN);
    return r && "fragment" in r ? r.fragment : r;
  }
  getNextFragment(e, t) {
    const r = t.fragments, n = r.length;
    if (!n)
      return null;
    const {
      config: s
    } = this, o = r[0].start;
    let a;
    if (t.live) {
      const l = s.initialLiveManifestSize;
      if (n < l)
        return this.warn(`Not enough fragments to start playback (have: ${n}, need: ${l})`), null;
      !t.PTSKnown && !this.startFragRequested && this.startPosition === -1 && (a = this.getInitialLiveFragment(t, r), this.startPosition = a ? this.hls.liveSyncPosition || a.start : e);
    } else
      e <= o && (a = r[0]);
    if (!a) {
      const l = s.lowLatencyMode ? t.partEnd : t.fragmentEnd;
      a = this.getFragmentAtPosition(e, l, t);
    }
    return this.mapToInitFragWhenRequired(a);
  }
  isLoopLoading(e, t) {
    const r = this.fragmentTracker.getState(e);
    return (r === at.OK || r === at.PARTIAL && !!e.gap) && this.nextLoadPosition > t;
  }
  getNextFragmentLoopLoading(e, t, r, n, s) {
    const o = e.gap, a = this.getNextFragment(this.nextLoadPosition, t);
    if (a === null)
      return a;
    if (e = a, o && e && !e.gap && r.nextStart) {
      const l = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, r.nextStart, n);
      if (l !== null && r.len + l.len >= s)
        return this.log(`buffer full after gaps in "${n}" playlist starting at sn: ${e.sn}`), null;
    }
    return e;
  }
  mapToInitFragWhenRequired(e) {
    return e != null && e.initSegment && !(e != null && e.initSegment.data) && !this.bitrateTest ? e.initSegment : e;
  }
  getNextPart(e, t, r) {
    let n = -1, s = !1, o = !0;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a];
      if (o = o && !u.independent, n > -1 && r < u.start)
        break;
      const c = u.loaded;
      c ? n = -1 : (s || u.independent || o) && u.fragment === t && (n = a), s = c;
    }
    return n;
  }
  loadedEndOfParts(e, t) {
    const r = e[e.length - 1];
    return r && t > r.start && r.loaded;
  }
  /*
   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
   "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
   start and end times for each fragment in the playlist (after which this method will not need to be called).
  */
  getInitialLiveFragment(e, t) {
    const r = this.fragPrevious;
    let n = null;
    if (r) {
      if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${r.programDateTime}`), n = qv(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !n) {
        const s = r.sn + 1;
        if (s >= e.startSN && s <= e.endSN) {
          const o = t[s - e.startSN];
          r.cc === o.cc && (n = o, this.log(`Live playlist, switching playlist, load frag with next SN: ${n.sn}`));
        }
        n || (n = Xv(t, r.cc), n && this.log(`Live playlist, switching playlist, load frag with same CC: ${n.sn}`));
      }
    } else {
      const s = this.hls.liveSyncPosition;
      s !== null && (n = this.getFragmentAtPosition(s, this.bitrateTest ? e.fragmentEnd : e.edge, e));
    }
    return n;
  }
  /*
  This method finds the best matching fragment given the provided position.
   */
  getFragmentAtPosition(e, t, r) {
    const {
      config: n
    } = this;
    let {
      fragPrevious: s
    } = this, {
      fragments: o,
      endSN: a
    } = r;
    const {
      fragmentHint: l
    } = r, u = n.maxFragLookUpTolerance, c = r.partList, d = !!(n.lowLatencyMode && c != null && c.length && l);
    d && l && !this.bitrateTest && (o = o.concat(l), a = l.sn);
    let h;
    if (e < t) {
      const p = e > t - u ? 0 : u;
      h = Ai(s, o, e, p);
    } else
      h = o[o.length - 1];
    if (h) {
      const p = h.sn - r.startSN, f = this.fragmentTracker.getState(h);
      if ((f === at.OK || f === at.PARTIAL && h.gap) && (s = h), s && h.sn === s.sn && (!d || c[0].fragment.sn > h.sn) && s && h.level === s.level) {
        const m = o[p + 1];
        h.sn < a && this.fragmentTracker.getState(m) !== at.OK ? h = m : h = null;
      }
    }
    return h;
  }
  synchronizeToLiveEdge(e) {
    const {
      config: t,
      media: r
    } = this;
    if (!r)
      return;
    const n = this.hls.liveSyncPosition, s = r.currentTime, o = e.fragments[0].start, a = e.edge, l = s >= o - t.maxFragLookUpTolerance && s <= a;
    if (n !== null && r.duration > n && (s < n || !l)) {
      const u = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
      (!l && r.readyState < 4 || s < a - u) && (this.loadedmetadata || (this.nextLoadPosition = n), r.readyState && (this.warn(`Playback: ${s.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${n.toFixed(3)}`), r.currentTime = n));
    }
  }
  alignPlaylists(e, t) {
    const {
      levels: r,
      levelLastLoaded: n,
      fragPrevious: s
    } = this, o = n !== null ? r[n] : null, a = e.fragments.length;
    if (!a)
      return this.warn("No fragments in live playlist"), 0;
    const l = e.fragments[0].start, u = !t, c = e.alignedSliding && de(l);
    if (u || !c && !l) {
      cy(s, o, e);
      const d = e.fragments[0].start;
      return this.log(`Live playlist sliding: ${d.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} prev-sn: ${s ? s.sn : "na"} fragments: ${a}`), d;
    }
    return l;
  }
  waitForCdnTuneIn(e) {
    return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3);
  }
  setStartPosition(e, t) {
    let r = this.startPosition;
    if (r < t && (r = -1), r === -1 || this.lastCurrentTime === -1) {
      const n = this.startTimeOffset !== null, s = n ? this.startTimeOffset : e.startTimeOffset;
      s !== null && de(s) ? (r = t + s, s < 0 && (r += e.totalduration), r = Math.min(Math.max(t, r), t + e.totalduration), this.log(`Start time offset ${s} found in ${n ? "multivariant" : "media"} playlist, adjust startPosition to ${r}`), this.startPosition = r) : e.live ? r = this.hls.liveSyncPosition || t : this.startPosition = r = 0, this.lastCurrentTime = r;
    }
    this.nextLoadPosition = r;
  }
  getLoadPosition() {
    const {
      media: e
    } = this;
    let t = 0;
    return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t;
  }
  handleFragLoadAborted(e, t) {
    this.transmuxer && e.sn !== "initSegment" && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} was aborted`), this.resetFragmentLoading(e));
  }
  resetFragmentLoading(e) {
    (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== z.FRAG_LOADING_WAITING_RETRY) && (this.state = z.IDLE);
  }
  onFragmentOrKeyLoadError(e, t) {
    if (t.chunkMeta && !t.frag) {
      const c = this.getCurrentContext(t.chunkMeta);
      c && (t.frag = c.frag);
    }
    const r = t.frag;
    if (!r || r.type !== e || !this.levels)
      return;
    if (this.fragContextChanged(r)) {
      var n;
      this.warn(`Frag load error must match current frag to retry ${r.url} > ${(n = this.fragCurrent) == null ? void 0 : n.url}`);
      return;
    }
    const s = t.details === W.FRAG_GAP;
    s && this.fragmentTracker.fragBuffered(r, !0);
    const o = t.errorAction, {
      action: a,
      retryCount: l = 0,
      retryConfig: u
    } = o || {};
    if (o && a === Et.RetryRequest && u) {
      this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition);
      const c = Ms(u, l);
      this.warn(`Fragment ${r.sn} of ${e} ${r.level} errored with ${t.details}, retrying loading ${l + 1}/${u.maxNumRetry} in ${c}ms`), o.resolved = !0, this.retryDate = self.performance.now() + c, this.state = z.FRAG_LOADING_WAITING_RETRY;
    } else
      u && o ? (this.resetFragmentErrors(e), l < u.maxNumRetry ? s || (o.resolved = !0) : K.warn(`${t.details} reached or exceeded max retry (${l})`)) : this.state = z.ERROR;
    this.tickImmediate();
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === z.PARSING || this.state === z.PARSED) {
      const t = e.parent, r = this.getFwdBufferInfo(this.mediaBuffer, t), n = r && r.len > 0.5;
      n && this.reduceMaxBufferLength(r.len);
      const s = !n;
      return s && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), s;
    }
    return !1;
  }
  resetFragmentErrors(e) {
    e === ge.AUDIO && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== z.STOPPED && (this.state = z.IDLE);
  }
  afterBufferFlushed(e, t, r) {
    if (!e)
      return;
    const n = je.getBuffered(e);
    this.fragmentTracker.detectEvictedFragments(t, n, r), this.state === z.ENDED && this.resetLoadingState();
  }
  resetLoadingState() {
    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = z.IDLE;
  }
  resetStartWhenNotLoaded(e) {
    if (!this.loadedmetadata) {
      this.startFragRequested = !1;
      const t = this.levels ? this.levels[e].details : null;
      t != null && t.live ? (this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;
    }
  }
  resetWhenMissingContext(e) {
    this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(e.level), this.resetLoadingState();
  }
  removeUnbufferedFrags(e = 0) {
    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0);
  }
  updateLevelTiming(e, t, r, n) {
    var s;
    const o = r.details;
    if (!o) {
      this.warn("level.details undefined");
      return;
    }
    if (Object.keys(e.elementaryStreams).reduce((l, u) => {
      const c = e.elementaryStreams[u];
      if (c) {
        const d = c.endPTS - c.startPTS;
        if (d <= 0)
          return this.warn(`Could not parse fragment ${e.sn} ${u} duration reliably (${d})`), l || !1;
        const h = n ? 0 : Ql(o, e, c.startPTS, c.endPTS, c.startDTS, c.endDTS);
        return this.hls.trigger(O.LEVEL_PTS_UPDATED, {
          details: o,
          level: r,
          drift: h,
          type: u,
          frag: e,
          start: c.startPTS,
          end: c.endPTS
        }), !0;
      }
      return l;
    }, !1))
      r.fragmentError = 0;
    else if (((s = this.transmuxer) == null ? void 0 : s.error) === null) {
      const l = new Error(`Found no media in fragment ${e.sn} of level ${r.id} resetting transmuxer to fallback to playlist timing`);
      if (this.warn(l.message), this.hls.trigger(O.ERROR, {
        type: fe.MEDIA_ERROR,
        details: W.FRAG_PARSING_ERROR,
        fatal: !1,
        error: l,
        frag: e,
        reason: `Found no media in msn ${e.sn} of level "${r.url}"`
      }), !this.hls)
        return;
      this.resetTransmuxer();
    }
    this.state = z.PARSED, this.hls.trigger(O.FRAG_PARSED, {
      frag: e,
      part: t
    });
  }
  resetTransmuxer() {
    this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null);
  }
  recoverWorkerError(e) {
    e.event === "demuxerWorker" && (this.resetTransmuxer(), this.resetLoadingState());
  }
  set state(e) {
    const t = this._state;
    t !== e && (this._state = e, this.log(`${t}->${e}`));
  }
  get state() {
    return this._state;
  }
}
function Xl() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}
function Ey() {
  const i = hn();
  if (!i)
    return !1;
  const e = Xl(), t = i && typeof i.isTypeSupported == "function" && i.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'), r = !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function";
  return !!t && !!r;
}
function Ay() {
  var i;
  const e = Xl();
  return typeof (e == null || (i = e.prototype) == null ? void 0 : i.changeType) == "function";
}
function _y() {
  return typeof __HLS_WORKER_BUNDLE__ == "function";
}
function xy() {
  const i = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
    type: "text/javascript"
  }), e = self.URL.createObjectURL(i);
  return {
    worker: new self.Worker(e),
    objectURL: e
  };
}
function Sy(i) {
  const e = new self.URL(i, self.location.href).href;
  return {
    worker: new self.Worker(e),
    scriptURL: e
  };
}
function Ht(i = "", e = 9e4) {
  return {
    type: i,
    id: -1,
    pid: -1,
    inputTimeScale: e,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  };
}
class $l {
  constructor() {
    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;
  }
  resetInitSegment(e, t, r, n) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    };
  }
  resetTimeStamp(e) {
    this.initPTS = e, this.resetContiguity();
  }
  resetContiguity() {
    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;
  }
  canParse(e, t) {
    return !1;
  }
  appendFrame(e, t, r) {
  }
  // feed incoming data to the front of the parsing pipeline
  demux(e, t) {
    this.cachedData && (e = Lr(this.cachedData, e), this.cachedData = null);
    let r = Yi(e, 0), n = r ? r.length : 0, s;
    const o = this._audioTrack, a = this._id3Track, l = r ? sv(r) : void 0, u = e.length;
    for ((this.basePTS === null || this.frameIndex === 0 && de(l)) && (this.basePTS = Ty(l, t, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), r && r.length > 0 && a.samples.push({
      pts: this.lastPTS,
      dts: this.lastPTS,
      data: r,
      type: Ft.audioId3,
      duration: Number.POSITIVE_INFINITY
    }); n < u; ) {
      if (this.canParse(e, n)) {
        const c = this.appendFrame(o, e, n);
        c ? (this.frameIndex++, this.lastPTS = c.sample.pts, n += c.length, s = n) : n = u;
      } else
        nv(e, n) ? (r = Yi(e, n), a.samples.push({
          pts: this.lastPTS,
          dts: this.lastPTS,
          data: r,
          type: Ft.audioId3,
          duration: Number.POSITIVE_INFINITY
        }), n += r.length, s = n) : n++;
      if (n === u && s !== u) {
        const c = Tr(e, s);
        this.cachedData ? this.cachedData = Lr(this.cachedData, c) : this.cachedData = c;
      }
    }
    return {
      audioTrack: o,
      videoTrack: Ht(),
      id3Track: a,
      textTrack: Ht()
    };
  }
  demuxSampleAes(e, t, r) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
  }
  flush(e) {
    const t = this.cachedData;
    return t && (this.cachedData = null, this.demux(t, 0)), {
      audioTrack: this._audioTrack,
      videoTrack: Ht(),
      id3Track: this._id3Track,
      textTrack: Ht()
    };
  }
  destroy() {
  }
}
const Ty = (i, e, t) => {
  if (de(i))
    return i * 90;
  const r = t ? t.baseTime * 9e4 / t.timescale : 0;
  return e * 9e4 + r;
};
function Iy(i, e, t, r) {
  let n, s, o, a;
  const l = navigator.userAgent.toLowerCase(), u = r, c = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  n = ((e[t + 2] & 192) >>> 6) + 1;
  const d = (e[t + 2] & 60) >>> 2;
  if (d > c.length - 1) {
    i.trigger(O.ERROR, {
      type: fe.MEDIA_ERROR,
      details: W.FRAG_PARSING_ERROR,
      fatal: !0,
      reason: `invalid ADTS sampling index:${d}`
    });
    return;
  }
  return o = (e[t + 2] & 1) << 2, o |= (e[t + 3] & 192) >>> 6, K.log(`manifest codec:${r}, ADTS type:${n}, samplingIndex:${d}`), /firefox/i.test(l) ? d >= 6 ? (n = 5, a = new Array(4), s = d - 3) : (n = 2, a = new Array(2), s = d) : l.indexOf("android") !== -1 ? (n = 2, a = new Array(2), s = d) : (n = 5, a = new Array(4), r && (r.indexOf("mp4a.40.29") !== -1 || r.indexOf("mp4a.40.5") !== -1) || !r && d >= 6 ? s = d - 3 : ((r && r.indexOf("mp4a.40.2") !== -1 && (d >= 6 && o === 1 || /vivaldi/i.test(l)) || !r && o === 1) && (n = 2, a = new Array(2)), s = d)), a[0] = n << 3, a[0] |= (d & 14) >> 1, a[1] |= (d & 1) << 7, a[1] |= o << 3, n === 5 && (a[1] |= (s & 14) >> 1, a[2] = (s & 1) << 7, a[2] |= 8, a[3] = 0), {
    config: a,
    samplerate: c[d],
    channelCount: o,
    codec: "mp4a.40." + n,
    manifestCodec: u
  };
}
function eu(i, e) {
  return i[e] === 255 && (i[e + 1] & 246) === 240;
}
function tu(i, e) {
  return i[e + 1] & 1 ? 7 : 9;
}
function Gs(i, e) {
  return (i[e + 3] & 3) << 11 | i[e + 4] << 3 | (i[e + 5] & 224) >>> 5;
}
function by(i, e) {
  return e + 5 < i.length;
}
function $i(i, e) {
  return e + 1 < i.length && eu(i, e);
}
function Ly(i, e) {
  return by(i, e) && eu(i, e) && Gs(i, e) <= i.length - e;
}
function Cy(i, e) {
  if ($i(i, e)) {
    const t = tu(i, e);
    if (e + t >= i.length)
      return !1;
    const r = Gs(i, e);
    if (r <= t)
      return !1;
    const n = e + r;
    return n === i.length || $i(i, n);
  }
  return !1;
}
function ru(i, e, t, r, n) {
  if (!i.samplerate) {
    const s = Iy(e, t, r, n);
    if (!s)
      return;
    i.config = s.config, i.samplerate = s.samplerate, i.channelCount = s.channelCount, i.codec = s.codec, i.manifestCodec = s.manifestCodec, K.log(`parsed codec:${i.codec}, rate:${s.samplerate}, channels:${s.channelCount}`);
  }
}
function iu(i) {
  return 1024 * 9e4 / i;
}
function Ry(i, e) {
  const t = tu(i, e);
  if (e + t <= i.length) {
    const r = Gs(i, e) - t;
    if (r > 0)
      return {
        headerLength: t,
        frameLength: r
      };
  }
}
function nu(i, e, t, r, n) {
  const s = iu(i.samplerate), o = r + n * s, a = Ry(e, t);
  let l;
  if (a) {
    const {
      frameLength: d,
      headerLength: h
    } = a, p = h + d, f = Math.max(0, t + p - e.length);
    f ? (l = new Uint8Array(p - h), l.set(e.subarray(t + h, e.length), 0)) : l = e.subarray(t + h, t + p);
    const g = {
      unit: l,
      pts: o
    };
    return f || i.samples.push(g), {
      sample: g,
      length: p,
      missing: f
    };
  }
  const u = e.length - t;
  return l = new Uint8Array(u), l.set(e.subarray(t, e.length), 0), {
    sample: {
      unit: l,
      pts: o
    },
    length: u,
    missing: -1
  };
}
class wy extends $l {
  constructor(e, t) {
    super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t;
  }
  resetInitSegment(e, t, r, n) {
    super.resetInitSegment(e, t, r, n), this._audioTrack = {
      container: "audio/adts",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "aac",
      samples: [],
      manifestCodec: t,
      duration: n,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
  static probe(e) {
    if (!e)
      return !1;
    let r = (Yi(e, 0) || []).length;
    for (let n = e.length; r < n; r++)
      if (Cy(e, r))
        return K.log("ADTS sync word found !"), !0;
    return !1;
  }
  canParse(e, t) {
    return Ly(e, t);
  }
  appendFrame(e, t, r) {
    ru(e, this.observer, t, r, e.manifestCodec);
    const n = nu(e, t, r, this.basePTS, this.frameIndex);
    if (n && n.missing === 0)
      return n;
  }
}
const ky = /\/emsg[-/]ID3/i;
class Dy {
  constructor(e, t) {
    this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t;
  }
  resetTimeStamp() {
  }
  resetInitSegment(e, t, r, n) {
    const s = this.videoTrack = Ht("video", 1), o = this.audioTrack = Ht("audio", 1), a = this.txtTrack = Ht("text", 1);
    if (this.id3Track = Ht("id3", 1), this.timeOffset = 0, !(e != null && e.byteLength))
      return;
    const l = Ul(e);
    if (l.video) {
      const {
        id: u,
        timescale: c,
        codec: d
      } = l.video;
      s.id = u, s.timescale = a.timescale = c, s.codec = d;
    }
    if (l.audio) {
      const {
        id: u,
        timescale: c,
        codec: d
      } = l.audio;
      o.id = u, o.timescale = c, o.codec = d;
    }
    a.id = Bl.text, s.sampleDuration = 0, s.duration = o.duration = n;
  }
  resetContiguity() {
    this.remainderData = null;
  }
  static probe(e) {
    return e = e.length > 16384 ? e.subarray(0, 16384) : e, Pe(e, ["moof"]).length > 0;
  }
  demux(e, t) {
    this.timeOffset = t;
    let r = e;
    const n = this.videoTrack, s = this.txtTrack;
    if (this.config.progressive) {
      this.remainderData && (r = Lr(this.remainderData, e));
      const a = Av(r);
      this.remainderData = a.remainder, n.samples = a.valid || new Uint8Array();
    } else
      n.samples = r;
    const o = this.extractID3Track(n, t);
    return s.samples = Qo(t, n), {
      videoTrack: n,
      audioTrack: this.audioTrack,
      id3Track: o,
      textTrack: this.txtTrack
    };
  }
  flush() {
    const e = this.timeOffset, t = this.videoTrack, r = this.txtTrack;
    t.samples = this.remainderData || new Uint8Array(), this.remainderData = null;
    const n = this.extractID3Track(t, this.timeOffset);
    return r.samples = Qo(e, t), {
      videoTrack: t,
      audioTrack: Ht(),
      id3Track: n,
      textTrack: Ht()
    };
  }
  extractID3Track(e, t) {
    const r = this.id3Track;
    if (e.samples.length) {
      const n = Pe(e.samples, ["emsg"]);
      n && n.forEach((s) => {
        const o = Sv(s);
        if (ky.test(o.schemeIdUri)) {
          const a = de(o.presentationTime) ? o.presentationTime / o.timeScale : t + o.presentationTimeDelta / o.timeScale;
          let l = o.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : o.eventDuration / o.timeScale;
          l <= 1e-3 && (l = Number.POSITIVE_INFINITY);
          const u = o.payload;
          r.samples.push({
            data: u,
            len: u.byteLength,
            dts: a,
            pts: a,
            type: Ft.emsg,
            duration: l
          });
        }
      });
    }
    return r;
  }
  demuxSampleAes(e, t, r) {
    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
  }
  destroy() {
  }
}
let Di = null;
const Oy = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], Py = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], My = [
  // MPEG 2.5
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // Reserved
  [
    0,
    // Reserved
    0,
    // Layer3
    0,
    // Layer2
    0
    // Layer1
  ],
  // MPEG 2
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // MPEG 1
  [
    0,
    // Reserved
    144,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ]
], By = [
  0,
  // Reserved
  1,
  // Layer3
  1,
  // Layer2
  4
  // Layer1
];
function su(i, e, t, r, n) {
  if (t + 24 > e.length)
    return;
  const s = ou(e, t);
  if (s && t + s.frameLength <= e.length) {
    const o = s.samplesPerFrame * 9e4 / s.sampleRate, a = r + n * o, l = {
      unit: e.subarray(t, t + s.frameLength),
      pts: a,
      dts: a
    };
    return i.config = [], i.channelCount = s.channelCount, i.samplerate = s.sampleRate, i.samples.push(l), {
      sample: l,
      length: s.frameLength,
      missing: 0
    };
  }
}
function ou(i, e) {
  const t = i[e + 1] >> 3 & 3, r = i[e + 1] >> 1 & 3, n = i[e + 2] >> 4 & 15, s = i[e + 2] >> 2 & 3;
  if (t !== 1 && n !== 0 && n !== 15 && s !== 3) {
    const o = i[e + 2] >> 1 & 1, a = i[e + 3] >> 6, l = t === 3 ? 3 - r : r === 3 ? 3 : 4, u = Oy[l * 14 + n - 1] * 1e3, d = Py[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + s], h = a === 3 ? 1 : 2, p = My[t][r], f = By[r], g = p * 8 * f, m = Math.floor(p * u / d + o) * f;
    if (Di === null) {
      const A = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Di = A ? parseInt(A[1]) : 0;
    }
    return !!Di && Di <= 87 && r === 2 && u >= 224e3 && a === 0 && (i[e + 3] = i[e + 3] | 128), {
      sampleRate: d,
      channelCount: h,
      frameLength: m,
      samplesPerFrame: g
    };
  }
}
function Vs(i, e) {
  return i[e] === 255 && (i[e + 1] & 224) === 224 && (i[e + 1] & 6) !== 0;
}
function au(i, e) {
  return e + 1 < i.length && Vs(i, e);
}
function Fy(i, e) {
  return Vs(i, e) && 4 <= i.length - e;
}
function Ny(i, e) {
  if (e + 1 < i.length && Vs(i, e)) {
    const r = ou(i, e);
    let n = 4;
    r != null && r.frameLength && (n = r.frameLength);
    const s = e + n;
    return s === i.length || au(i, s);
  }
  return !1;
}
class ga {
  constructor(e) {
    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0;
  }
  // ():void
  loadWord() {
    const e = this.data, t = this.bytesAvailable, r = e.byteLength - t, n = new Uint8Array(4), s = Math.min(4, t);
    if (s === 0)
      throw new Error("no bytes available");
    n.set(e.subarray(r, r + s)), this.word = new DataView(n.buffer).getUint32(0), this.bitsAvailable = s * 8, this.bytesAvailable -= s;
  }
  // (count:int):void
  skipBits(e) {
    let t;
    e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);
  }
  // (size:int):uint
  readBits(e) {
    let t = Math.min(this.bitsAvailable, e);
    const r = this.word >>> 32 - t;
    if (e > 32 && K.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0)
      this.word <<= t;
    else if (this.bytesAvailable > 0)
      this.loadWord();
    else
      throw new Error("no bits available");
    return t = e - t, t > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r;
  }
  // ():uint
  skipLZ() {
    let e;
    for (e = 0; e < this.bitsAvailable; ++e)
      if (this.word & 2147483648 >>> e)
        return this.word <<= e, this.bitsAvailable -= e, e;
    return this.loadWord(), e + this.skipLZ();
  }
  // ():void
  skipUEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():void
  skipEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():uint
  readUEG() {
    const e = this.skipLZ();
    return this.readBits(e + 1) - 1;
  }
  // ():int
  readEG() {
    const e = this.readUEG();
    return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);
  }
  // Some convenience functions
  // :Boolean
  readBoolean() {
    return this.readBits(1) === 1;
  }
  // ():int
  readUByte() {
    return this.readBits(8);
  }
  // ():int
  readUShort() {
    return this.readBits(16);
  }
  // ():int
  readUInt() {
    return this.readBits(32);
  }
  /**
   * Advance the ExpGolomb decoder past a scaling list. The scaling
   * list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */
  skipScalingList(e) {
    let t = 8, r = 8, n;
    for (let s = 0; s < e; s++)
      r !== 0 && (n = this.readEG(), r = (t + n + 256) % 256), t = r === 0 ? t : r;
  }
  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @returns an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */
  readSPS() {
    let e = 0, t = 0, r = 0, n = 0, s, o, a;
    const l = this.readUByte.bind(this), u = this.readBits.bind(this), c = this.readUEG.bind(this), d = this.readBoolean.bind(this), h = this.skipBits.bind(this), p = this.skipEG.bind(this), f = this.skipUEG.bind(this), g = this.skipScalingList.bind(this);
    l();
    const m = l();
    if (u(5), h(3), l(), f(), m === 100 || m === 110 || m === 122 || m === 244 || m === 44 || m === 83 || m === 86 || m === 118 || m === 128) {
      const S = c();
      if (S === 3 && h(1), f(), f(), h(1), d())
        for (o = S !== 3 ? 8 : 12, a = 0; a < o; a++)
          d() && (a < 6 ? g(16) : g(64));
    }
    f();
    const v = c();
    if (v === 0)
      c();
    else if (v === 1)
      for (h(1), p(), p(), s = c(), a = 0; a < s; a++)
        p();
    f(), h(1);
    const E = c(), A = c(), _ = u(1);
    _ === 0 && h(1), h(1), d() && (e = c(), t = c(), r = c(), n = c());
    let y = [1, 1];
    if (d() && d())
      switch (l()) {
        case 1:
          y = [1, 1];
          break;
        case 2:
          y = [12, 11];
          break;
        case 3:
          y = [10, 11];
          break;
        case 4:
          y = [16, 11];
          break;
        case 5:
          y = [40, 33];
          break;
        case 6:
          y = [24, 11];
          break;
        case 7:
          y = [20, 11];
          break;
        case 8:
          y = [32, 11];
          break;
        case 9:
          y = [80, 33];
          break;
        case 10:
          y = [18, 11];
          break;
        case 11:
          y = [15, 11];
          break;
        case 12:
          y = [64, 33];
          break;
        case 13:
          y = [160, 99];
          break;
        case 14:
          y = [4, 3];
          break;
        case 15:
          y = [3, 2];
          break;
        case 16:
          y = [2, 1];
          break;
        case 255: {
          y = [l() << 8 | l(), l() << 8 | l()];
          break;
        }
      }
    return {
      width: Math.ceil((E + 1) * 16 - e * 2 - t * 2),
      height: (2 - _) * (A + 1) * 16 - (_ ? 2 : 4) * (r + n),
      pixelRatio: y
    };
  }
  readSliceType() {
    return this.readUByte(), this.readUEG(), this.readUEG();
  }
}
class Uy {
  constructor(e, t, r) {
    this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new Us(t, {
      removePKCS7Padding: !1
    });
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer);
  }
  // AAC - encrypt all full 16 bytes blocks starting from offset 16
  decryptAacSample(e, t, r) {
    const n = e[t].unit;
    if (n.length <= 16)
      return;
    const s = n.subarray(16, n.length - n.length % 16), o = s.buffer.slice(s.byteOffset, s.byteOffset + s.length);
    this.decryptBuffer(o).then((a) => {
      const l = new Uint8Array(a);
      n.set(l, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, r);
    });
  }
  decryptAacSamples(e, t, r) {
    for (; ; t++) {
      if (t >= e.length) {
        r();
        return;
      }
      if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, r), !this.decrypter.isSync()))
        return;
    }
  }
  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
  getAvcEncryptedData(e) {
    const t = Math.floor((e.length - 48) / 160) * 16 + 16, r = new Int8Array(t);
    let n = 0;
    for (let s = 32; s < e.length - 16; s += 160, n += 16)
      r.set(e.subarray(s, s + 16), n);
    return r;
  }
  getAvcDecryptedUnit(e, t) {
    const r = new Uint8Array(t);
    let n = 0;
    for (let s = 32; s < e.length - 16; s += 160, n += 16)
      e.set(r.subarray(n, n + 16), s);
    return e;
  }
  decryptAvcSample(e, t, r, n, s) {
    const o = Vl(s.data), a = this.getAvcEncryptedData(o);
    this.decryptBuffer(a.buffer).then((l) => {
      s.data = this.getAvcDecryptedUnit(o, l), this.decrypter.isSync() || this.decryptAvcSamples(e, t, r + 1, n);
    });
  }
  decryptAvcSamples(e, t, r, n) {
    if (e instanceof Uint8Array)
      throw new Error("Cannot decrypt samples of type Uint8Array");
    for (; ; t++, r = 0) {
      if (t >= e.length) {
        n();
        return;
      }
      const s = e[t].units;
      for (; !(r >= s.length); r++) {
        const o = s[r];
        if (!(o.data.length <= 48 || o.type !== 1 && o.type !== 5) && (this.decryptAvcSample(e, t, r, n, o), !this.decrypter.isSync()))
          return;
      }
    }
  }
}
const mt = 188;
class lr {
  constructor(e, t, r) {
    this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = e, this.config = t, this.typeSupported = r;
  }
  static probe(e) {
    const t = lr.syncOffset(e);
    return t > 0 && K.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`), t !== -1;
  }
  static syncOffset(e) {
    const t = e.length, r = Math.min(mt * 5, e.length - mt) + 1;
    let n = 0;
    for (; n < r; ) {
      let s = !1;
      for (let o = n; o < t && e[o] === 71; o += mt)
        if (!s && os(e, o) === 0 && (s = !0), s && o + mt > r)
          return n;
      n++;
    }
    return -1;
  }
  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   */
  static createTrack(e, t) {
    return {
      container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
      type: e,
      id: Bl[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: e === "audio" ? t : void 0
    };
  }
  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   */
  resetInitSegment(e, t, r, n) {
    this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = lr.createTrack("video"), this._audioTrack = lr.createTrack("audio", n), this._id3Track = lr.createTrack("id3"), this._txtTrack = lr.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = r, this._duration = n;
  }
  resetTimeStamp() {
  }
  resetContiguity() {
    const {
      _audioTrack: e,
      _avcTrack: t,
      _id3Track: r
    } = this;
    e && (e.pesData = null), t && (t.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null;
  }
  demux(e, t, r = !1, n = !1) {
    r || (this.sampleAes = null);
    let s;
    const o = this._avcTrack, a = this._audioTrack, l = this._id3Track, u = this._txtTrack;
    let c = o.pid, d = o.pesData, h = a.pid, p = l.pid, f = a.pesData, g = l.pesData, m = null, v = this.pmtParsed, E = this._pmtId, A = e.length;
    if (this.remainderData && (e = Lr(this.remainderData, e), A = e.length, this.remainderData = null), A < mt && !n)
      return this.remainderData = e, {
        audioTrack: a,
        videoTrack: o,
        id3Track: l,
        textTrack: u
      };
    const _ = Math.max(0, lr.syncOffset(e));
    A -= (A - _) % mt, A < e.byteLength && !n && (this.remainderData = new Uint8Array(e.buffer, A, e.buffer.byteLength - A));
    let y = 0;
    for (let b = _; b < A; b += mt)
      if (e[b] === 71) {
        const w = !!(e[b + 1] & 64), P = os(e, b), C = (e[b + 3] & 48) >> 4;
        let T;
        if (C > 1) {
          if (T = b + 5 + e[b + 4], T === b + mt)
            continue;
        } else
          T = b + 4;
        switch (P) {
          case c:
            w && (d && (s = Or(d)) && this.parseAVCPES(o, u, s, !1), d = {
              data: [],
              size: 0
            }), d && (d.data.push(e.subarray(T, b + mt)), d.size += b + mt - T);
            break;
          case h:
            if (w) {
              if (f && (s = Or(f)))
                switch (a.segmentCodec) {
                  case "aac":
                    this.parseAACPES(a, s);
                    break;
                  case "mp3":
                    this.parseMPEGPES(a, s);
                    break;
                }
              f = {
                data: [],
                size: 0
              };
            }
            f && (f.data.push(e.subarray(T, b + mt)), f.size += b + mt - T);
            break;
          case p:
            w && (g && (s = Or(g)) && this.parseID3PES(l, s), g = {
              data: [],
              size: 0
            }), g && (g.data.push(e.subarray(T, b + mt)), g.size += b + mt - T);
            break;
          case 0:
            w && (T += e[T] + 1), E = this._pmtId = Ky(e, T);
            break;
          case E: {
            w && (T += e[T] + 1);
            const x = Gy(e, T, this.typeSupported, r);
            c = x.avc, c > 0 && (o.pid = c), h = x.audio, h > 0 && (a.pid = h, a.segmentCodec = x.segmentCodec), p = x.id3, p > 0 && (l.pid = p), m !== null && !v && (K.warn(`MPEG-TS PMT found at ${b} after unknown PID '${m}'. Backtracking to sync byte @${_} to parse all TS packets.`), m = null, b = _ - 188), v = this.pmtParsed = !0;
            break;
          }
          case 17:
          case 8191:
            break;
          default:
            m = P;
            break;
        }
      } else
        y++;
    if (y > 0) {
      const b = new Error(`Found ${y} TS packet/s that do not start with 0x47`);
      this.observer.emit(O.ERROR, O.ERROR, {
        type: fe.MEDIA_ERROR,
        details: W.FRAG_PARSING_ERROR,
        fatal: !1,
        error: b,
        reason: b.message
      });
    }
    o.pesData = d, a.pesData = f, l.pesData = g;
    const S = {
      audioTrack: a,
      videoTrack: o,
      id3Track: l,
      textTrack: u
    };
    return n && this.extractRemainingSamples(S), S;
  }
  flush() {
    const {
      remainderData: e
    } = this;
    this.remainderData = null;
    let t;
    return e ? t = this.demux(e, -1, !1, !0) : t = {
      videoTrack: this._avcTrack,
      audioTrack: this._audioTrack,
      id3Track: this._id3Track,
      textTrack: this._txtTrack
    }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t;
  }
  extractRemainingSamples(e) {
    const {
      audioTrack: t,
      videoTrack: r,
      id3Track: n,
      textTrack: s
    } = e, o = r.pesData, a = t.pesData, l = n.pesData;
    let u;
    if (o && (u = Or(o)) ? (this.parseAVCPES(r, s, u, !0), r.pesData = null) : r.pesData = o, a && (u = Or(a))) {
      switch (t.segmentCodec) {
        case "aac":
          this.parseAACPES(t, u);
          break;
        case "mp3":
          this.parseMPEGPES(t, u);
          break;
      }
      t.pesData = null;
    } else
      a != null && a.size && K.log("last AAC PES packet truncated,might overlap between fragments"), t.pesData = a;
    l && (u = Or(l)) ? (this.parseID3PES(n, u), n.pesData = null) : n.pesData = l;
  }
  demuxSampleAes(e, t, r) {
    const n = this.demux(e, r, !0, !this.config.progressive), s = this.sampleAes = new Uy(this.observer, this.config, t);
    return this.decrypt(n, s);
  }
  decrypt(e, t) {
    return new Promise((r) => {
      const {
        audioTrack: n,
        videoTrack: s
      } = e;
      n.samples && n.segmentCodec === "aac" ? t.decryptAacSamples(n.samples, 0, () => {
        s.samples ? t.decryptAvcSamples(s.samples, 0, 0, () => {
          r(e);
        }) : r(e);
      }) : s.samples && t.decryptAvcSamples(s.samples, 0, 0, () => {
        r(e);
      });
    });
  }
  destroy() {
    this._duration = 0;
  }
  parseAVCPES(e, t, r, n) {
    const s = this.parseAVCNALu(e, r.data);
    let o = this.avcSample, a, l = !1;
    r.data = null, o && s.length && !e.audFound && (Pn(o, e), o = this.avcSample = Oi(!1, r.pts, r.dts, "")), s.forEach((u) => {
      switch (u.type) {
        case 1: {
          a = !0, o || (o = this.avcSample = Oi(!0, r.pts, r.dts, "")), o.frame = !0;
          const c = u.data;
          if (l && c.length > 4) {
            const d = new ga(c).readSliceType();
            (d === 2 || d === 4 || d === 7 || d === 9) && (o.key = !0);
          }
          break;
        }
        case 5:
          a = !0, o || (o = this.avcSample = Oi(!0, r.pts, r.dts, "")), o.key = !0, o.frame = !0;
          break;
        case 6: {
          a = !0, Gl(u.data, 1, r.pts, t.samples);
          break;
        }
        case 7:
          if (a = !0, l = !0, !e.sps) {
            const c = u.data, h = new ga(c).readSPS();
            e.width = h.width, e.height = h.height, e.pixelRatio = h.pixelRatio, e.sps = [c], e.duration = this._duration;
            const p = c.subarray(1, 4);
            let f = "avc1.";
            for (let g = 0; g < 3; g++) {
              let m = p[g].toString(16);
              m.length < 2 && (m = "0" + m), f += m;
            }
            e.codec = f;
          }
          break;
        case 8:
          a = !0, e.pps || (e.pps = [u.data]);
          break;
        case 9:
          a = !1, e.audFound = !0, o && Pn(o, e), o = this.avcSample = Oi(!1, r.pts, r.dts, "");
          break;
        case 12:
          a = !0;
          break;
        default:
          a = !1, o && (o.debug += "unknown NAL " + u.type + " ");
          break;
      }
      o && a && o.units.push(u);
    }), n && o && (Pn(o, e), this.avcSample = null);
  }
  getLastNalUnit(e) {
    var t;
    let r = this.avcSample, n;
    if ((!r || r.units.length === 0) && (r = e[e.length - 1]), (t = r) != null && t.units) {
      const s = r.units;
      n = s[s.length - 1];
    }
    return n;
  }
  parseAVCNALu(e, t) {
    const r = t.byteLength;
    let n = e.naluState || 0;
    const s = n, o = [];
    let a = 0, l, u, c, d = -1, h = 0;
    for (n === -1 && (d = 0, h = t[0] & 31, n = 0, a = 1); a < r; ) {
      if (l = t[a++], !n) {
        n = l ? 0 : 1;
        continue;
      }
      if (n === 1) {
        n = l ? 0 : 2;
        continue;
      }
      if (!l)
        n = 3;
      else if (l === 1) {
        if (d >= 0) {
          const p = {
            data: t.subarray(d, a - n - 1),
            type: h
          };
          o.push(p);
        } else {
          const p = this.getLastNalUnit(e.samples);
          if (p && (s && a <= 4 - s && p.state && (p.data = p.data.subarray(0, p.data.byteLength - s)), u = a - n - 1, u > 0)) {
            const f = new Uint8Array(p.data.byteLength + u);
            f.set(p.data, 0), f.set(t.subarray(0, u), p.data.byteLength), p.data = f, p.state = 0;
          }
        }
        a < r ? (c = t[a] & 31, d = a, h = c, n = 0) : n = -1;
      } else
        n = 0;
    }
    if (d >= 0 && n >= 0) {
      const p = {
        data: t.subarray(d, r),
        type: h,
        state: n
      };
      o.push(p);
    }
    if (o.length === 0) {
      const p = this.getLastNalUnit(e.samples);
      if (p) {
        const f = new Uint8Array(p.data.byteLength + t.byteLength);
        f.set(p.data, 0), f.set(t, p.data.byteLength), p.data = f;
      }
    }
    return e.naluState = n, o;
  }
  parseAACPES(e, t) {
    let r = 0;
    const n = this.aacOverFlow;
    let s = t.data;
    if (n) {
      this.aacOverFlow = null;
      const d = n.missing, h = n.sample.unit.byteLength;
      if (d === -1) {
        const p = new Uint8Array(h + s.byteLength);
        p.set(n.sample.unit, 0), p.set(s, h), s = p;
      } else {
        const p = h - d;
        n.sample.unit.set(s.subarray(0, d), p), e.samples.push(n.sample), r = n.missing;
      }
    }
    let o, a;
    for (o = r, a = s.length; o < a - 1 && !$i(s, o); o++)
      ;
    if (o !== r) {
      let d;
      const h = o < a - 1;
      h ? d = `AAC PES did not start with ADTS header,offset:${o}` : d = "No ADTS header found in AAC PES";
      const p = new Error(d);
      if (K.warn(`parsing error: ${d}`), this.observer.emit(O.ERROR, O.ERROR, {
        type: fe.MEDIA_ERROR,
        details: W.FRAG_PARSING_ERROR,
        fatal: !1,
        levelRetry: h,
        error: p,
        reason: d
      }), !h)
        return;
    }
    ru(e, this.observer, s, o, this.audioCodec);
    let l;
    if (t.pts !== void 0)
      l = t.pts;
    else if (n) {
      const d = iu(e.samplerate);
      l = n.sample.pts + d;
    } else {
      K.warn("[tsdemuxer]: AAC PES unknown PTS");
      return;
    }
    let u = 0, c;
    for (; o < a; )
      if (c = nu(e, s, o, l, u), o += c.length, c.missing) {
        this.aacOverFlow = c;
        break;
      } else
        for (u++; o < a - 1 && !$i(s, o); o++)
          ;
  }
  parseMPEGPES(e, t) {
    const r = t.data, n = r.length;
    let s = 0, o = 0;
    const a = t.pts;
    if (a === void 0) {
      K.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return;
    }
    for (; o < n; )
      if (au(r, o)) {
        const l = su(e, r, o, a, s);
        if (l)
          o += l.length, s++;
        else
          break;
      } else
        o++;
  }
  parseID3PES(e, t) {
    if (t.pts === void 0) {
      K.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return;
    }
    const r = et({}, t, {
      type: this._avcTrack ? Ft.emsg : Ft.audioId3,
      duration: Number.POSITIVE_INFINITY
    });
    e.samples.push(r);
  }
}
function Oi(i, e, t, r) {
  return {
    key: i,
    frame: !1,
    pts: e,
    dts: t,
    units: [],
    debug: r,
    length: 0
  };
}
function os(i, e) {
  return ((i[e + 1] & 31) << 8) + i[e + 2];
}
function Ky(i, e) {
  return (i[e + 10] & 31) << 8 | i[e + 11];
}
function Gy(i, e, t, r) {
  const n = {
    audio: -1,
    avc: -1,
    id3: -1,
    segmentCodec: "aac"
  }, s = (i[e + 1] & 15) << 8 | i[e + 2], o = e + 3 + s - 4, a = (i[e + 10] & 15) << 8 | i[e + 11];
  for (e += 12 + a; e < o; ) {
    const l = os(i, e);
    switch (i[e]) {
      case 207:
        if (!r) {
          K.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
          break;
        }
      case 15:
        n.audio === -1 && (n.audio = l);
        break;
      case 21:
        n.id3 === -1 && (n.id3 = l);
        break;
      case 219:
        if (!r) {
          K.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
          break;
        }
      case 27:
        n.avc === -1 && (n.avc = l);
        break;
      case 3:
      case 4:
        t.mpeg !== !0 && t.mp3 !== !0 ? K.log("MPEG audio found, not supported in this browser") : n.audio === -1 && (n.audio = l, n.segmentCodec = "mp3");
        break;
      case 36:
        K.warn("Unsupported HEVC stream type found");
        break;
    }
    e += ((i[e + 3] & 15) << 8 | i[e + 4]) + 5;
  }
  return n;
}
function Or(i) {
  let e = 0, t, r, n, s, o;
  const a = i.data;
  if (!i || i.size === 0)
    return null;
  for (; a[0].length < 19 && a.length > 1; ) {
    const u = new Uint8Array(a[0].length + a[1].length);
    u.set(a[0]), u.set(a[1], a[0].length), a[0] = u, a.splice(1, 1);
  }
  if (t = a[0], (t[0] << 16) + (t[1] << 8) + t[2] === 1) {
    if (r = (t[4] << 8) + t[5], r && r > i.size - 6)
      return null;
    const u = t[7];
    u & 192 && (s = (t[9] & 14) * 536870912 + // 1 << 29
    (t[10] & 255) * 4194304 + // 1 << 22
    (t[11] & 254) * 16384 + // 1 << 14
    (t[12] & 255) * 128 + // 1 << 7
    (t[13] & 254) / 2, u & 64 ? (o = (t[14] & 14) * 536870912 + // 1 << 29
    (t[15] & 255) * 4194304 + // 1 << 22
    (t[16] & 254) * 16384 + // 1 << 14
    (t[17] & 255) * 128 + // 1 << 7
    (t[18] & 254) / 2, s - o > 60 * 9e4 && (K.warn(`${Math.round((s - o) / 9e4)}s delta between PTS and DTS, align them`), s = o)) : o = s), n = t[8];
    let c = n + 9;
    if (i.size <= c)
      return null;
    i.size -= c;
    const d = new Uint8Array(i.size);
    for (let h = 0, p = a.length; h < p; h++) {
      t = a[h];
      let f = t.byteLength;
      if (c)
        if (c > f) {
          c -= f;
          continue;
        } else
          t = t.subarray(c), f -= c, c = 0;
      d.set(t, e), e += f;
    }
    return r && (r -= n + 3), {
      data: d,
      pts: s,
      dts: o,
      len: r
    };
  }
  return null;
}
function Pn(i, e) {
  if (i.units.length && i.frame) {
    if (i.pts === void 0) {
      const t = e.samples, r = t.length;
      if (r) {
        const n = t[r - 1];
        i.pts = n.pts, i.dts = n.dts;
      } else {
        e.dropped++;
        return;
      }
    }
    e.samples.push(i);
  }
  i.debug.length && K.log(i.pts + "/" + i.dts + ":" + i.debug);
}
class Vy extends $l {
  resetInitSegment(e, t, r, n) {
    super.resetInitSegment(e, t, r, n), this._audioTrack = {
      container: "audio/mpeg",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "mp3",
      samples: [],
      manifestCodec: t,
      duration: n,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  static probe(e) {
    if (!e)
      return !1;
    let r = (Yi(e, 0) || []).length;
    for (let n = e.length; r < n; r++)
      if (Ny(e, r))
        return K.log("MPEG Audio sync word found !"), !0;
    return !1;
  }
  canParse(e, t) {
    return Fy(e, t);
  }
  appendFrame(e, t, r) {
    if (this.basePTS !== null)
      return su(e, t, r, this.basePTS, this.frameIndex);
  }
}
class ma {
  static getSilentFrame(e, t) {
    switch (e) {
      case "mp4a.40.2":
        if (t === 1)
          return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (t === 2)
          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (t === 3)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        if (t === 4)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        if (t === 5)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        if (t === 6)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        break;
      default:
        if (t === 1)
          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (t === 2)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (t === 3)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        break;
    }
  }
}
const or = Math.pow(2, 32) - 1;
class H {
  static init() {
    H.types = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    let e;
    for (e in H.types)
      H.types.hasOwnProperty(e) && (H.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
    const t = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]), r = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    H.HDLR_TYPES = {
      video: t,
      audio: r
    };
    const n = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]), s = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    H.STTS = H.STSC = H.STCO = s, H.STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]), H.VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]), H.SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance
      0,
      0
      // reserved
    ]), H.STSD = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1
    ]);
    const o = new Uint8Array([105, 115, 111, 109]), a = new Uint8Array([97, 118, 99, 49]), l = new Uint8Array([0, 0, 0, 1]);
    H.FTYP = H.box(H.types.ftyp, o, l, o, a), H.DINF = H.box(H.types.dinf, H.box(H.types.dref, n));
  }
  static box(e, ...t) {
    let r = 8, n = t.length;
    const s = n;
    for (; n--; )
      r += t[n].byteLength;
    const o = new Uint8Array(r);
    for (o[0] = r >> 24 & 255, o[1] = r >> 16 & 255, o[2] = r >> 8 & 255, o[3] = r & 255, o.set(e, 4), n = 0, r = 8; n < s; n++)
      o.set(t[n], r), r += t[n].byteLength;
    return o;
  }
  static hdlr(e) {
    return H.box(H.types.hdlr, H.HDLR_TYPES[e]);
  }
  static mdat(e) {
    return H.box(H.types.mdat, e);
  }
  static mdhd(e, t) {
    t *= e;
    const r = Math.floor(t / (or + 1)), n = Math.floor(t % (or + 1));
    return H.box(H.types.mdhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      r >> 24,
      r >> 16 & 255,
      r >> 8 & 255,
      r & 255,
      n >> 24,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255,
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]));
  }
  static mdia(e) {
    return H.box(H.types.mdia, H.mdhd(e.timescale, e.duration), H.hdlr(e.type), H.minf(e));
  }
  static mfhd(e) {
    return H.box(H.types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      e >> 24,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255
      // sequence_number
    ]));
  }
  static minf(e) {
    return e.type === "audio" ? H.box(H.types.minf, H.box(H.types.smhd, H.SMHD), H.DINF, H.stbl(e)) : H.box(H.types.minf, H.box(H.types.vmhd, H.VMHD), H.DINF, H.stbl(e));
  }
  static moof(e, t, r) {
    return H.box(H.types.moof, H.mfhd(e), H.traf(r, t));
  }
  static moov(e) {
    let t = e.length;
    const r = [];
    for (; t--; )
      r[t] = H.trak(e[t]);
    return H.box.apply(null, [H.types.moov, H.mvhd(e[0].timescale, e[0].duration)].concat(r).concat(H.mvex(e)));
  }
  static mvex(e) {
    let t = e.length;
    const r = [];
    for (; t--; )
      r[t] = H.trex(e[t]);
    return H.box.apply(null, [H.types.mvex, ...r]);
  }
  static mvhd(e, t) {
    t *= e;
    const r = Math.floor(t / (or + 1)), n = Math.floor(t % (or + 1)), s = new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      r >> 24,
      r >> 16 & 255,
      r >> 8 & 255,
      r & 255,
      n >> 24,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255,
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return H.box(H.types.mvhd, s);
  }
  static sdtp(e) {
    const t = e.samples || [], r = new Uint8Array(4 + t.length);
    let n, s;
    for (n = 0; n < t.length; n++)
      s = t[n].flags, r[n + 4] = s.dependsOn << 4 | s.isDependedOn << 2 | s.hasRedundancy;
    return H.box(H.types.sdtp, r);
  }
  static stbl(e) {
    return H.box(H.types.stbl, H.stsd(e), H.box(H.types.stts, H.STTS), H.box(H.types.stsc, H.STSC), H.box(H.types.stsz, H.STSZ), H.box(H.types.stco, H.STCO));
  }
  static avc1(e) {
    let t = [], r = [], n, s, o;
    for (n = 0; n < e.sps.length; n++)
      s = e.sps[n], o = s.byteLength, t.push(o >>> 8 & 255), t.push(o & 255), t = t.concat(Array.prototype.slice.call(s));
    for (n = 0; n < e.pps.length; n++)
      s = e.pps[n], o = s.byteLength, r.push(o >>> 8 & 255), r.push(o & 255), r = r.concat(Array.prototype.slice.call(s));
    const a = H.box(H.types.avcC, new Uint8Array([
      1,
      // version
      t[3],
      // profile
      t[4],
      // profile compat
      t[5],
      // level
      255,
      // lengthSizeMinusOne, hard-coded to 4 bytes
      224 | e.sps.length
      // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(t).concat([
      e.pps.length
      // numOfPictureParameterSets
    ]).concat(r))), l = e.width, u = e.height, c = e.pixelRatio[0], d = e.pixelRatio[1];
    return H.box(
      H.types.avc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        l >> 8 & 255,
        l & 255,
        // width
        u >> 8 & 255,
        u & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      a,
      H.box(H.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      H.box(H.types.pasp, new Uint8Array([
        c >> 24,
        // hSpacing
        c >> 16 & 255,
        c >> 8 & 255,
        c & 255,
        d >> 24,
        // vSpacing
        d >> 16 & 255,
        d >> 8 & 255,
        d & 255
      ]))
    );
  }
  static esds(e) {
    const t = e.config.length;
    return new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      3,
      // descriptor_type
      23 + t,
      // length
      0,
      1,
      // es_id
      0,
      // stream_priority
      4,
      // descriptor_type
      15 + t,
      // length
      64,
      // codec : mpeg4_audio
      21,
      // stream_type
      0,
      0,
      0,
      // buffer_size
      0,
      0,
      0,
      0,
      // maxBitrate
      0,
      0,
      0,
      0,
      // avgBitrate
      5
      // descriptor_type
    ].concat([t]).concat(e.config).concat([6, 1, 2]));
  }
  static mp4a(e) {
    const t = e.samplerate;
    return H.box(H.types.mp4a, new Uint8Array([
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      // reserved
      0,
      1,
      // data_reference_index
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      e.channelCount,
      // channelcount
      0,
      16,
      // sampleSize:16bits
      0,
      0,
      0,
      0,
      // reserved2
      t >> 8 & 255,
      t & 255,
      //
      0,
      0
    ]), H.box(H.types.esds, H.esds(e)));
  }
  static mp3(e) {
    const t = e.samplerate;
    return H.box(H.types[".mp3"], new Uint8Array([
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      // reserved
      0,
      1,
      // data_reference_index
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      e.channelCount,
      // channelcount
      0,
      16,
      // sampleSize:16bits
      0,
      0,
      0,
      0,
      // reserved2
      t >> 8 & 255,
      t & 255,
      //
      0,
      0
    ]));
  }
  static stsd(e) {
    return e.type === "audio" ? e.segmentCodec === "mp3" && e.codec === "mp3" ? H.box(H.types.stsd, H.STSD, H.mp3(e)) : H.box(H.types.stsd, H.STSD, H.mp4a(e)) : H.box(H.types.stsd, H.STSD, H.avc1(e));
  }
  static tkhd(e) {
    const t = e.id, r = e.duration * e.timescale, n = e.width, s = e.height, o = Math.floor(r / (or + 1)), a = Math.floor(r % (or + 1));
    return H.box(H.types.tkhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      t >> 24 & 255,
      t >> 16 & 255,
      t >> 8 & 255,
      t & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      o >> 24,
      o >> 16 & 255,
      o >> 8 & 255,
      o & 255,
      a >> 24,
      a >> 16 & 255,
      a >> 8 & 255,
      a & 255,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      0,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      n >> 8 & 255,
      n & 255,
      0,
      0,
      // width
      s >> 8 & 255,
      s & 255,
      0,
      0
      // height
    ]));
  }
  static traf(e, t) {
    const r = H.sdtp(e), n = e.id, s = Math.floor(t / (or + 1)), o = Math.floor(t % (or + 1));
    return H.box(
      H.types.traf,
      H.box(H.types.tfhd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        n >> 24,
        n >> 16 & 255,
        n >> 8 & 255,
        n & 255
        // track_ID
      ])),
      H.box(H.types.tfdt, new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        s >> 24,
        s >> 16 & 255,
        s >> 8 & 255,
        s & 255,
        o >> 24,
        o >> 16 & 255,
        o >> 8 & 255,
        o & 255
      ])),
      H.trun(e, r.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8),
      // mdat header
      r
    );
  }
  /**
   * Generate a track box.
   * @param track a track definition
   */
  static trak(e) {
    return e.duration = e.duration || 4294967295, H.box(H.types.trak, H.tkhd(e), H.mdia(e));
  }
  static trex(e) {
    const t = e.id;
    return H.box(H.types.trex, new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      t >> 24,
      t >> 16 & 255,
      t >> 8 & 255,
      t & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]));
  }
  static trun(e, t) {
    const r = e.samples || [], n = r.length, s = 12 + 16 * n, o = new Uint8Array(s);
    let a, l, u, c, d, h;
    for (t += 8 + s, o.set([
      e.type === "video" ? 1 : 0,
      // version 1 for video with signed-int sample_composition_time_offset
      0,
      15,
      1,
      // flags
      n >>> 24 & 255,
      n >>> 16 & 255,
      n >>> 8 & 255,
      n & 255,
      // sample_count
      t >>> 24 & 255,
      t >>> 16 & 255,
      t >>> 8 & 255,
      t & 255
      // data_offset
    ], 0), a = 0; a < n; a++)
      l = r[a], u = l.duration, c = l.size, d = l.flags, h = l.cts, o.set([
        u >>> 24 & 255,
        u >>> 16 & 255,
        u >>> 8 & 255,
        u & 255,
        // sample_duration
        c >>> 24 & 255,
        c >>> 16 & 255,
        c >>> 8 & 255,
        c & 255,
        // sample_size
        d.isLeading << 2 | d.dependsOn,
        d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync,
        d.degradPrio & 61440,
        d.degradPrio & 15,
        // sample_flags
        h >>> 24 & 255,
        h >>> 16 & 255,
        h >>> 8 & 255,
        h & 255
        // sample_composition_time_offset
      ], 12 + 16 * a);
    return H.box(H.types.trun, o);
  }
  static initSegment(e) {
    H.types || H.init();
    const t = H.moov(e), r = new Uint8Array(H.FTYP.byteLength + t.byteLength);
    return r.set(H.FTYP), r.set(t, H.FTYP.byteLength), r;
  }
}
H.types = void 0;
H.HDLR_TYPES = void 0;
H.STTS = void 0;
H.STSC = void 0;
H.STCO = void 0;
H.STSZ = void 0;
H.VMHD = void 0;
H.SMHD = void 0;
H.STSD = void 0;
H.FTYP = void 0;
H.DINF = void 0;
const lu = 9e4;
function Hs(i, e, t = 1, r = !1) {
  const n = i * e * t;
  return r ? Math.round(n) : n;
}
function Hy(i, e, t = 1, r = !1) {
  return Hs(i, e, 1 / t, r);
}
function ti(i, e = !1) {
  return Hs(i, 1e3, 1 / lu, e);
}
function jy(i, e = 1) {
  return Hs(i, lu, 1 / e);
}
const Wy = 10 * 1e3, va = 1024, Qy = 1152;
let Pi = null, Mn = null;
class Bn {
  constructor(e, t, r, n = "") {
    if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, Pi === null) {
      const o = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Pi = o ? parseInt(o[1]) : 0;
    }
    if (Mn === null) {
      const s = navigator.userAgent.match(/Safari\/(\d+)/i);
      Mn = s ? parseInt(s[1]) : 0;
    }
  }
  destroy() {
  }
  resetTimeStamp(e) {
    K.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e;
  }
  resetNextTimestamp() {
    K.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;
  }
  resetInitSegment() {
    K.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1;
  }
  getVideoStartPts(e) {
    let t = !1;
    const r = e.reduce((n, s) => {
      const o = s.pts - n;
      return o < -4294967296 ? (t = !0, Ct(n, s.pts)) : o > 0 ? n : s.pts;
    }, e[0].pts);
    return t && K.debug("PTS rollover detected"), r;
  }
  remux(e, t, r, n, s, o, a, l) {
    let u, c, d, h, p, f, g = s, m = s;
    const v = e.pid > -1, E = t.pid > -1, A = t.samples.length, _ = e.samples.length > 0, y = a && A > 0 || A > 1;
    if ((!v || _) && (!E || y) || this.ISGenerated || a) {
      this.ISGenerated || (d = this.generateIS(e, t, s, o));
      const b = this.isVideoContiguous;
      let w = -1, P;
      if (y && (w = Jy(t.samples), !b && this.config.forceKeyFrameOnDiscontinuity))
        if (f = !0, w > 0) {
          K.warn(`[mp4-remuxer]: Dropped ${w} out of ${A} video samples due to a missing keyframe`);
          const C = this.getVideoStartPts(t.samples);
          t.samples = t.samples.slice(w), t.dropped += w, m += (t.samples[0].pts - C) / t.inputTimeScale, P = m;
        } else
          w === -1 && (K.warn(`[mp4-remuxer]: No keyframe found out of ${A} video samples`), f = !1);
      if (this.ISGenerated) {
        if (_ && y) {
          const C = this.getVideoStartPts(t.samples), x = (Ct(e.samples[0].pts, C) - C) / t.inputTimeScale;
          g += Math.max(0, x), m += Math.max(0, -x);
        }
        if (_) {
          if (e.samplerate || (K.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), d = this.generateIS(e, t, s, o)), c = this.remuxAudio(e, g, this.isAudioContiguous, o, E || y || l === ge.AUDIO ? m : void 0), y) {
            const C = c ? c.endPTS - c.startPTS : 0;
            t.inputTimeScale || (K.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), d = this.generateIS(e, t, s, o)), u = this.remuxVideo(t, m, b, C);
          }
        } else
          y && (u = this.remuxVideo(t, m, b, 0));
        u && (u.firstKeyFrame = w, u.independent = w !== -1, u.firstKeyFramePTS = P);
      }
    }
    return this.ISGenerated && this._initPTS && this._initDTS && (r.samples.length && (p = uu(r, s, this._initPTS, this._initDTS)), n.samples.length && (h = cu(n, s, this._initPTS))), {
      audio: c,
      video: u,
      initSegment: d,
      independent: f,
      text: h,
      id3: p
    };
  }
  generateIS(e, t, r, n) {
    const s = e.samples, o = t.samples, a = this.typeSupported, l = {}, u = this._initPTS;
    let c = !u || n, d = "audio/mp4", h, p, f;
    if (c && (h = p = 1 / 0), e.config && s.length) {
      switch (e.timescale = e.samplerate, e.segmentCodec) {
        case "mp3":
          a.mpeg ? (d = "audio/mpeg", e.codec = "") : a.mp3 && (e.codec = "mp3");
          break;
      }
      l.audio = {
        id: "audio",
        container: d,
        codec: e.codec,
        initSegment: e.segmentCodec === "mp3" && a.mpeg ? new Uint8Array(0) : H.initSegment([e]),
        metadata: {
          channelCount: e.channelCount
        }
      }, c && (f = e.inputTimeScale, !u || f !== u.timescale ? h = p = s[0].pts - Math.round(f * r) : c = !1);
    }
    if (t.sps && t.pps && o.length && (t.timescale = t.inputTimeScale, l.video = {
      id: "main",
      container: "video/mp4",
      codec: t.codec,
      initSegment: H.initSegment([t]),
      metadata: {
        width: t.width,
        height: t.height
      }
    }, c))
      if (f = t.inputTimeScale, !u || f !== u.timescale) {
        const g = this.getVideoStartPts(o), m = Math.round(f * r);
        p = Math.min(p, Ct(o[0].dts, g) - m), h = Math.min(h, g - m);
      } else
        c = !1;
    if (Object.keys(l).length)
      return this.ISGenerated = !0, c ? (this._initPTS = {
        baseTime: h,
        timescale: f
      }, this._initDTS = {
        baseTime: p,
        timescale: f
      }) : h = f = void 0, {
        tracks: l,
        initPTS: h,
        timescale: f
      };
  }
  remuxVideo(e, t, r, n) {
    const s = e.inputTimeScale, o = e.samples, a = [], l = o.length, u = this._initPTS;
    let c = this.nextAvcDts, d = 8, h = this.videoSampleDuration, p, f, g = Number.POSITIVE_INFINITY, m = Number.NEGATIVE_INFINITY, v = !1;
    if (!r || c === null) {
      const k = t * s, F = o[0].pts - Ct(o[0].dts, o[0].pts);
      c = k - F;
    }
    const E = u.baseTime * s / u.timescale;
    for (let k = 0; k < l; k++) {
      const F = o[k];
      F.pts = Ct(F.pts - E, c), F.dts = Ct(F.dts - E, c), F.dts < o[k > 0 ? k - 1 : k].dts && (v = !0);
    }
    v && o.sort(function(k, F) {
      const U = k.dts - F.dts, G = k.pts - F.pts;
      return U || G;
    }), p = o[0].dts, f = o[o.length - 1].dts;
    const A = f - p, _ = A ? Math.round(A / (l - 1)) : h || e.inputTimeScale / 30;
    if (r) {
      const k = p - c, F = k > _, U = k < -1;
      if ((F || U) && (F ? K.warn(`AVC: ${ti(k, !0)} ms (${k}dts) hole between fragments detected, filling it`) : K.warn(`AVC: ${ti(-k, !0)} ms (${k}dts) overlapping between fragments detected`), !U || c > o[0].pts)) {
        p = c;
        const G = o[0].pts - k;
        o[0].dts = p, o[0].pts = G, K.log(`Video: First PTS/DTS adjusted: ${ti(G, !0)}/${ti(p, !0)}, delta: ${ti(k, !0)} ms`);
      }
    }
    p = Math.max(0, p);
    let y = 0, S = 0;
    for (let k = 0; k < l; k++) {
      const F = o[k], U = F.units, G = U.length;
      let N = 0;
      for (let V = 0; V < G; V++)
        N += U[V].data.length;
      S += N, y += G, F.length = N, F.dts = Math.max(F.dts, p), g = Math.min(F.pts, g), m = Math.max(F.pts, m);
    }
    f = o[l - 1].dts;
    const b = S + 4 * y + 8;
    let w;
    try {
      w = new Uint8Array(b);
    } catch (k) {
      this.observer.emit(O.ERROR, O.ERROR, {
        type: fe.MUX_ERROR,
        details: W.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: k,
        bytes: b,
        reason: `fail allocating video mdat ${b}`
      });
      return;
    }
    const P = new DataView(w.buffer);
    P.setUint32(0, b), w.set(H.types.mdat, 4);
    let C = !1, T = Number.POSITIVE_INFINITY, x = Number.POSITIVE_INFINITY, L = Number.NEGATIVE_INFINITY, I = Number.NEGATIVE_INFINITY;
    for (let k = 0; k < l; k++) {
      const F = o[k], U = F.units;
      let G = 0;
      for (let j = 0, ee = U.length; j < ee; j++) {
        const Y = U[j], te = Y.data, oe = Y.data.byteLength;
        P.setUint32(d, oe), d += 4, w.set(te, d), d += oe, G += 4 + oe;
      }
      let N;
      if (k < l - 1)
        h = o[k + 1].dts - F.dts, N = o[k + 1].pts - F.pts;
      else {
        const j = this.config, ee = k > 0 ? F.dts - o[k - 1].dts : _;
        if (N = k > 0 ? F.pts - o[k - 1].pts : _, j.stretchShortVideoTrack && this.nextAudioPts !== null) {
          const Y = Math.floor(j.maxBufferHole * s), te = (n ? g + n * s : this.nextAudioPts) - F.pts;
          te > Y ? (h = te - ee, h < 0 ? h = ee : C = !0, K.log(`[mp4-remuxer]: It is approximately ${te / 90} ms to the next segment; using duration ${h / 90} ms for the last video frame.`)) : h = ee;
        } else
          h = ee;
      }
      const V = Math.round(F.pts - F.dts);
      T = Math.min(T, h), L = Math.max(L, h), x = Math.min(x, N), I = Math.max(I, N), a.push(new ya(F.key, h, G, V));
    }
    if (a.length) {
      if (Pi) {
        if (Pi < 70) {
          const k = a[0].flags;
          k.dependsOn = 2, k.isNonSync = 0;
        }
      } else if (Mn && I - x < L - T && _ / L < 0.025 && a[0].cts === 0) {
        K.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
        let k = p;
        for (let F = 0, U = a.length; F < U; F++) {
          const G = k + a[F].duration, N = k + a[F].cts;
          if (F < U - 1) {
            const V = G + a[F + 1].cts;
            a[F].duration = V - N;
          } else
            a[F].duration = F ? a[F - 1].duration : _;
          a[F].cts = 0, k = G;
        }
      }
    }
    h = C || !h ? _ : h, this.nextAvcDts = c = f + h, this.videoSampleDuration = h, this.isVideoContiguous = !0;
    const R = H.moof(e.sequenceNumber++, p, et({}, e, {
      samples: a
    })), B = "video", D = {
      data1: R,
      data2: w,
      startPTS: g / s,
      endPTS: (m + h) / s,
      startDTS: p / s,
      endDTS: c / s,
      type: B,
      hasAudio: !1,
      hasVideo: !0,
      nb: a.length,
      dropped: e.dropped
    };
    return e.samples = [], e.dropped = 0, D;
  }
  remuxAudio(e, t, r, n, s) {
    const o = e.inputTimeScale, a = e.samplerate ? e.samplerate : o, l = o / a, u = e.segmentCodec === "aac" ? va : Qy, c = u * l, d = this._initPTS, h = e.segmentCodec === "mp3" && this.typeSupported.mpeg, p = [], f = s !== void 0;
    let g = e.samples, m = h ? 0 : 8, v = this.nextAudioPts || -1;
    const E = t * o, A = d.baseTime * o / d.timescale;
    if (this.isAudioContiguous = r = r || g.length && v > 0 && (n && Math.abs(E - v) < 9e3 || Math.abs(Ct(g[0].pts - A, E) - v) < 20 * c), g.forEach(function(B) {
      B.pts = Ct(B.pts - A, E);
    }), !r || v < 0) {
      if (g = g.filter((B) => B.pts >= 0), !g.length)
        return;
      s === 0 ? v = 0 : n && !f ? v = Math.max(0, E) : v = g[0].pts;
    }
    if (e.segmentCodec === "aac") {
      const B = this.config.maxAudioFramesDrift;
      for (let D = 0, k = v; D < g.length; D++) {
        const F = g[D], U = F.pts, G = U - k, N = Math.abs(1e3 * G / o);
        if (G <= -B * c && f)
          D === 0 && (K.warn(`Audio frame @ ${(U / o).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * G / o)} ms.`), this.nextAudioPts = v = k = U);
        else if (G >= B * c && N < Wy && f) {
          let V = Math.round(G / c);
          k = U - V * c, k < 0 && (V--, k += c), D === 0 && (this.nextAudioPts = v = k), K.warn(`[mp4-remuxer]: Injecting ${V} audio frame @ ${(k / o).toFixed(3)}s due to ${Math.round(1e3 * G / o)} ms gap.`);
          for (let j = 0; j < V; j++) {
            const ee = Math.max(k, 0);
            let Y = ma.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
            Y || (K.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), Y = F.unit.subarray()), g.splice(D, 0, {
              unit: Y,
              pts: ee
            }), k += c, D++;
          }
        }
        F.pts = k, k += c;
      }
    }
    let _ = null, y = null, S, b = 0, w = g.length;
    for (; w--; )
      b += g[w].unit.byteLength;
    for (let B = 0, D = g.length; B < D; B++) {
      const k = g[B], F = k.unit;
      let U = k.pts;
      if (y !== null) {
        const N = p[B - 1];
        N.duration = Math.round((U - y) / l);
      } else if (r && e.segmentCodec === "aac" && (U = v), _ = U, b > 0) {
        b += m;
        try {
          S = new Uint8Array(b);
        } catch (N) {
          this.observer.emit(O.ERROR, O.ERROR, {
            type: fe.MUX_ERROR,
            details: W.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: N,
            bytes: b,
            reason: `fail allocating audio mdat ${b}`
          });
          return;
        }
        h || (new DataView(S.buffer).setUint32(0, b), S.set(H.types.mdat, 4));
      } else
        return;
      S.set(F, m);
      const G = F.byteLength;
      m += G, p.push(new ya(!0, u, G, 0)), y = U;
    }
    const P = p.length;
    if (!P)
      return;
    const C = p[p.length - 1];
    this.nextAudioPts = v = y + l * C.duration;
    const T = h ? new Uint8Array(0) : H.moof(e.sequenceNumber++, _ / l, et({}, e, {
      samples: p
    }));
    e.samples = [];
    const x = _ / o, L = v / o, R = {
      data1: T,
      data2: S,
      startPTS: x,
      endPTS: L,
      startDTS: x,
      endDTS: L,
      type: "audio",
      hasAudio: !0,
      hasVideo: !1,
      nb: P
    };
    return this.isAudioContiguous = !0, R;
  }
  remuxEmptyAudio(e, t, r, n) {
    const s = e.inputTimeScale, o = e.samplerate ? e.samplerate : s, a = s / o, l = this.nextAudioPts, u = this._initDTS, c = u.baseTime * 9e4 / u.timescale, d = (l !== null ? l : n.startDTS * s) + c, h = n.endDTS * s + c, p = a * va, f = Math.ceil((h - d) / p), g = ma.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
    if (K.warn("[mp4-remuxer]: remux empty Audio"), !g) {
      K.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
      return;
    }
    const m = [];
    for (let v = 0; v < f; v++) {
      const E = d + v * p;
      m.push({
        unit: g,
        pts: E,
        dts: E
      });
    }
    return e.samples = m, this.remuxAudio(e, t, r, !1);
  }
}
function Ct(i, e) {
  let t;
  if (e === null)
    return i;
  for (e < i ? t = -8589934592 : t = 8589934592; Math.abs(i - e) > 4294967296; )
    i += t;
  return i;
}
function Jy(i) {
  for (let e = 0; e < i.length; e++)
    if (i[e].key)
      return e;
  return -1;
}
function uu(i, e, t, r) {
  const n = i.samples.length;
  if (!n)
    return;
  const s = i.inputTimeScale;
  for (let a = 0; a < n; a++) {
    const l = i.samples[a];
    l.pts = Ct(l.pts - t.baseTime * 9e4 / t.timescale, e * s) / s, l.dts = Ct(l.dts - r.baseTime * 9e4 / r.timescale, e * s) / s;
  }
  const o = i.samples;
  return i.samples = [], {
    samples: o
  };
}
function cu(i, e, t) {
  const r = i.samples.length;
  if (!r)
    return;
  const n = i.inputTimeScale;
  for (let o = 0; o < r; o++) {
    const a = i.samples[o];
    a.pts = Ct(a.pts - t.baseTime * 9e4 / t.timescale, e * n) / n;
  }
  i.samples.sort((o, a) => o.pts - a.pts);
  const s = i.samples;
  return i.samples = [], {
    samples: s
  };
}
class ya {
  constructor(e, t, r, n) {
    this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = r, this.cts = n, this.flags = new Yy(e);
  }
}
class Yy {
  constructor(e) {
    this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = e ? 2 : 1, this.isNonSync = e ? 0 : 1;
  }
}
class zy {
  constructor() {
    this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null;
  }
  destroy() {
  }
  resetTimeStamp(e) {
    this.initPTS = e, this.lastEndTime = null;
  }
  resetNextTimestamp() {
    this.lastEndTime = null;
  }
  resetInitSegment(e, t, r, n) {
    this.audioCodec = t, this.videoCodec = r, this.generateInitSegment(gv(e, n)), this.emitInitSegment = !0;
  }
  generateInitSegment(e) {
    let {
      audioCodec: t,
      videoCodec: r
    } = this;
    if (!(e != null && e.byteLength)) {
      this.initTracks = void 0, this.initData = void 0;
      return;
    }
    const n = this.initData = Ul(e);
    t || (t = Ea(n.audio, Ke.AUDIO)), r || (r = Ea(n.video, Ke.VIDEO));
    const s = {};
    n.audio && n.video ? s.audiovideo = {
      container: "video/mp4",
      codec: t + "," + r,
      initSegment: e,
      id: "main"
    } : n.audio ? s.audio = {
      container: "audio/mp4",
      codec: t,
      initSegment: e,
      id: "audio"
    } : n.video ? s.video = {
      container: "video/mp4",
      codec: r,
      initSegment: e,
      id: "main"
    } : K.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = s;
  }
  remux(e, t, r, n, s, o) {
    var a, l;
    let {
      initPTS: u,
      lastEndTime: c
    } = this;
    const d = {
      audio: void 0,
      video: void 0,
      text: n,
      id3: r,
      initSegment: void 0
    };
    de(c) || (c = this.lastEndTime = s || 0);
    const h = t.samples;
    if (!(h != null && h.length))
      return d;
    const p = {
      initPTS: void 0,
      timescale: 1
    };
    let f = this.initData;
    if ((a = f) != null && a.length || (this.generateInitSegment(h), f = this.initData), !((l = f) != null && l.length))
      return K.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), d;
    this.emitInitSegment && (p.tracks = this.initTracks, this.emitInitSegment = !1);
    const g = vv(h, f), m = mv(f, h), v = m === null ? s : m;
    (qy(u, v, s, g) || p.timescale !== u.timescale && o) && (p.initPTS = v - s, u && u.timescale === 1 && K.warn(`Adjusting initPTS by ${p.initPTS - u.baseTime}`), this.initPTS = u = {
      baseTime: p.initPTS,
      timescale: 1
    });
    const E = e ? v - u.baseTime / u.timescale : c, A = E + g;
    Ev(f, h, u.baseTime / u.timescale), g > 0 ? this.lastEndTime = A : (K.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
    const _ = !!f.audio, y = !!f.video;
    let S = "";
    _ && (S += "audio"), y && (S += "video");
    const b = {
      data1: h,
      startPTS: E,
      startDTS: E,
      endPTS: A,
      endDTS: A,
      type: S,
      hasAudio: _,
      hasVideo: y,
      nb: 1,
      dropped: 0
    };
    return d.audio = b.type === "audio" ? b : void 0, d.video = b.type !== "audio" ? b : void 0, d.initSegment = p, d.id3 = uu(r, s, u, u), n.samples.length && (d.text = cu(n, s, u)), d;
  }
}
function qy(i, e, t, r) {
  if (i === null)
    return !0;
  const n = Math.max(r, 1), s = e - i.baseTime / i.timescale;
  return Math.abs(s - t) > n;
}
function Ea(i, e) {
  const t = i == null ? void 0 : i.codec;
  return t && t.length > 4 ? t : t === "hvc1" || t === "hev1" ? "hvc1.1.6.L120.90" : t === "av01" ? "av01.0.04M.08" : t === "avc1" || e === Ke.VIDEO ? "avc1.42e01e" : "mp4a.40.5";
}
let tr;
try {
  tr = self.performance.now.bind(self.performance);
} catch {
  K.debug("Unable to use Performance API on this environment"), tr = typeof self < "u" && self.Date.now;
}
const Fn = [{
  demux: Dy,
  remux: zy
}, {
  demux: lr,
  remux: Bn
}, {
  demux: wy,
  remux: Bn
}, {
  demux: Vy,
  remux: Bn
}];
class Aa {
  constructor(e, t, r, n, s) {
    this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = r, this.vendor = n, this.id = s;
  }
  configure(e) {
    this.transmuxConfig = e, this.decrypter && this.decrypter.reset();
  }
  push(e, t, r, n) {
    const s = r.transmuxing;
    s.executeStart = tr();
    let o = new Uint8Array(e);
    const {
      currentTransmuxState: a,
      transmuxConfig: l
    } = this;
    n && (this.currentTransmuxState = n);
    const {
      contiguous: u,
      discontinuity: c,
      trackSwitch: d,
      accurateTimeOffset: h,
      timeOffset: p,
      initSegmentChange: f
    } = n || a, {
      audioCodec: g,
      videoCodec: m,
      defaultInitPts: v,
      duration: E,
      initSegmentData: A
    } = l, _ = Zy(o, t);
    if (_ && _.method === "AES-128") {
      const w = this.getDecrypter();
      if (w.isSync()) {
        let P = w.softwareDecrypt(o, _.key.buffer, _.iv.buffer);
        if (r.part > -1 && (P = w.flush()), !P)
          return s.executeEnd = tr(), Nn(r);
        o = new Uint8Array(P);
      } else
        return this.decryptionPromise = w.webCryptoDecrypt(o, _.key.buffer, _.iv.buffer).then((P) => {
          const C = this.push(P, null, r);
          return this.decryptionPromise = null, C;
        }), this.decryptionPromise;
    }
    const y = this.needsProbing(c, d);
    if (y) {
      const w = this.configureTransmuxer(o);
      if (w)
        return K.warn(`[transmuxer] ${w.message}`), this.observer.emit(O.ERROR, O.ERROR, {
          type: fe.MEDIA_ERROR,
          details: W.FRAG_PARSING_ERROR,
          fatal: !1,
          error: w,
          reason: w.message
        }), s.executeEnd = tr(), Nn(r);
    }
    (c || d || f || y) && this.resetInitSegment(A, g, m, E, t), (c || f || y) && this.resetInitialTimestamp(v), u || this.resetContiguity();
    const S = this.transmux(o, _, p, h, r), b = this.currentTransmuxState;
    return b.contiguous = !0, b.discontinuity = !1, b.trackSwitch = !1, s.executeEnd = tr(), S;
  }
  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
  flush(e) {
    const t = e.transmuxing;
    t.executeStart = tr();
    const {
      decrypter: r,
      currentTransmuxState: n,
      decryptionPromise: s
    } = this;
    if (s)
      return s.then(() => this.flush(e));
    const o = [], {
      timeOffset: a
    } = n;
    if (r) {
      const d = r.flush();
      d && o.push(this.push(d, null, e));
    }
    const {
      demuxer: l,
      remuxer: u
    } = this;
    if (!l || !u)
      return t.executeEnd = tr(), [Nn(e)];
    const c = l.flush(a);
    return Gi(c) ? c.then((d) => (this.flushRemux(o, d, e), o)) : (this.flushRemux(o, c, e), o);
  }
  flushRemux(e, t, r) {
    const {
      audioTrack: n,
      videoTrack: s,
      id3Track: o,
      textTrack: a
    } = t, {
      accurateTimeOffset: l,
      timeOffset: u
    } = this.currentTransmuxState;
    K.log(`[transmuxer.ts]: Flushed fragment ${r.sn}${r.part > -1 ? " p: " + r.part : ""} of level ${r.level}`);
    const c = this.remuxer.remux(n, s, o, a, u, l, !0, this.id);
    e.push({
      remuxResult: c,
      chunkMeta: r
    }), r.transmuxing.executeEnd = tr();
  }
  resetInitialTimestamp(e) {
    const {
      demuxer: t,
      remuxer: r
    } = this;
    !t || !r || (t.resetTimeStamp(e), r.resetTimeStamp(e));
  }
  resetContiguity() {
    const {
      demuxer: e,
      remuxer: t
    } = this;
    !e || !t || (e.resetContiguity(), t.resetNextTimestamp());
  }
  resetInitSegment(e, t, r, n, s) {
    const {
      demuxer: o,
      remuxer: a
    } = this;
    !o || !a || (o.resetInitSegment(e, t, r, n), a.resetInitSegment(e, t, r, s));
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);
  }
  transmux(e, t, r, n, s) {
    let o;
    return t && t.method === "SAMPLE-AES" ? o = this.transmuxSampleAes(e, t, r, n, s) : o = this.transmuxUnencrypted(e, r, n, s), o;
  }
  transmuxUnencrypted(e, t, r, n) {
    const {
      audioTrack: s,
      videoTrack: o,
      id3Track: a,
      textTrack: l
    } = this.demuxer.demux(e, t, !1, !this.config.progressive);
    return {
      remuxResult: this.remuxer.remux(s, o, a, l, t, r, !1, this.id),
      chunkMeta: n
    };
  }
  transmuxSampleAes(e, t, r, n, s) {
    return this.demuxer.demuxSampleAes(e, t, r).then((o) => ({
      remuxResult: this.remuxer.remux(o.audioTrack, o.videoTrack, o.id3Track, o.textTrack, r, n, !1, this.id),
      chunkMeta: s
    }));
  }
  configureTransmuxer(e) {
    const {
      config: t,
      observer: r,
      typeSupported: n,
      vendor: s
    } = this;
    let o;
    for (let d = 0, h = Fn.length; d < h; d++)
      if (Fn[d].demux.probe(e)) {
        o = Fn[d];
        break;
      }
    if (!o)
      return new Error("Failed to find demuxer by probing fragment data");
    const a = this.demuxer, l = this.remuxer, u = o.remux, c = o.demux;
    (!l || !(l instanceof u)) && (this.remuxer = new u(r, t, n, s)), (!a || !(a instanceof c)) && (this.demuxer = new c(r, t, n), this.probe = c.probe);
  }
  needsProbing(e, t) {
    return !this.demuxer || !this.remuxer || e || t;
  }
  getDecrypter() {
    let e = this.decrypter;
    return e || (e = this.decrypter = new Us(this.config)), e;
  }
}
function Zy(i, e) {
  let t = null;
  return i.byteLength > 0 && e != null && e.key != null && e.iv !== null && e.method != null && (t = e), t;
}
const Nn = (i) => ({
  remuxResult: {},
  chunkMeta: i
});
function Gi(i) {
  return "then" in i && i.then instanceof Function;
}
class Xy {
  constructor(e, t, r, n, s) {
    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = r, this.duration = n, this.defaultInitPts = s || null;
  }
}
class $y {
  constructor(e, t, r, n, s, o) {
    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = r, this.trackSwitch = n, this.timeOffset = s, this.initSegmentChange = o;
  }
}
var du = { exports: {} };
(function(i) {
  var e = Object.prototype.hasOwnProperty, t = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = !1));
  function n(l, u, c) {
    this.fn = l, this.context = u, this.once = c || !1;
  }
  function s(l, u, c, d, h) {
    if (typeof c != "function")
      throw new TypeError("The listener must be a function");
    var p = new n(c, d || l, h), f = t ? t + u : u;
    return l._events[f] ? l._events[f].fn ? l._events[f] = [l._events[f], p] : l._events[f].push(p) : (l._events[f] = p, l._eventsCount++), l;
  }
  function o(l, u) {
    --l._eventsCount === 0 ? l._events = new r() : delete l._events[u];
  }
  function a() {
    this._events = new r(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var u = [], c, d;
    if (this._eventsCount === 0)
      return u;
    for (d in c = this._events)
      e.call(c, d) && u.push(t ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u;
  }, a.prototype.listeners = function(u) {
    var c = t ? t + u : u, d = this._events[c];
    if (!d)
      return [];
    if (d.fn)
      return [d.fn];
    for (var h = 0, p = d.length, f = new Array(p); h < p; h++)
      f[h] = d[h].fn;
    return f;
  }, a.prototype.listenerCount = function(u) {
    var c = t ? t + u : u, d = this._events[c];
    return d ? d.fn ? 1 : d.length : 0;
  }, a.prototype.emit = function(u, c, d, h, p, f) {
    var g = t ? t + u : u;
    if (!this._events[g])
      return !1;
    var m = this._events[g], v = arguments.length, E, A;
    if (m.fn) {
      switch (m.once && this.removeListener(u, m.fn, void 0, !0), v) {
        case 1:
          return m.fn.call(m.context), !0;
        case 2:
          return m.fn.call(m.context, c), !0;
        case 3:
          return m.fn.call(m.context, c, d), !0;
        case 4:
          return m.fn.call(m.context, c, d, h), !0;
        case 5:
          return m.fn.call(m.context, c, d, h, p), !0;
        case 6:
          return m.fn.call(m.context, c, d, h, p, f), !0;
      }
      for (A = 1, E = new Array(v - 1); A < v; A++)
        E[A - 1] = arguments[A];
      m.fn.apply(m.context, E);
    } else {
      var _ = m.length, y;
      for (A = 0; A < _; A++)
        switch (m[A].once && this.removeListener(u, m[A].fn, void 0, !0), v) {
          case 1:
            m[A].fn.call(m[A].context);
            break;
          case 2:
            m[A].fn.call(m[A].context, c);
            break;
          case 3:
            m[A].fn.call(m[A].context, c, d);
            break;
          case 4:
            m[A].fn.call(m[A].context, c, d, h);
            break;
          default:
            if (!E)
              for (y = 1, E = new Array(v - 1); y < v; y++)
                E[y - 1] = arguments[y];
            m[A].fn.apply(m[A].context, E);
        }
    }
    return !0;
  }, a.prototype.on = function(u, c, d) {
    return s(this, u, c, d, !1);
  }, a.prototype.once = function(u, c, d) {
    return s(this, u, c, d, !0);
  }, a.prototype.removeListener = function(u, c, d, h) {
    var p = t ? t + u : u;
    if (!this._events[p])
      return this;
    if (!c)
      return o(this, p), this;
    var f = this._events[p];
    if (f.fn)
      f.fn === c && (!h || f.once) && (!d || f.context === d) && o(this, p);
    else {
      for (var g = 0, m = [], v = f.length; g < v; g++)
        (f[g].fn !== c || h && !f[g].once || d && f[g].context !== d) && m.push(f[g]);
      m.length ? this._events[p] = m.length === 1 ? m[0] : m : o(this, p);
    }
    return this;
  }, a.prototype.removeAllListeners = function(u) {
    var c;
    return u ? (c = t ? t + u : u, this._events[c] && o(this, c)) : (this._events = new r(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, i.exports = a;
})(du);
var eE = du.exports, js = /* @__PURE__ */ Um(eE);
const Un = hn() || {
  isTypeSupported: () => !1
};
class hu {
  constructor(e, t, r, n) {
    this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
    const s = e.config;
    this.hls = e, this.id = t, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = r, this.onFlush = n;
    const o = (u, c) => {
      c = c || {}, c.frag = this.frag, c.id = this.id, u === O.ERROR && (this.error = c.error), this.hls.trigger(u, c);
    };
    this.observer = new js(), this.observer.on(O.FRAG_DECRYPTED, o), this.observer.on(O.ERROR, o);
    const a = {
      mp4: Un.isTypeSupported("video/mp4"),
      mpeg: Un.isTypeSupported("audio/mpeg"),
      mp3: Un.isTypeSupported('audio/mp4; codecs="mp3"')
    }, l = navigator.vendor;
    if (this.useWorker && typeof Worker < "u" && (s.workerPath || _y())) {
      try {
        s.workerPath ? (K.log(`loading Web Worker ${s.workerPath} for "${t}"`), this.workerContext = Sy(s.workerPath)) : (K.log(`injecting Web Worker for "${t}"`), this.workerContext = xy()), this.onwmsg = (d) => this.onWorkerMessage(d);
        const {
          worker: c
        } = this.workerContext;
        c.addEventListener("message", this.onwmsg), c.onerror = (d) => {
          const h = new Error(`${d.message}  (${d.filename}:${d.lineno})`);
          s.enableWorker = !1, K.warn(`Error in "${t}" Web Worker, fallback to inline`), this.hls.trigger(O.ERROR, {
            type: fe.OTHER_ERROR,
            details: W.INTERNAL_EXCEPTION,
            fatal: !1,
            event: "demuxerWorker",
            error: h
          });
        }, c.postMessage({
          cmd: "init",
          typeSupported: a,
          vendor: l,
          id: t,
          config: JSON.stringify(s)
        });
      } catch (c) {
        K.warn(`Error setting up "${t}" Web Worker, fallback to inline`, c), this.resetWorker(), this.error = null, this.transmuxer = new Aa(this.observer, a, s, l, t);
      }
      return;
    }
    this.transmuxer = new Aa(this.observer, a, s, l, t);
  }
  resetWorker() {
    if (this.workerContext) {
      const {
        worker: e,
        objectURL: t
      } = this.workerContext;
      t && self.URL.revokeObjectURL(t), e.removeEventListener("message", this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null;
    }
  }
  destroy() {
    if (this.workerContext)
      this.resetWorker(), this.onwmsg = void 0;
    else {
      const t = this.transmuxer;
      t && (t.destroy(), this.transmuxer = null);
    }
    const e = this.observer;
    e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null;
  }
  push(e, t, r, n, s, o, a, l, u, c) {
    var d, h;
    u.transmuxing.start = self.performance.now();
    const {
      transmuxer: p
    } = this, f = o ? o.start : s.start, g = s.decryptdata, m = this.frag, v = !(m && s.cc === m.cc), E = !(m && u.level === m.level), A = m ? u.sn - m.sn : -1, _ = this.part ? u.part - this.part.index : -1, y = A === 0 && u.id > 1 && u.id === (m == null ? void 0 : m.stats.chunkCount), S = !E && (A === 1 || A === 0 && (_ === 1 || y && _ <= 0)), b = self.performance.now();
    (E || A || s.stats.parsing.start === 0) && (s.stats.parsing.start = b), o && (_ || !S) && (o.stats.parsing.start = b);
    const w = !(m && ((d = s.initSegment) == null ? void 0 : d.url) === ((h = m.initSegment) == null ? void 0 : h.url)), P = new $y(v, S, l, E, f, w);
    if (!S || v || w) {
      K.log(`[transmuxer-interface, ${s.type}]: Starting new transmux session for sn: ${u.sn} p: ${u.part} level: ${u.level} id: ${u.id}
        discontinuity: ${v}
        trackSwitch: ${E}
        contiguous: ${S}
        accurateTimeOffset: ${l}
        timeOffset: ${f}
        initSegmentChange: ${w}`);
      const C = new Xy(r, n, t, a, c);
      this.configureTransmuxer(C);
    }
    if (this.frag = s, this.part = o, this.workerContext)
      this.workerContext.worker.postMessage({
        cmd: "demux",
        data: e,
        decryptdata: g,
        chunkMeta: u,
        state: P
      }, e instanceof ArrayBuffer ? [e] : []);
    else if (p) {
      const C = p.push(e, g, u, P);
      Gi(C) ? (p.async = !0, C.then((T) => {
        this.handleTransmuxComplete(T);
      }).catch((T) => {
        this.transmuxerError(T, u, "transmuxer-interface push error");
      })) : (p.async = !1, this.handleTransmuxComplete(C));
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now();
    const {
      transmuxer: t
    } = this;
    if (this.workerContext)
      this.workerContext.worker.postMessage({
        cmd: "flush",
        chunkMeta: e
      });
    else if (t) {
      let r = t.flush(e);
      Gi(r) || t.async ? (Gi(r) || (r = Promise.resolve(r)), r.then((s) => {
        this.handleFlushResult(s, e);
      }).catch((s) => {
        this.transmuxerError(s, e, "transmuxer-interface flush error");
      })) : this.handleFlushResult(r, e);
    }
  }
  transmuxerError(e, t, r) {
    this.hls && (this.error = e, this.hls.trigger(O.ERROR, {
      type: fe.MEDIA_ERROR,
      details: W.FRAG_PARSING_ERROR,
      chunkMeta: t,
      fatal: !1,
      error: e,
      err: e,
      reason: r
    }));
  }
  handleFlushResult(e, t) {
    e.forEach((r) => {
      this.handleTransmuxComplete(r);
    }), this.onFlush(t);
  }
  onWorkerMessage(e) {
    const t = e.data, r = this.hls;
    switch (t.event) {
      case "init": {
        var n;
        const s = (n = this.workerContext) == null ? void 0 : n.objectURL;
        s && self.URL.revokeObjectURL(s);
        break;
      }
      case "transmuxComplete": {
        this.handleTransmuxComplete(t.data);
        break;
      }
      case "flush": {
        this.onFlush(t.data);
        break;
      }
      case "workerLog":
        K[t.data.logType] && K[t.data.logType](t.data.message);
        break;
      default: {
        t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data);
        break;
      }
    }
  }
  configureTransmuxer(e) {
    const {
      transmuxer: t
    } = this;
    this.workerContext ? this.workerContext.worker.postMessage({
      cmd: "configure",
      config: e
    }) : t && t.configure(e);
  }
  handleTransmuxComplete(e) {
    e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e);
  }
}
const tE = 250, Kn = 2, rE = 0.1, iE = 0.05;
class nE {
  constructor(e, t, r, n) {
    this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = r, this.hls = n;
  }
  destroy() {
    this.media = null, this.hls = this.fragmentTracker = null;
  }
  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   *
   * @param lastCurrentTime - Previously read playhead position
   */
  poll(e, t) {
    const {
      config: r,
      media: n,
      stalled: s
    } = this;
    if (n === null)
      return;
    const {
      currentTime: o,
      seeking: a
    } = n, l = this.seeking && !a, u = !this.seeking && a;
    if (this.seeking = a, o !== e) {
      if (this.moved = !0, s !== null) {
        if (this.stallReported) {
          const v = self.performance.now() - s;
          K.warn(`playback not stuck anymore @${o}, after ${Math.round(v)}ms`), this.stallReported = !1;
        }
        this.stalled = null, this.nudgeRetry = 0;
      }
      return;
    }
    if (u || l) {
      this.stalled = null;
      return;
    }
    if (n.paused && !a || n.ended || n.playbackRate === 0 || !je.getBuffered(n).length)
      return;
    const c = je.bufferInfo(n, o, 0), d = c.len > 0, h = c.nextStart || 0;
    if (!d && !h)
      return;
    if (a) {
      const v = c.len > Kn, E = !h || t && t.start <= o || h - o > Kn && !this.fragmentTracker.getPartialFragment(o);
      if (v || E)
        return;
      this.moved = !1;
    }
    if (!this.moved && this.stalled !== null) {
      var p;
      const v = Math.max(h, c.start || 0) - o, E = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null, _ = (E == null || (p = E.details) == null ? void 0 : p.live) ? E.details.targetduration * 2 : Kn, y = this.fragmentTracker.getPartialFragment(o);
      if (v > 0 && (v <= _ || y)) {
        this._trySkipBufferHole(y);
        return;
      }
    }
    const f = self.performance.now();
    if (s === null) {
      this.stalled = f;
      return;
    }
    const g = f - s;
    if (!a && g >= tE && (this._reportStall(c), !this.media))
      return;
    const m = je.bufferInfo(n, o, r.maxBufferHole);
    this._tryFixBufferStall(m, g);
  }
  /**
   * Detects and attempts to fix known buffer stalling issues.
   * @param bufferInfo - The properties of the current buffer.
   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
   * @private
   */
  _tryFixBufferStall(e, t) {
    const {
      config: r,
      fragmentTracker: n,
      media: s
    } = this;
    if (s === null)
      return;
    const o = s.currentTime, a = n.getPartialFragment(o);
    a && (this._trySkipBufferHole(a) || !this.media) || (e.len > r.maxBufferHole || e.nextStart && e.nextStart - o < r.maxBufferHole) && t > r.highBufferWatchdogPeriod * 1e3 && (K.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer());
  }
  /**
   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
   * @param bufferLen - The playhead distance from the end of the current buffer segment.
   * @private
   */
  _reportStall(e) {
    const {
      hls: t,
      media: r,
      stallReported: n
    } = this;
    if (!n && r) {
      this.stallReported = !0;
      const s = new Error(`Playback stalling at @${r.currentTime} due to low buffer (${JSON.stringify(e)})`);
      K.warn(s.message), t.trigger(O.ERROR, {
        type: fe.MEDIA_ERROR,
        details: W.BUFFER_STALLED_ERROR,
        fatal: !1,
        error: s,
        buffer: e.len
      });
    }
  }
  /**
   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
   * @param partial - The partial fragment found at the current time (where playback is stalling).
   * @private
   */
  _trySkipBufferHole(e) {
    const {
      config: t,
      hls: r,
      media: n
    } = this;
    if (n === null)
      return 0;
    const s = n.currentTime, o = je.bufferInfo(n, s, 0), a = s < o.start ? o.start : o.nextStart;
    if (a) {
      const l = o.len <= t.maxBufferHole, u = o.len > 0 && o.len < 1 && n.readyState < 3, c = a - s;
      if (c > 0 && (l || u)) {
        if (c > t.maxBufferHole) {
          const {
            fragmentTracker: h
          } = this;
          let p = !1;
          if (s === 0) {
            const f = h.getAppendedFrag(0, ge.MAIN);
            f && a < f.end && (p = !0);
          }
          if (!p) {
            const f = e || h.getAppendedFrag(s, ge.MAIN);
            if (f) {
              let g = !1, m = f.end;
              for (; m < a; ) {
                const v = h.getPartialFragment(m);
                if (v)
                  m += v.duration;
                else {
                  g = !0;
                  break;
                }
              }
              if (g)
                return 0;
            }
          }
        }
        const d = Math.max(a + iE, s + rE);
        if (K.warn(`skipping hole, adjusting currentTime from ${s} to ${d}`), this.moved = !0, this.stalled = null, n.currentTime = d, e && !e.gap) {
          const h = new Error(`fragment loaded with buffer holes, seeking from ${s} to ${d}`);
          r.trigger(O.ERROR, {
            type: fe.MEDIA_ERROR,
            details: W.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: h,
            reason: h.message,
            frag: e
          });
        }
        return d;
      }
    }
    return 0;
  }
  /**
   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
   * @private
   */
  _tryNudgeBuffer() {
    const {
      config: e,
      hls: t,
      media: r,
      nudgeRetry: n
    } = this;
    if (r === null)
      return;
    const s = r.currentTime;
    if (this.nudgeRetry++, n < e.nudgeMaxRetry) {
      const o = s + (n + 1) * e.nudgeOffset, a = new Error(`Nudging 'currentTime' from ${s} to ${o}`);
      K.warn(a.message), r.currentTime = o, t.trigger(O.ERROR, {
        type: fe.MEDIA_ERROR,
        details: W.BUFFER_NUDGE_ON_STALL,
        error: a,
        fatal: !1
      });
    } else {
      const o = new Error(`Playhead still not moving while enough data buffered @${s} after ${e.nudgeMaxRetry} nudges`);
      K.error(o.message), t.trigger(O.ERROR, {
        type: fe.MEDIA_ERROR,
        details: W.BUFFER_STALLED_ERROR,
        error: o,
        fatal: !0
      });
    }
  }
}
const sE = 100;
class oE extends Ks {
  constructor(e, t, r) {
    super(e, t, r, "[stream-controller]", ge.MAIN), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.MANIFEST_PARSED, this.onManifestParsed, this), e.on(O.LEVEL_LOADING, this.onLevelLoading, this), e.on(O.LEVEL_LOADED, this.onLevelLoaded, this), e.on(O.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(O.ERROR, this.onError, this), e.on(O.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(O.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(O.BUFFER_CREATED, this.onBufferCreated, this), e.on(O.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(O.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(O.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.MANIFEST_PARSED, this.onManifestParsed, this), e.off(O.LEVEL_LOADED, this.onLevelLoaded, this), e.off(O.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(O.ERROR, this.onError, this), e.off(O.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(O.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(O.BUFFER_CREATED, this.onBufferCreated, this), e.off(O.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(O.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(O.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onHandlerDestroying() {
    this._unregisterListeners(), this.onMediaDetaching();
  }
  startLoad(e) {
    if (this.levels) {
      const {
        lastCurrentTime: t,
        hls: r
      } = this;
      if (this.stopLoad(), this.setInterval(sE), this.level = -1, !this.startFragRequested) {
        let n = r.startLevel;
        n === -1 && (r.config.testBandwidth && this.levels.length > 1 ? (n = 0, this.bitrateTest = !0) : n = r.nextAutoLevel), this.level = r.nextLoadLevel = n, this.loadedmetadata = !1;
      }
      t > 0 && e === -1 && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t), this.state = z.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick();
    } else
      this._forceStartLoad = !0, this.state = z.STOPPED;
  }
  stopLoad() {
    this._forceStartLoad = !1, super.stopLoad();
  }
  doTick() {
    switch (this.state) {
      case z.WAITING_LEVEL: {
        var e;
        const {
          levels: r,
          level: n
        } = this, s = r == null || (e = r[n]) == null ? void 0 : e.details;
        if (s && (!s.live || this.levelLastLoaded === this.level)) {
          if (this.waitForCdnTuneIn(s))
            break;
          this.state = z.IDLE;
          break;
        }
        break;
      }
      case z.FRAG_LOADING_WAITING_RETRY:
        {
          var t;
          const r = self.performance.now(), n = this.retryDate;
          (!n || r >= n || (t = this.media) != null && t.seeking) && (this.resetStartWhenNotLoaded(this.level), this.state = z.IDLE);
        }
        break;
    }
    this.state === z.IDLE && this.doTickIdle(), this.onTickEnd();
  }
  onTickEnd() {
    super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged();
  }
  doTickIdle() {
    const {
      hls: e,
      levelLastLoaded: t,
      levels: r,
      media: n
    } = this, {
      config: s,
      nextLoadLevel: o
    } = e;
    if (t === null || !n && (this.startFragRequested || !s.startFragPrefetch) || this.altAudio && this.audioOnly || !(r != null && r[o]))
      return;
    const a = r[o], l = this.getMainFwdBufferInfo();
    if (l === null)
      return;
    const u = this.getLevelDetails();
    if (u && this._streamEnded(l, u)) {
      const m = {};
      this.altAudio && (m.type = "video"), this.hls.trigger(O.BUFFER_EOS, m), this.state = z.ENDED;
      return;
    }
    e.loadLevel !== o && e.manualLevel === -1 && this.log(`Adapting to level ${o} from level ${this.level}`), this.level = e.nextLoadLevel = o;
    const c = a.details;
    if (!c || this.state === z.WAITING_LEVEL || c.live && this.levelLastLoaded !== o) {
      this.level = o, this.state = z.WAITING_LEVEL;
      return;
    }
    const d = l.len, h = this.getMaxBufferLength(a.maxBitrate);
    if (d >= h)
      return;
    this.backtrackFragment && this.backtrackFragment.start > l.end && (this.backtrackFragment = null);
    const p = this.backtrackFragment ? this.backtrackFragment.start : l.end;
    let f = this.getNextFragment(p, c);
    if (this.couldBacktrack && !this.fragPrevious && f && f.sn !== "initSegment" && this.fragmentTracker.getState(f) !== at.OK) {
      var g;
      const v = ((g = this.backtrackFragment) != null ? g : f).sn - c.startSN, E = c.fragments[v - 1];
      E && f.cc === E.cc && (f = E, this.fragmentTracker.removeFragment(E));
    } else
      this.backtrackFragment && l.len && (this.backtrackFragment = null);
    if (f && this.isLoopLoading(f, p)) {
      if (!f.gap) {
        const v = this.audioOnly && !this.altAudio ? Ke.AUDIO : Ke.VIDEO, E = (v === Ke.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        E && this.afterBufferFlushed(E, v, ge.MAIN);
      }
      f = this.getNextFragmentLoopLoading(f, c, l, ge.MAIN, h);
    }
    f && (f.initSegment && !f.initSegment.data && !this.bitrateTest && (f = f.initSegment), this.loadFragment(f, a, p));
  }
  loadFragment(e, t, r) {
    const n = this.fragmentTracker.getState(e);
    this.fragCurrent = e, n === at.NOT_LOADED || n === at.PARTIAL ? e.sn === "initSegment" ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, super.loadFragment(e, t, r)) : this.clearTrackerIfNeeded(e);
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, ge.MAIN);
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + 0.5) : null;
  }
  /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */
  immediateLevelSwitch() {
    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  /**
   * try to switch ASAP without breaking video playback:
   * in order to ensure smooth but quick level switching,
   * we need to find the next flushable buffer range
   * we should take into account new segment fetch time
   */
  nextLevelSwitch() {
    const {
      levels: e,
      media: t
    } = this;
    if (t != null && t.readyState) {
      let r;
      const n = this.getAppendedFrag(t.currentTime);
      n && n.start > 1 && this.flushMainBuffer(0, n.start - 1);
      const s = this.getLevelDetails();
      if (s != null && s.live) {
        const a = this.getMainFwdBufferInfo();
        if (!a || a.len < s.targetduration * 2)
          return;
      }
      if (!t.paused && e) {
        const a = this.hls.nextLoadLevel, l = e[a], u = this.fragLastKbps;
        u && this.fragCurrent ? r = this.fragCurrent.duration * l.maxBitrate / (1e3 * u) + 1 : r = 0;
      } else
        r = 0;
      const o = this.getBufferedFrag(t.currentTime + r);
      if (o) {
        const a = this.followingBufferedFrag(o);
        if (a) {
          this.abortCurrentFrag();
          const l = a.maxStartPTS ? a.maxStartPTS : a.start, u = a.duration, c = Math.max(o.end, l + Math.min(Math.max(u - this.config.maxFragLookUpTolerance, u * 0.5), u * 0.75));
          this.flushMainBuffer(c, Number.POSITIVE_INFINITY);
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent;
    switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
      case z.KEY_LOADING:
      case z.FRAG_LOADING:
      case z.FRAG_LOADING_WAITING_RETRY:
      case z.PARSING:
      case z.PARSED:
        this.state = z.IDLE;
        break;
    }
    this.nextLoadPosition = this.getLoadPosition();
  }
  flushMainBuffer(e, t) {
    super.flushMainBuffer(e, t, this.altAudio ? "video" : null);
  }
  onMediaAttached(e, t) {
    super.onMediaAttached(e, t);
    const r = t.media;
    this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), r.addEventListener("playing", this.onvplaying), r.addEventListener("seeked", this.onvseeked), this.gapController = new nE(this.config, r, this.fragmentTracker, this.hls);
  }
  onMediaDetaching() {
    const {
      media: e
    } = this;
    e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching();
  }
  onMediaPlaying() {
    this.tick();
  }
  onMediaSeeked() {
    const e = this.media, t = e ? e.currentTime : null;
    de(t) && this.log(`Media seeked to ${t.toFixed(3)}`);
    const r = this.getMainFwdBufferInfo();
    if (r === null || r.len === 0) {
      this.warn(`Main forward buffer length on "seeked" event ${r ? r.len : "empty"})`);
      return;
    }
    this.tick();
  }
  onManifestLoading() {
    this.log("Trigger BUFFER_RESET"), this.hls.trigger(O.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = 0, this.levels = this.fragPlaying = this.backtrackFragment = null, this.altAudio = this.audioOnly = !1;
  }
  onManifestParsed(e, t) {
    let r = !1, n = !1, s;
    t.levels.forEach((o) => {
      s = o.audioCodec, s && (s.indexOf("mp4a.40.2") !== -1 && (r = !0), s.indexOf("mp4a.40.5") !== -1 && (n = !0));
    }), this.audioCodecSwitch = r && n && !Ay(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1;
  }
  onLevelLoading(e, t) {
    const {
      levels: r
    } = this;
    if (!r || this.state !== z.IDLE)
      return;
    const n = r[t.level];
    (!n.details || n.details.live && this.levelLastLoaded !== t.level || this.waitForCdnTuneIn(n.details)) && (this.state = z.WAITING_LEVEL);
  }
  onLevelLoaded(e, t) {
    var r;
    const {
      levels: n
    } = this, s = t.level, o = t.details, a = o.totalduration;
    if (!n) {
      this.warn(`Levels were reset while loading level ${s}`);
      return;
    }
    this.log(`Level ${s} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""}, cc [${o.startCC}, ${o.endCC}] duration:${a}`);
    const l = n[s], u = this.fragCurrent;
    u && (this.state === z.FRAG_LOADING || this.state === z.FRAG_LOADING_WAITING_RETRY) && (u.level !== t.level || u.urlId !== l.urlId) && u.loader && this.abortCurrentFrag();
    let c = 0;
    if (o.live || (r = l.details) != null && r.live) {
      if (o.fragments[0] || (o.deltaUpdateFailed = !0), o.deltaUpdateFailed)
        return;
      c = this.alignPlaylists(o, l.details);
    }
    if (l.details = o, this.levelLastLoaded = s, this.hls.trigger(O.LEVEL_UPDATED, {
      details: o,
      level: s
    }), this.state === z.WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(o))
        return;
      this.state = z.IDLE;
    }
    this.startFragRequested ? o.live && this.synchronizeToLiveEdge(o) : this.setStartPosition(o, c), this.tick();
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const {
      frag: r,
      part: n,
      payload: s
    } = e, {
      levels: o
    } = this;
    if (!o) {
      this.warn(`Levels were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);
      return;
    }
    const a = o[r.level], l = a.details;
    if (!l) {
      this.warn(`Dropping fragment ${r.sn} of level ${r.level} after level details were reset`), this.fragmentTracker.removeFragment(r);
      return;
    }
    const u = a.videoCodec, c = l.PTSKnown || !l.live, d = (t = r.initSegment) == null ? void 0 : t.data, h = this._getAudioCodec(a), p = this.transmuxer = this.transmuxer || new hu(this.hls, ge.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), f = n ? n.index : -1, g = f !== -1, m = new Fs(r.level, r.sn, r.stats.chunkCount, s.byteLength, f, g), v = this.initPTS[r.cc];
    p.push(s, d, h, u, r, n, l.totalduration, c, m, v);
  }
  onAudioTrackSwitching(e, t) {
    const r = this.altAudio;
    if (!!!t.url) {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
        const o = this.fragCurrent;
        o && (this.log("Switching to main audio track, cancel main fragment load"), o.abortRequests(), this.fragmentTracker.removeFragment(o)), this.resetTransmuxer(), this.resetLoadingState();
      } else
        this.audioOnly && this.resetTransmuxer();
      const s = this.hls;
      r && (s.trigger(O.BUFFER_FLUSHING, {
        startOffset: 0,
        endOffset: Number.POSITIVE_INFINITY,
        type: null
      }), this.fragmentTracker.removeAllFragments()), s.trigger(O.AUDIO_TRACK_SWITCHED, t);
    }
  }
  onAudioTrackSwitched(e, t) {
    const r = t.id, n = !!this.hls.audioTracks[r].url;
    if (n) {
      const s = this.videoBuffer;
      s && this.mediaBuffer !== s && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = s);
    }
    this.altAudio = n, this.tick();
  }
  onBufferCreated(e, t) {
    const r = t.tracks;
    let n, s, o = !1;
    for (const a in r) {
      const l = r[a];
      if (l.id === "main") {
        if (s = a, n = l, a === "video") {
          const u = r[a];
          u && (this.videoBuffer = u.buffer);
        }
      } else
        o = !0;
    }
    o && n ? (this.log(`Alternate track found, use ${s}.buffered to schedule main fragment loading`), this.mediaBuffer = n.buffer) : this.mediaBuffer = this.media;
  }
  onFragBuffered(e, t) {
    const {
      frag: r,
      part: n
    } = t;
    if (r && r.type !== ge.MAIN)
      return;
    if (this.fragContextChanged(r)) {
      this.warn(`Fragment ${r.sn}${n ? " p: " + n.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}`), this.state === z.PARSED && (this.state = z.IDLE);
      return;
    }
    const s = n ? n.stats : r.stats;
    this.fragLastKbps = Math.round(8 * s.total / (s.buffering.end - s.loading.first)), r.sn !== "initSegment" && (this.fragPrevious = r), this.fragBufferedComplete(r, n);
  }
  onError(e, t) {
    var r;
    if (t.fatal) {
      this.state = z.ERROR;
      return;
    }
    switch (t.details) {
      case W.FRAG_GAP:
      case W.FRAG_PARSING_ERROR:
      case W.FRAG_DECRYPT_ERROR:
      case W.FRAG_LOAD_ERROR:
      case W.FRAG_LOAD_TIMEOUT:
      case W.KEY_LOAD_ERROR:
      case W.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(ge.MAIN, t);
        break;
      case W.LEVEL_LOAD_ERROR:
      case W.LEVEL_LOAD_TIMEOUT:
      case W.LEVEL_PARSING_ERROR:
        !t.levelRetry && this.state === z.WAITING_LEVEL && ((r = t.context) == null ? void 0 : r.type) === Be.LEVEL && (this.state = z.IDLE);
        break;
      case W.BUFFER_FULL_ERROR:
        if (!t.parent || t.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
        break;
      case W.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t);
        break;
    }
  }
  // Checks the health of the buffer and attempts to resolve playback stalls.
  checkBuffer() {
    const {
      media: e,
      gapController: t
    } = this;
    if (!(!e || !t || !e.readyState)) {
      if (this.loadedmetadata || !je.getBuffered(e).length) {
        const r = this.state !== z.IDLE ? this.fragCurrent : null;
        t.poll(this.lastCurrentTime, r);
      }
      this.lastCurrentTime = e.currentTime;
    }
  }
  onFragLoadEmergencyAborted() {
    this.state = z.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate();
  }
  onBufferFlushed(e, {
    type: t
  }) {
    if (t !== Ke.AUDIO || this.audioOnly && !this.altAudio) {
      const r = (t === Ke.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      this.afterBufferFlushed(r, t, ge.MAIN);
    }
  }
  onLevelsUpdated(e, t) {
    this.levels = t.levels;
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  /**
   * Seeks to the set startPosition if not equal to the mediaElement's current time.
   */
  seekToStartPos() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const t = e.currentTime;
    let r = this.startPosition;
    if (r >= 0 && t < r) {
      if (e.seeking) {
        this.log(`could not seek to ${r}, already seeking at ${t}`);
        return;
      }
      const n = je.getBuffered(e), o = (n.length ? n.start(0) : 0) - r;
      o > 0 && (o < this.config.maxBufferHole || o < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${o} to match buffer start`), r += o, this.startPosition = r), this.log(`seek to target start position ${r} from current time ${t}`), e.currentTime = r;
    }
  }
  _getAudioCodec(e) {
    let t = this.config.defaultAudioCodec || e.audioCodec;
    return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t.indexOf("mp4a.40.5") !== -1 ? t = "mp4a.40.2" : t = "mp4a.40.5"), t;
  }
  _loadBitrateTestFrag(e, t) {
    e.bitrateTest = !0, this._doFragLoad(e, t).then((r) => {
      const {
        hls: n
      } = this;
      if (!r || this.fragContextChanged(e))
        return;
      t.fragmentError = 0, this.state = z.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;
      const s = e.stats;
      s.parsing.start = s.parsing.end = s.buffering.start = s.buffering.end = self.performance.now(), n.trigger(O.FRAG_LOADED, r), e.bitrateTest = !1;
    });
  }
  _handleTransmuxComplete(e) {
    var t;
    const r = "main", {
      hls: n
    } = this, {
      remuxResult: s,
      chunkMeta: o
    } = e, a = this.getCurrentContext(o);
    if (!a) {
      this.resetWhenMissingContext(o);
      return;
    }
    const {
      frag: l,
      part: u,
      level: c
    } = a, {
      video: d,
      text: h,
      id3: p,
      initSegment: f
    } = s, {
      details: g
    } = c, m = this.altAudio ? void 0 : s.audio;
    if (this.fragContextChanged(l)) {
      this.fragmentTracker.removeFragment(l);
      return;
    }
    if (this.state = z.PARSING, f) {
      if (f != null && f.tracks) {
        const A = l.initSegment || l;
        this._bufferInitSegment(c, f.tracks, A, o), n.trigger(O.FRAG_PARSING_INIT_SEGMENT, {
          frag: A,
          id: r,
          tracks: f.tracks
        });
      }
      const v = f.initPTS, E = f.timescale;
      de(v) && (this.initPTS[l.cc] = {
        baseTime: v,
        timescale: E
      }, n.trigger(O.INIT_PTS_FOUND, {
        frag: l,
        id: r,
        initPTS: v,
        timescale: E
      }));
    }
    if (d && s.independent !== !1) {
      if (g) {
        const {
          startPTS: v,
          endPTS: E,
          startDTS: A,
          endDTS: _
        } = d;
        if (u)
          u.elementaryStreams[d.type] = {
            startPTS: v,
            endPTS: E,
            startDTS: A,
            endDTS: _
          };
        else if (d.firstKeyFrame && d.independent && o.id === 1 && (this.couldBacktrack = !0), d.dropped && d.independent) {
          const y = this.getMainFwdBufferInfo(), S = (y ? y.end : this.getLoadPosition()) + this.config.maxBufferHole, b = d.firstKeyFramePTS ? d.firstKeyFramePTS : v;
          if (S < b - this.config.maxBufferHole) {
            this.backtrack(l);
            return;
          }
          l.setElementaryStreamInfo(d.type, l.start, E, l.start, _, !0);
        }
        l.setElementaryStreamInfo(d.type, v, E, A, _), this.backtrackFragment && (this.backtrackFragment = l), this.bufferFragmentData(d, l, u, o);
      }
    } else if (s.independent === !1) {
      this.backtrack(l);
      return;
    }
    if (m) {
      const {
        startPTS: v,
        endPTS: E,
        startDTS: A,
        endDTS: _
      } = m;
      u && (u.elementaryStreams[Ke.AUDIO] = {
        startPTS: v,
        endPTS: E,
        startDTS: A,
        endDTS: _
      }), l.setElementaryStreamInfo(Ke.AUDIO, v, E, A, _), this.bufferFragmentData(m, l, u, o);
    }
    if (g && p != null && (t = p.samples) != null && t.length) {
      const v = {
        id: r,
        frag: l,
        details: g,
        samples: p.samples
      };
      n.trigger(O.FRAG_PARSING_METADATA, v);
    }
    if (g && h) {
      const v = {
        id: r,
        frag: l,
        details: g,
        samples: h.samples
      };
      n.trigger(O.FRAG_PARSING_USERDATA, v);
    }
  }
  _bufferInitSegment(e, t, r, n) {
    if (this.state !== z.PARSING)
      return;
    this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio;
    const {
      audio: s,
      video: o,
      audiovideo: a
    } = t;
    if (s) {
      let l = e.audioCodec;
      const u = navigator.userAgent.toLowerCase();
      this.audioCodecSwitch && (l && (l.indexOf("mp4a.40.5") !== -1 ? l = "mp4a.40.2" : l = "mp4a.40.5"), s.metadata.channelCount !== 1 && u.indexOf("firefox") === -1 && (l = "mp4a.40.5")), u.indexOf("android") !== -1 && s.container !== "audio/mpeg" && (l = "mp4a.40.2", this.log(`Android: force audio codec to ${l}`)), e.audioCodec && e.audioCodec !== l && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${l}"`), s.levelCodec = l, s.id = "main", this.log(`Init audio buffer, container:${s.container}, codecs[selected/level/parsed]=[${l || ""}/${e.audioCodec || ""}/${s.codec}]`);
    }
    o && (o.levelCodec = e.videoCodec, o.id = "main", this.log(`Init video buffer, container:${o.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${o.codec}]`)), a && this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.attrs.CODECS || ""}/${a.codec}]`), this.hls.trigger(O.BUFFER_CODECS, t), Object.keys(t).forEach((l) => {
      const c = t[l].initSegment;
      c != null && c.byteLength && this.hls.trigger(O.BUFFER_APPENDING, {
        type: l,
        data: c,
        frag: r,
        part: null,
        chunkMeta: n,
        parent: r.type
      });
    }), this.tick();
  }
  getMainFwdBufferInfo() {
    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, ge.MAIN);
  }
  backtrack(e) {
    this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = z.IDLE;
  }
  checkFragmentChanged() {
    const e = this.media;
    let t = null;
    if (e && e.readyState > 1 && e.seeking === !1) {
      const r = e.currentTime;
      if (je.isBuffered(e, r) ? t = this.getAppendedFrag(r) : je.isBuffered(e, r + 0.1) && (t = this.getAppendedFrag(r + 0.1)), t) {
        this.backtrackFragment = null;
        const n = this.fragPlaying, s = t.level;
        (!n || t.sn !== n.sn || n.level !== s || t.urlId !== n.urlId) && (this.fragPlaying = t, this.hls.trigger(O.FRAG_CHANGED, {
          frag: t
        }), (!n || n.level !== s) && this.hls.trigger(O.LEVEL_SWITCHED, {
          level: s
        }));
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag;
    return e ? e.level : -1;
  }
  get currentFrag() {
    const e = this.media;
    return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null;
  }
  get currentProgramDateTime() {
    const e = this.media;
    if (e) {
      const t = e.currentTime, r = this.currentFrag;
      if (r && de(t) && de(r.programDateTime)) {
        const n = r.programDateTime + (t - r.start) * 1e3;
        return new Date(n);
      }
    }
    return null;
  }
  get currentLevel() {
    const e = this.currentFrag;
    return e ? e.level : -1;
  }
  get nextBufferedFrag() {
    const e = this.currentFrag;
    return e ? this.followingBufferedFrag(e) : null;
  }
  get forceStartLoad() {
    return this._forceStartLoad;
  }
}
class Pr {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  constructor(e, t = 0, r = 0) {
    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = r;
  }
  sample(e, t) {
    const r = Math.pow(this.alpha_, e);
    this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e;
  }
  getTotalWeight() {
    return this.totalWeight_;
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (e)
        return this.estimate_ / e;
    }
    return this.estimate_;
  }
}
class aE {
  constructor(e, t, r, n = 100) {
    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new Pr(e), this.fast_ = new Pr(t), this.defaultTTFB_ = n, this.ttfb_ = new Pr(e);
  }
  update(e, t) {
    const {
      slow_: r,
      fast_: n,
      ttfb_: s
    } = this;
    r.halfLife !== e && (this.slow_ = new Pr(e, r.getEstimate(), r.getTotalWeight())), n.halfLife !== t && (this.fast_ = new Pr(t, n.getEstimate(), n.getTotalWeight())), s.halfLife !== e && (this.ttfb_ = new Pr(e, s.getEstimate(), s.getTotalWeight()));
  }
  sample(e, t) {
    e = Math.max(e, this.minDelayMs_);
    const r = 8 * t, n = e / 1e3, s = r / n;
    this.fast_.sample(n, s), this.slow_.sample(n, s);
  }
  sampleTTFB(e) {
    const t = e / 1e3, r = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
    this.ttfb_.sample(r, Math.max(e, 5));
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_;
  }
  getEstimate() {
    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_;
  }
  destroy() {
  }
}
class lE {
  constructor(e) {
    this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = -1, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = e;
    const t = e.config;
    this.bwEstimator = new aE(t.abrEwmaSlowVoD, t.abrEwmaFastVoD, t.abrEwmaDefaultEstimate), this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.FRAG_LOADING, this.onFragLoading, this), e.on(O.FRAG_LOADED, this.onFragLoaded, this), e.on(O.FRAG_BUFFERED, this.onFragBuffered, this), e.on(O.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(O.LEVEL_LOADED, this.onLevelLoaded, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.FRAG_LOADING, this.onFragLoading, this), e.off(O.FRAG_LOADED, this.onFragLoaded, this), e.off(O.FRAG_BUFFERED, this.onFragBuffered, this), e.off(O.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(O.LEVEL_LOADED, this.onLevelLoaded, this);
  }
  destroy() {
    this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null;
  }
  onFragLoading(e, t) {
    var r;
    const n = t.frag;
    this.ignoreFragment(n) || (this.fragCurrent = n, this.partCurrent = (r = t.part) != null ? r : null, this.clearTimer(), this.timer = self.setInterval(this.onCheck, 100));
  }
  onLevelSwitching(e, t) {
    this.clearTimer();
  }
  getTimeToLoadFrag(e, t, r, n) {
    const s = e + r / t, o = n ? this.lastLevelLoadSec : 0;
    return s + o;
  }
  onLevelLoaded(e, t) {
    const r = this.hls.config, {
      total: n,
      bwEstimate: s
    } = t.stats;
    de(n) && de(s) && (this.lastLevelLoadSec = 8 * n / s), t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD);
  }
  /*
      This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load
      quickly enough to prevent underbuffering
    */
  _abandonRulesCheck() {
    const {
      fragCurrent: e,
      partCurrent: t,
      hls: r
    } = this, {
      autoLevelEnabled: n,
      media: s
    } = r;
    if (!e || !s)
      return;
    const o = performance.now(), a = t ? t.stats : e.stats, l = t ? t.duration : e.duration, u = o - a.loading.start;
    if (a.aborted || a.loaded && a.loaded === a.total || e.level === 0) {
      this.clearTimer(), this._nextAutoLevel = -1;
      return;
    }
    if (!n || s.paused || !s.playbackRate || !s.readyState)
      return;
    const c = r.mainForwardBufferInfo;
    if (c === null)
      return;
    const d = this.bwEstimator.getEstimateTTFB(), h = Math.abs(s.playbackRate);
    if (u <= Math.max(d, 1e3 * (l / (h * 2))))
      return;
    const p = c.len / h;
    if (p >= 2 * l / h)
      return;
    const f = a.loading.first ? a.loading.first - a.loading.start : -1, g = a.loaded && f > -1, m = this.bwEstimator.getEstimate(), {
      levels: v,
      minAutoLevel: E
    } = r, A = v[e.level], _ = a.total || Math.max(a.loaded, Math.round(l * A.maxBitrate / 8));
    let y = u - f;
    y < 1 && g && (y = Math.min(u, a.loaded * 8 / m));
    const S = g ? a.loaded * 1e3 / y : 0, b = S ? (_ - a.loaded) / S : _ * 8 / m + d / 1e3;
    if (b <= p)
      return;
    const w = S ? S * 8 : m;
    let P = Number.POSITIVE_INFINITY, C;
    for (C = e.level - 1; C > E; C--) {
      const T = v[C].maxBitrate;
      if (P = this.getTimeToLoadFrag(d / 1e3, w, l * T, !v[C].details), P < p)
        break;
    }
    P >= b || P > l * 10 || (r.nextLoadLevel = C, g ? this.bwEstimator.sample(u - Math.min(d, f), a.loaded) : this.bwEstimator.sampleTTFB(u), this.clearTimer(), K.warn(`[abr] Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} is loading too slowly;
      Time to underbuffer: ${p.toFixed(3)} s
      Estimated load time for current fragment: ${b.toFixed(3)} s
      Estimated load time for down switch fragment: ${P.toFixed(3)} s
      TTFB estimate: ${f}
      Current BW estimate: ${de(m) ? (m / 1024).toFixed(3) : "Unknown"} Kb/s
      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s
      Aborting and switching to level ${C}`), e.loader && (this.fragCurrent = this.partCurrent = null, e.abortRequests()), r.trigger(O.FRAG_LOAD_EMERGENCY_ABORTED, {
      frag: e,
      part: t,
      stats: a
    }));
  }
  onFragLoaded(e, {
    frag: t,
    part: r
  }) {
    const n = r ? r.stats : t.stats;
    if (t.type === ge.MAIN && this.bwEstimator.sampleTTFB(n.loading.first - n.loading.start), !this.ignoreFragment(t)) {
      if (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
        const s = r ? r.duration : t.duration, o = this.hls.levels[t.level], a = (o.loaded ? o.loaded.bytes : 0) + n.loaded, l = (o.loaded ? o.loaded.duration : 0) + s;
        o.loaded = {
          bytes: a,
          duration: l
        }, o.realBitrate = Math.round(8 * a / l);
      }
      if (t.bitrateTest) {
        const s = {
          stats: n,
          frag: t,
          part: r,
          id: t.type
        };
        this.onFragBuffered(O.FRAG_BUFFERED, s), t.bitrateTest = !1;
      }
    }
  }
  onFragBuffered(e, t) {
    const {
      frag: r,
      part: n
    } = t, s = n != null && n.stats.loaded ? n.stats : r.stats;
    if (s.aborted || this.ignoreFragment(r))
      return;
    const o = s.parsing.end - s.loading.start - Math.min(s.loading.first - s.loading.start, this.bwEstimator.getEstimateTTFB());
    this.bwEstimator.sample(o, s.loaded), s.bwEstimate = this.bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = o / 1e3 : this.bitrateTestDelay = 0;
  }
  ignoreFragment(e) {
    return e.type !== ge.MAIN || e.sn === "initSegment";
  }
  clearTimer() {
    self.clearInterval(this.timer);
  }
  // return next auto level
  get nextAutoLevel() {
    const e = this._nextAutoLevel, t = this.bwEstimator;
    if (e !== -1 && !t.canEstimate())
      return e;
    let r = this.getNextABRAutoLevel();
    if (e !== -1) {
      const n = this.hls.levels;
      if (n.length > Math.max(e, r) && n[e].loadError <= n[r].loadError)
        return e;
    }
    return e !== -1 && (r = Math.min(e, r)), r;
  }
  getNextABRAutoLevel() {
    const {
      fragCurrent: e,
      partCurrent: t,
      hls: r
    } = this, {
      maxAutoLevel: n,
      config: s,
      minAutoLevel: o,
      media: a
    } = r, l = t ? t.duration : e ? e.duration : 0, u = a && a.playbackRate !== 0 ? Math.abs(a.playbackRate) : 1, c = this.bwEstimator ? this.bwEstimator.getEstimate() : s.abrEwmaDefaultEstimate, d = r.mainForwardBufferInfo, h = (d ? d.len : 0) / u;
    let p = this.findBestLevel(c, o, n, h, s.abrBandWidthFactor, s.abrBandWidthUpFactor);
    if (p >= 0)
      return p;
    K.trace(`[abr] ${h ? "rebuffering expected" : "buffer is empty"}, finding optimal quality level`);
    let f = l ? Math.min(l, s.maxStarvationDelay) : s.maxStarvationDelay, g = s.abrBandWidthFactor, m = s.abrBandWidthUpFactor;
    if (!h) {
      const v = this.bitrateTestDelay;
      v && (f = (l ? Math.min(l, s.maxLoadingDelay) : s.maxLoadingDelay) - v, K.trace(`[abr] bitrate test took ${Math.round(1e3 * v)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * f)} ms`), g = m = 1);
    }
    return p = this.findBestLevel(c, o, n, h + f, g, m), Math.max(p, 0);
  }
  findBestLevel(e, t, r, n, s, o) {
    var a;
    const {
      fragCurrent: l,
      partCurrent: u,
      lastLoadedFragLevel: c
    } = this, {
      levels: d
    } = this.hls, h = d[c], p = !!(h != null && (a = h.details) != null && a.live), f = h == null ? void 0 : h.codecSet, g = u ? u.duration : l ? l.duration : 0, m = this.bwEstimator.getEstimateTTFB() / 1e3;
    let v = t, E = -1;
    for (let A = r; A >= t; A--) {
      const _ = d[A];
      if (!_ || f && _.codecSet !== f) {
        _ && (v = Math.min(A, v), E = Math.max(A, E));
        continue;
      }
      E !== -1 && K.trace(`[abr] Skipped level(s) ${v}-${E} with CODECS:"${d[E].attrs.CODECS}"; not compatible with "${h.attrs.CODECS}"`);
      const y = _.details, S = (u ? y == null ? void 0 : y.partTarget : y == null ? void 0 : y.averagetargetduration) || g;
      let b;
      A <= c ? b = s * e : b = o * e;
      const w = d[A].maxBitrate, P = this.getTimeToLoadFrag(m, b, w * S, y === void 0);
      if (K.trace(`[abr] level:${A} adjustedbw-bitrate:${Math.round(b - w)} avgDuration:${S.toFixed(1)} maxFetchDuration:${n.toFixed(1)} fetchDuration:${P.toFixed(1)}`), b > w && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
      (P === 0 || !de(P) || p && !this.bitrateTestDelay || P < n))
        return A;
    }
    return -1;
  }
  set nextAutoLevel(e) {
    this._nextAutoLevel = e;
  }
}
class fu {
  constructor() {
    this.chunks = [], this.dataLength = 0;
  }
  push(e) {
    this.chunks.push(e), this.dataLength += e.length;
  }
  flush() {
    const {
      chunks: e,
      dataLength: t
    } = this;
    let r;
    if (e.length)
      e.length === 1 ? r = e[0] : r = uE(e, t);
    else
      return new Uint8Array(0);
    return this.reset(), r;
  }
  reset() {
    this.chunks.length = 0, this.dataLength = 0;
  }
}
function uE(i, e) {
  const t = new Uint8Array(e);
  let r = 0;
  for (let n = 0; n < i.length; n++) {
    const s = i[n];
    t.set(s, r), r += s.length;
  }
  return t;
}
const _a = 100;
class cE extends Ks {
  constructor(e, t, r) {
    super(e, t, r, "[audio-stream-controller]", ge.AUDIO), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners();
  }
  onHandlerDestroying() {
    this._unregisterListeners(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null;
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.LEVEL_LOADED, this.onLevelLoaded, this), e.on(O.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(O.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(O.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(O.ERROR, this.onError, this), e.on(O.BUFFER_RESET, this.onBufferReset, this), e.on(O.BUFFER_CREATED, this.onBufferCreated, this), e.on(O.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(O.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(O.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.LEVEL_LOADED, this.onLevelLoaded, this), e.off(O.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(O.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(O.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(O.ERROR, this.onError, this), e.off(O.BUFFER_RESET, this.onBufferReset, this), e.off(O.BUFFER_CREATED, this.onBufferCreated, this), e.off(O.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(O.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(O.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
  onInitPtsFound(e, {
    frag: t,
    id: r,
    initPTS: n,
    timescale: s
  }) {
    if (r === "main") {
      const o = t.cc;
      this.initPTS[t.cc] = {
        baseTime: n,
        timescale: s
      }, this.log(`InitPTS for cc: ${o} found from main: ${n}`), this.videoTrackCC = o, this.state === z.WAITING_INIT_PTS && this.tick();
    }
  }
  startLoad(e) {
    if (!this.levels) {
      this.startPosition = e, this.state = z.STOPPED;
      return;
    }
    const t = this.lastCurrentTime;
    this.stopLoad(), this.setInterval(_a), t > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t, this.state = z.IDLE) : (this.loadedmetadata = !1, this.state = z.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick();
  }
  doTick() {
    switch (this.state) {
      case z.IDLE:
        this.doTickIdle();
        break;
      case z.WAITING_TRACK: {
        var e;
        const {
          levels: r,
          trackId: n
        } = this, s = r == null || (e = r[n]) == null ? void 0 : e.details;
        if (s) {
          if (this.waitForCdnTuneIn(s))
            break;
          this.state = z.WAITING_INIT_PTS;
        }
        break;
      }
      case z.FRAG_LOADING_WAITING_RETRY: {
        var t;
        const r = performance.now(), n = this.retryDate;
        (!n || r >= n || (t = this.media) != null && t.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = z.IDLE);
        break;
      }
      case z.WAITING_INIT_PTS: {
        const r = this.waitingData;
        if (r) {
          const {
            frag: n,
            part: s,
            cache: o,
            complete: a
          } = r;
          if (this.initPTS[n.cc] !== void 0) {
            this.waitingData = null, this.waitingVideoCC = -1, this.state = z.FRAG_LOADING;
            const l = o.flush(), u = {
              frag: n,
              part: s,
              payload: l,
              networkDetails: null
            };
            this._handleFragmentLoadProgress(u), a && super._handleFragmentLoadComplete(u);
          } else if (this.videoTrackCC !== this.waitingVideoCC)
            this.log(`Waiting fragment cc (${n.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment();
          else {
            const l = this.getLoadPosition(), u = je.bufferInfo(this.mediaBuffer, l, this.config.maxBufferHole);
            ss(u.end, this.config.maxFragLookUpTolerance, n) < 0 && (this.log(`Waiting fragment cc (${n.cc}) @ ${n.start} cancelled because another fragment at ${u.end} is needed`), this.clearWaitingFragment());
          }
        } else
          this.state = z.IDLE;
      }
    }
    this.onTickEnd();
  }
  clearWaitingFragment() {
    const e = this.waitingData;
    e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = z.IDLE);
  }
  resetLoadingState() {
    this.clearWaitingFragment(), super.resetLoadingState();
  }
  onTickEnd() {
    const {
      media: e
    } = this;
    e != null && e.readyState && (this.lastCurrentTime = e.currentTime);
  }
  doTickIdle() {
    const {
      hls: e,
      levels: t,
      media: r,
      trackId: n
    } = this, s = e.config;
    if (!(t != null && t[n]) || !r && (this.startFragRequested || !s.startFragPrefetch))
      return;
    const o = t[n], a = o.details;
    if (!a || a.live && this.levelLastLoaded !== n || this.waitForCdnTuneIn(a)) {
      this.state = z.WAITING_TRACK;
      return;
    }
    const l = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.bufferFlushed && l && (this.bufferFlushed = !1, this.afterBufferFlushed(l, Ke.AUDIO, ge.AUDIO));
    const u = this.getFwdBufferInfo(l, ge.AUDIO);
    if (u === null)
      return;
    const {
      bufferedTrack: c,
      switchingTrack: d
    } = this;
    if (!d && this._streamEnded(u, a)) {
      e.trigger(O.BUFFER_EOS, {
        type: "audio"
      }), this.state = z.ENDED;
      return;
    }
    const h = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, ge.MAIN), p = u.len, f = this.getMaxBufferLength(h == null ? void 0 : h.len);
    if (p >= f && !d)
      return;
    const m = a.fragments[0].start;
    let v = u.end;
    if (d && r) {
      const y = this.getLoadPosition();
      c && d.attrs !== c.attrs && (v = y), a.PTSKnown && y < m && (u.end > m || u.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), r.currentTime = m + 0.05);
    }
    let E = this.getNextFragment(v, a), A = !1;
    if (E && this.isLoopLoading(E, v) && (A = !!E.gap, E = this.getNextFragmentLoopLoading(E, a, u, ge.MAIN, f)), !E) {
      this.bufferFlushed = !0;
      return;
    }
    const _ = h && E.start > h.end + a.targetduration;
    if (_ || // Or wait for main buffer after buffing some audio
    !(h != null && h.len) && u.len) {
      const y = this.getAppendedFrag(E.start, ge.MAIN);
      if (y === null || (A || (A = !!y.gap || !!_ && h.len === 0), _ && !A || A && u.nextStart && u.nextStart < y.end))
        return;
    }
    this.loadFragment(E, o, v);
  }
  getMaxBufferLength(e) {
    const t = super.getMaxBufferLength();
    return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t;
  }
  onMediaDetaching() {
    this.videoBuffer = null, super.onMediaDetaching();
  }
  onAudioTracksUpdated(e, {
    audioTracks: t
  }) {
    this.resetTransmuxer(), this.levels = t.map((r) => new Ei(r));
  }
  onAudioTrackSwitching(e, t) {
    const r = !!t.url;
    this.trackId = t.id;
    const {
      fragCurrent: n
    } = this;
    n && (n.abortRequests(), this.removeUnbufferedFrags(n.start)), this.resetLoadingState(), r ? this.setInterval(_a) : this.resetTransmuxer(), r ? (this.switchingTrack = t, this.state = z.IDLE) : (this.switchingTrack = null, this.bufferedTrack = t, this.state = z.STOPPED), this.tick();
  }
  onManifestLoading() {
    this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details, this.cachedTrackLoadedData !== null && (this.hls.trigger(O.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null);
  }
  onAudioTrackLoaded(e, t) {
    var r;
    if (this.mainDetails == null) {
      this.cachedTrackLoadedData = t;
      return;
    }
    const {
      levels: n
    } = this, {
      details: s,
      id: o
    } = t;
    if (!n) {
      this.warn(`Audio tracks were reset while loading level ${o}`);
      return;
    }
    this.log(`Track ${o} loaded [${s.startSN},${s.endSN}]${s.lastPartSn ? `[part-${s.lastPartSn}-${s.lastPartIndex}]` : ""},duration:${s.totalduration}`);
    const a = n[o];
    let l = 0;
    if (s.live || (r = a.details) != null && r.live) {
      const u = this.mainDetails;
      if (s.fragments[0] || (s.deltaUpdateFailed = !0), s.deltaUpdateFailed || !u)
        return;
      !a.details && s.hasProgramDateTime && u.hasProgramDateTime ? (Zl(s, u), l = s.fragments[0].start) : l = this.alignPlaylists(s, a.details);
    }
    a.details = s, this.levelLastLoaded = o, !this.startFragRequested && (this.mainDetails || !s.live) && this.setStartPosition(a.details, l), this.state === z.WAITING_TRACK && !this.waitForCdnTuneIn(s) && (this.state = z.IDLE), this.tick();
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const {
      frag: r,
      part: n,
      payload: s
    } = e, {
      config: o,
      trackId: a,
      levels: l
    } = this;
    if (!l) {
      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);
      return;
    }
    const u = l[a];
    if (!u) {
      this.warn("Audio track is undefined on fragment load progress");
      return;
    }
    const c = u.details;
    if (!c) {
      this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(r.start);
      return;
    }
    const d = o.defaultAudioCodec || u.audioCodec || "mp4a.40.2";
    let h = this.transmuxer;
    h || (h = this.transmuxer = new hu(this.hls, ge.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
    const p = this.initPTS[r.cc], f = (t = r.initSegment) == null ? void 0 : t.data;
    if (p !== void 0) {
      const m = n ? n.index : -1, v = m !== -1, E = new Fs(r.level, r.sn, r.stats.chunkCount, s.byteLength, m, v);
      h.push(s, f, d, "", r, n, c.totalduration, !1, E, p);
    } else {
      this.log(`Unknown video PTS for cc ${r.cc}, waiting for video PTS before demuxing audio frag ${r.sn} of [${c.startSN} ,${c.endSN}],track ${a}`);
      const {
        cache: g
      } = this.waitingData = this.waitingData || {
        frag: r,
        part: n,
        cache: new fu(),
        complete: !1
      };
      g.push(new Uint8Array(s)), this.waitingVideoCC = this.videoTrackCC, this.state = z.WAITING_INIT_PTS;
    }
  }
  _handleFragmentLoadComplete(e) {
    if (this.waitingData) {
      this.waitingData.complete = !0;
      return;
    }
    super._handleFragmentLoadComplete(e);
  }
  onBufferReset() {
    this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1;
  }
  onBufferCreated(e, t) {
    const r = t.tracks.audio;
    r && (this.mediaBuffer = r.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null);
  }
  onFragBuffered(e, t) {
    const {
      frag: r,
      part: n
    } = t;
    if (r.type !== ge.AUDIO) {
      if (!this.loadedmetadata && r.type === ge.MAIN) {
        var s;
        (s = this.videoBuffer || this.media) != null && s.buffered.length && (this.loadedmetadata = !0);
      }
      return;
    }
    if (this.fragContextChanged(r)) {
      this.warn(`Fragment ${r.sn}${n ? " p: " + n.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
      return;
    }
    if (r.sn !== "initSegment") {
      this.fragPrevious = r;
      const o = this.switchingTrack;
      o && (this.bufferedTrack = o, this.switchingTrack = null, this.hls.trigger(O.AUDIO_TRACK_SWITCHED, Tt({}, o)));
    }
    this.fragBufferedComplete(r, n);
  }
  onError(e, t) {
    var r;
    if (t.fatal) {
      this.state = z.ERROR;
      return;
    }
    switch (t.details) {
      case W.FRAG_GAP:
      case W.FRAG_PARSING_ERROR:
      case W.FRAG_DECRYPT_ERROR:
      case W.FRAG_LOAD_ERROR:
      case W.FRAG_LOAD_TIMEOUT:
      case W.KEY_LOAD_ERROR:
      case W.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(ge.AUDIO, t);
        break;
      case W.AUDIO_TRACK_LOAD_ERROR:
      case W.AUDIO_TRACK_LOAD_TIMEOUT:
      case W.LEVEL_PARSING_ERROR:
        !t.levelRetry && this.state === z.WAITING_TRACK && ((r = t.context) == null ? void 0 : r.type) === Be.AUDIO_TRACK && (this.state = z.IDLE);
        break;
      case W.BUFFER_FULL_ERROR:
        if (!t.parent || t.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
        break;
      case W.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t);
        break;
    }
  }
  onBufferFlushed(e, {
    type: t
  }) {
    t === Ke.AUDIO && (this.bufferFlushed = !0, this.state === z.ENDED && (this.state = z.IDLE));
  }
  _handleTransmuxComplete(e) {
    var t;
    const r = "audio", {
      hls: n
    } = this, {
      remuxResult: s,
      chunkMeta: o
    } = e, a = this.getCurrentContext(o);
    if (!a) {
      this.resetWhenMissingContext(o);
      return;
    }
    const {
      frag: l,
      part: u,
      level: c
    } = a, {
      details: d
    } = c, {
      audio: h,
      text: p,
      id3: f,
      initSegment: g
    } = s;
    if (this.fragContextChanged(l) || !d) {
      this.fragmentTracker.removeFragment(l);
      return;
    }
    if (this.state = z.PARSING, this.switchingTrack && h && this.completeAudioSwitch(this.switchingTrack), g != null && g.tracks) {
      const m = l.initSegment || l;
      this._bufferInitSegment(g.tracks, m, o), n.trigger(O.FRAG_PARSING_INIT_SEGMENT, {
        frag: m,
        id: r,
        tracks: g.tracks
      });
    }
    if (h) {
      const {
        startPTS: m,
        endPTS: v,
        startDTS: E,
        endDTS: A
      } = h;
      u && (u.elementaryStreams[Ke.AUDIO] = {
        startPTS: m,
        endPTS: v,
        startDTS: E,
        endDTS: A
      }), l.setElementaryStreamInfo(Ke.AUDIO, m, v, E, A), this.bufferFragmentData(h, l, u, o);
    }
    if (f != null && (t = f.samples) != null && t.length) {
      const m = et({
        id: r,
        frag: l,
        details: d
      }, f);
      n.trigger(O.FRAG_PARSING_METADATA, m);
    }
    if (p) {
      const m = et({
        id: r,
        frag: l,
        details: d
      }, p);
      n.trigger(O.FRAG_PARSING_USERDATA, m);
    }
  }
  _bufferInitSegment(e, t, r) {
    if (this.state !== z.PARSING)
      return;
    e.video && delete e.video;
    const n = e.audio;
    if (!n)
      return;
    n.levelCodec = n.codec, n.id = "audio", this.log(`Init audio buffer, container:${n.container}, codecs[parsed]=[${n.codec}]`), this.hls.trigger(O.BUFFER_CODECS, e);
    const s = n.initSegment;
    if (s != null && s.byteLength) {
      const o = {
        type: "audio",
        frag: t,
        part: null,
        chunkMeta: r,
        parent: t.type,
        data: s
      };
      this.hls.trigger(O.BUFFER_APPENDING, o);
    }
    this.tick();
  }
  loadFragment(e, t, r) {
    const n = this.fragmentTracker.getState(e);
    if (this.fragCurrent = e, this.switchingTrack || n === at.NOT_LOADED || n === at.PARTIAL) {
      var s;
      e.sn === "initSegment" ? this._loadInitSegment(e, t) : (s = t.details) != null && s.live && !this.initPTS[e.cc] ? (this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = z.WAITING_INIT_PTS) : (this.startFragRequested = !0, super.loadFragment(e, t, r));
    } else
      this.clearTrackerIfNeeded(e);
  }
  completeAudioSwitch(e) {
    const {
      hls: t,
      media: r,
      bufferedTrack: n
    } = this, s = n == null ? void 0 : n.attrs, o = e.attrs;
    r && s && (s.CHANNELS !== o.CHANNELS || s.NAME !== o.NAME || s.LANGUAGE !== o.LANGUAGE) && (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(O.AUDIO_TRACK_SWITCHED, Tt({}, e));
  }
}
class dE extends Bs {
  constructor(e) {
    super(e, "[audio-track-controller]"), this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.MANIFEST_PARSED, this.onManifestParsed, this), e.on(O.LEVEL_LOADING, this.onLevelLoading, this), e.on(O.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(O.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(O.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.MANIFEST_PARSED, this.onManifestParsed, this), e.off(O.LEVEL_LOADING, this.onLevelLoading, this), e.off(O.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(O.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(O.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy();
  }
  onManifestLoading() {
    this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0;
  }
  onManifestParsed(e, t) {
    this.tracks = t.audioTracks || [];
  }
  onAudioTrackLoaded(e, t) {
    const {
      id: r,
      groupId: n,
      details: s
    } = t, o = this.tracksInGroup[r];
    if (!o || o.groupId !== n) {
      this.warn(`Track with id:${r} and group:${n} not found in active group ${o.groupId}`);
      return;
    }
    const a = o.details;
    o.details = t.details, this.log(`audio-track ${r} "${o.name}" lang:${o.lang} group:${n} loaded [${s.startSN}-${s.endSN}]`), r === this.trackId && this.playlistLoaded(r, t, a);
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level);
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level);
  }
  switchLevel(e) {
    const t = this.hls.levels[e];
    if (!(t != null && t.audioGroupIds))
      return;
    const r = t.audioGroupIds[t.urlId];
    if (this.groupId !== r) {
      this.groupId = r || null;
      const n = this.tracks.filter((o) => !r || o.groupId === r);
      this.selectDefaultTrack && !n.some((o) => o.default) && (this.selectDefaultTrack = !1), this.tracksInGroup = n;
      const s = {
        audioTracks: n
      };
      this.log(`Updating audio tracks, ${n.length} track(s) found in group:${r}`), this.hls.trigger(O.AUDIO_TRACKS_UPDATED, s), this.selectInitialTrack();
    } else
      this.shouldReloadPlaylist(this.currentTrack) && this.setAudioTrack(this.trackId);
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === Be.AUDIO_TRACK && t.context.id === this.trackId && t.context.groupId === this.groupId && (this.requestScheduled = -1, this.checkRetry(t));
  }
  get audioTracks() {
    return this.tracksInGroup;
  }
  get audioTrack() {
    return this.trackId;
  }
  set audioTrack(e) {
    this.selectDefaultTrack = !1, this.setAudioTrack(e);
  }
  setAudioTrack(e) {
    const t = this.tracksInGroup;
    if (e < 0 || e >= t.length) {
      this.warn("Invalid id passed to audio-track controller");
      return;
    }
    this.clearTimer();
    const r = this.currentTrack;
    t[this.trackId];
    const n = t[e], {
      groupId: s,
      name: o
    } = n;
    if (this.log(`Switching to audio-track ${e} "${o}" lang:${n.lang} group:${s}`), this.trackId = e, this.currentTrack = n, this.selectDefaultTrack = !1, this.hls.trigger(O.AUDIO_TRACK_SWITCHING, Tt({}, n)), n.details && !n.details.live)
      return;
    const a = this.switchParams(n.url, r == null ? void 0 : r.details);
    this.loadPlaylist(a);
  }
  selectInitialTrack() {
    const e = this.tracksInGroup, t = this.findTrackId(this.currentTrack) | this.findTrackId(null);
    if (t !== -1)
      this.setAudioTrack(t);
    else {
      const r = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${e.length}`);
      this.warn(r.message), this.hls.trigger(O.ERROR, {
        type: fe.MEDIA_ERROR,
        details: W.AUDIO_TRACK_LOAD_ERROR,
        fatal: !0,
        error: r
      });
    }
  }
  findTrackId(e) {
    const t = this.tracksInGroup;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      if ((!this.selectDefaultTrack || n.default) && (!e || e.attrs["STABLE-RENDITION-ID"] !== void 0 && e.attrs["STABLE-RENDITION-ID"] === n.attrs["STABLE-RENDITION-ID"] || e.name === n.name && e.lang === n.lang))
        return n.id;
    }
    return -1;
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const t = this.tracksInGroup[this.trackId];
    if (this.shouldLoadPlaylist(t)) {
      const r = t.id, n = t.groupId;
      let s = t.url;
      if (e)
        try {
          s = e.addDirectives(s);
        } catch (o) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`);
        }
      this.log(`loading audio-track playlist ${r} "${t.name}" lang:${t.lang} group:${n}`), this.clearTimer(), this.hls.trigger(O.AUDIO_TRACK_LOADING, {
        url: s,
        id: r,
        groupId: n,
        deliveryDirectives: e || null
      });
    }
  }
}
function pu(i, e) {
  if (i.length !== e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (!hE(i[t].attrs, e[t].attrs))
      return !1;
  return !0;
}
function hE(i, e) {
  const t = i["STABLE-RENDITION-ID"];
  return t ? t === e["STABLE-RENDITION-ID"] : !["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED"].some((r) => i[r] !== e[r]);
}
const xa = 500;
class fE extends Ks {
  constructor(e, t, r) {
    super(e, t, r, "[subtitle-stream-controller]", ge.SUBTITLE), this.levels = [], this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners();
  }
  onHandlerDestroying() {
    this._unregisterListeners(), this.mainDetails = null;
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.LEVEL_LOADED, this.onLevelLoaded, this), e.on(O.ERROR, this.onError, this), e.on(O.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(O.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(O.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(O.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(O.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(O.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.LEVEL_LOADED, this.onLevelLoaded, this), e.off(O.ERROR, this.onError, this), e.off(O.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(O.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(O.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(O.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(O.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(O.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  startLoad(e) {
    this.stopLoad(), this.state = z.IDLE, this.setInterval(xa), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick();
  }
  onManifestLoading() {
    this.mainDetails = null, this.fragmentTracker.removeAllFragments();
  }
  onMediaDetaching() {
    this.tracksBuffered = [], super.onMediaDetaching();
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details;
  }
  onSubtitleFragProcessed(e, t) {
    const {
      frag: r,
      success: n
    } = t;
    if (this.fragPrevious = r, this.state = z.IDLE, !n)
      return;
    const s = this.tracksBuffered[this.currentTrackId];
    if (!s)
      return;
    let o;
    const a = r.start;
    for (let u = 0; u < s.length; u++)
      if (a >= s[u].start && a <= s[u].end) {
        o = s[u];
        break;
      }
    const l = r.start + r.duration;
    o ? o.end = l : (o = {
      start: a,
      end: l
    }, s.push(o)), this.fragmentTracker.fragBuffered(r);
  }
  onBufferFlushing(e, t) {
    const {
      startOffset: r,
      endOffset: n
    } = t;
    if (r === 0 && n !== Number.POSITIVE_INFINITY) {
      const {
        currentTrackId: s,
        levels: o
      } = this;
      if (!o.length || !o[s] || !o[s].details)
        return;
      const l = o[s].details.targetduration, u = n - l;
      if (u <= 0)
        return;
      t.endOffsetSubtitles = Math.max(0, u), this.tracksBuffered.forEach((c) => {
        for (let d = 0; d < c.length; ) {
          if (c[d].end <= u) {
            c.shift();
            continue;
          } else if (c[d].start < u)
            c[d].start = u;
          else
            break;
          d++;
        }
      }), this.fragmentTracker.removeFragmentsInRange(r, u, ge.SUBTITLE);
    }
  }
  onFragBuffered(e, t) {
    if (!this.loadedmetadata && t.frag.type === ge.MAIN) {
      var r;
      (r = this.media) != null && r.buffered.length && (this.loadedmetadata = !0);
    }
  }
  // If something goes wrong, proceed to next frag, if we were processing one.
  onError(e, t) {
    const r = t.frag;
    (r == null ? void 0 : r.type) === ge.SUBTITLE && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== z.STOPPED && (this.state = z.IDLE));
  }
  // Got all new subtitle levels.
  onSubtitleTracksUpdated(e, {
    subtitleTracks: t
  }) {
    if (pu(this.levels, t)) {
      this.levels = t.map((r) => new Ei(r));
      return;
    }
    this.tracksBuffered = [], this.levels = t.map((r) => {
      const n = new Ei(r);
      return this.tracksBuffered[n.id] = [], n;
    }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, ge.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null;
  }
  onSubtitleTrackSwitch(e, t) {
    if (this.currentTrackId = t.id, !this.levels.length || this.currentTrackId === -1) {
      this.clearInterval();
      return;
    }
    const r = this.levels[this.currentTrackId];
    r != null && r.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, r && this.setInterval(xa);
  }
  // Got a new set of subtitle fragments.
  onSubtitleTrackLoaded(e, t) {
    var r;
    const {
      details: n,
      id: s
    } = t, {
      currentTrackId: o,
      levels: a
    } = this;
    if (!a.length)
      return;
    const l = a[o];
    if (s >= a.length || s !== o || !l)
      return;
    this.mediaBuffer = this.mediaBufferTimeRanges;
    let u = 0;
    if (n.live || (r = l.details) != null && r.live) {
      const c = this.mainDetails;
      if (n.deltaUpdateFailed || !c)
        return;
      const d = c.fragments[0];
      l.details ? (u = this.alignPlaylists(n, l.details), u === 0 && d && (u = d.start, ns(n, u))) : n.hasProgramDateTime && c.hasProgramDateTime ? (Zl(n, c), u = n.fragments[0].start) : d && (u = d.start, ns(n, u));
    }
    l.details = n, this.levelLastLoaded = s, !this.startFragRequested && (this.mainDetails || !n.live) && this.setStartPosition(l.details, u), this.tick(), n.live && !this.fragCurrent && this.media && this.state === z.IDLE && (Ai(null, n.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), l.details = void 0));
  }
  _handleFragmentLoadComplete(e) {
    const {
      frag: t,
      payload: r
    } = e, n = t.decryptdata, s = this.hls;
    if (!this.fragContextChanged(t) && r && r.byteLength > 0 && n && n.key && n.iv && n.method === "AES-128") {
      const o = performance.now();
      this.decrypter.decrypt(new Uint8Array(r), n.key.buffer, n.iv.buffer).catch((a) => {
        throw s.trigger(O.ERROR, {
          type: fe.MEDIA_ERROR,
          details: W.FRAG_DECRYPT_ERROR,
          fatal: !1,
          error: a,
          reason: a.message,
          frag: t
        }), a;
      }).then((a) => {
        const l = performance.now();
        s.trigger(O.FRAG_DECRYPTED, {
          frag: t,
          payload: a,
          stats: {
            tstart: o,
            tdecrypt: l
          }
        });
      }).catch((a) => {
        this.warn(`${a.name}: ${a.message}`), this.state = z.IDLE;
      });
    }
  }
  doTick() {
    if (!this.media) {
      this.state = z.IDLE;
      return;
    }
    if (this.state === z.IDLE) {
      const {
        currentTrackId: e,
        levels: t
      } = this, r = t[e];
      if (!t.length || !r || !r.details)
        return;
      const n = r.details, s = n.targetduration, {
        config: o
      } = this, a = this.getLoadPosition(), l = je.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], a - s, o.maxBufferHole), {
        end: u,
        len: c
      } = l, d = this.getFwdBufferInfo(this.media, ge.MAIN), h = this.getMaxBufferLength(d == null ? void 0 : d.len) + s;
      if (c > h)
        return;
      const p = n.fragments, f = p.length, g = n.edge;
      let m = null;
      const v = this.fragPrevious;
      if (u < g) {
        const {
          maxFragLookUpTolerance: E
        } = o;
        m = Ai(v, p, Math.max(p[0].start, u), E), !m && v && v.start < p[0].start && (m = p[0]);
      } else
        m = p[f - 1];
      if (!m)
        return;
      m = this.mapToInitFragWhenRequired(m), this.fragmentTracker.getState(m) === at.NOT_LOADED && this.loadFragment(m, r, u);
    }
  }
  getMaxBufferLength(e) {
    const t = super.getMaxBufferLength();
    return e ? Math.max(t, e) : t;
  }
  loadFragment(e, t, r) {
    this.fragCurrent = e, e.sn === "initSegment" ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, super.loadFragment(e, t, r));
  }
  get mediaBufferTimeRanges() {
    return new pE(this.tracksBuffered[this.currentTrackId] || []);
  }
}
class pE {
  constructor(e) {
    this.buffered = void 0;
    const t = (r, n, s) => {
      if (n = n >>> 0, n > s - 1)
        throw new DOMException(`Failed to execute '${r}' on 'TimeRanges': The index provided (${n}) is greater than the maximum bound (${s})`);
      return e[n][r];
    };
    this.buffered = {
      get length() {
        return e.length;
      },
      end(r) {
        return t("end", r, e.length);
      },
      start(r) {
        return t("start", r, e.length);
      }
    };
  }
}
class gE extends Bs {
  constructor(e) {
    super(e, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.trackChangeListener = () => this.onTextTracksChanged(), this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.registerListeners();
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, super.destroy();
  }
  get subtitleDisplay() {
    return this._subtitleDisplay;
  }
  set subtitleDisplay(e) {
    this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes(this.trackId);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.MANIFEST_PARSED, this.onManifestParsed, this), e.on(O.LEVEL_LOADING, this.onLevelLoading, this), e.on(O.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(O.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(O.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.MANIFEST_PARSED, this.onManifestParsed, this), e.off(O.LEVEL_LOADING, this.onLevelLoading, this), e.off(O.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(O.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(O.ERROR, this.onError, this);
  }
  // Listen for subtitle track change, then extract the current track ID.
  onMediaAttached(e, t) {
    this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange));
  }
  pollTrackChange(e) {
    self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e);
  }
  onMediaDetaching() {
    if (!this.media)
      return;
    self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), Gn(this.media.textTracks).forEach((t) => {
      Kr(t);
    }), this.subtitleTrack = -1, this.media = null;
  }
  onManifestLoading() {
    this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0;
  }
  // Fired whenever a new manifest is loaded.
  onManifestParsed(e, t) {
    this.tracks = t.subtitleTracks;
  }
  onSubtitleTrackLoaded(e, t) {
    const {
      id: r,
      details: n
    } = t, {
      trackId: s
    } = this, o = this.tracksInGroup[s];
    if (!o) {
      this.warn(`Invalid subtitle track id ${r}`);
      return;
    }
    const a = o.details;
    o.details = t.details, this.log(`subtitle track ${r} loaded [${n.startSN}-${n.endSN}]`), r === this.trackId && this.playlistLoaded(r, t, a);
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level);
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level);
  }
  switchLevel(e) {
    const t = this.hls.levels[e];
    if (!(t != null && t.textGroupIds))
      return;
    const r = t.textGroupIds[t.urlId], n = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
    if (this.groupId !== r) {
      const s = this.tracks.filter((l) => !r || l.groupId === r);
      this.tracksInGroup = s;
      const o = this.findTrackId(n == null ? void 0 : n.name) || this.findTrackId();
      this.groupId = r || null;
      const a = {
        subtitleTracks: s
      };
      this.log(`Updating subtitle tracks, ${s.length} track(s) found in "${r}" group-id`), this.hls.trigger(O.SUBTITLE_TRACKS_UPDATED, a), o !== -1 && this.setSubtitleTrack(o, n);
    } else
      this.shouldReloadPlaylist(n) && this.setSubtitleTrack(this.trackId, n);
  }
  findTrackId(e) {
    const t = this.tracksInGroup;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      if ((!this.selectDefaultTrack || n.default) && (!e || e === n.name))
        return n.id;
    }
    return -1;
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === Be.SUBTITLE_TRACK && t.context.id === this.trackId && t.context.groupId === this.groupId && this.checkRetry(t);
  }
  /** get alternate subtitle tracks list from playlist **/
  get subtitleTracks() {
    return this.tracksInGroup;
  }
  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
  get subtitleTrack() {
    return this.trackId;
  }
  set subtitleTrack(e) {
    this.selectDefaultTrack = !1;
    const t = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
    this.setSubtitleTrack(e, t);
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const t = this.tracksInGroup[this.trackId];
    if (this.shouldLoadPlaylist(t)) {
      const r = t.id, n = t.groupId;
      let s = t.url;
      if (e)
        try {
          s = e.addDirectives(s);
        } catch (o) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`);
        }
      this.log(`Loading subtitle playlist for id ${r}`), this.hls.trigger(O.SUBTITLE_TRACK_LOADING, {
        url: s,
        id: r,
        groupId: n,
        deliveryDirectives: e || null
      });
    }
  }
  /**
   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
   * This operates on the DOM textTracks.
   * A value of -1 will disable all subtitle tracks.
   */
  toggleTrackModes(e) {
    const {
      media: t,
      trackId: r
    } = this;
    if (!t)
      return;
    const n = Gn(t.textTracks), s = n.filter((a) => a.groupId === this.groupId);
    if (e === -1)
      [].slice.call(n).forEach((a) => {
        a.mode = "disabled";
      });
    else {
      const a = s[r];
      a && (a.mode = "disabled");
    }
    const o = s[e];
    o && (o.mode = this.subtitleDisplay ? "showing" : "hidden");
  }
  /**
   * This method is responsible for validating the subtitle index and periodically reloading if live.
   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
   */
  setSubtitleTrack(e, t) {
    var r;
    const n = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = e;
      return;
    }
    if (this.trackId !== e && this.toggleTrackModes(e), this.trackId === e && (e === -1 || (r = n[e]) != null && r.details) || e < -1 || e >= n.length)
      return;
    this.clearTimer();
    const s = n[e];
    if (this.log(`Switching to subtitle-track ${e}` + (s ? ` "${s.name}" lang:${s.lang} group:${s.groupId}` : "")), this.trackId = e, s) {
      const {
        id: o,
        groupId: a = "",
        name: l,
        type: u,
        url: c
      } = s;
      this.hls.trigger(O.SUBTITLE_TRACK_SWITCH, {
        id: o,
        groupId: a,
        name: l,
        type: u,
        url: c
      });
      const d = this.switchParams(s.url, t == null ? void 0 : t.details);
      this.loadPlaylist(d);
    } else
      this.hls.trigger(O.SUBTITLE_TRACK_SWITCH, {
        id: e
      });
  }
  onTextTracksChanged() {
    if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively)
      return;
    let e = -1;
    const t = Gn(this.media.textTracks);
    for (let r = 0; r < t.length; r++)
      if (t[r].mode === "hidden")
        e = r;
      else if (t[r].mode === "showing") {
        e = r;
        break;
      }
    this.subtitleTrack !== e && (this.subtitleTrack = e);
  }
}
function Gn(i) {
  const e = [];
  for (let t = 0; t < i.length; t++) {
    const r = i[t];
    (r.kind === "subtitles" || r.kind === "captions") && r.label && e.push(i[t]);
  }
  return e;
}
class mE {
  constructor(e) {
    this.buffers = void 0, this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    }, this.buffers = e;
  }
  append(e, t) {
    const r = this.queues[t];
    r.push(e), r.length === 1 && this.buffers[t] && this.executeNext(t);
  }
  insertAbort(e, t) {
    this.queues[t].unshift(e), this.executeNext(t);
  }
  appendBlocker(e) {
    let t;
    const r = new Promise((s) => {
      t = s;
    }), n = {
      execute: t,
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: () => {
      }
    };
    return this.append(n, e), r;
  }
  executeNext(e) {
    const {
      buffers: t,
      queues: r
    } = this, n = t[e], s = r[e];
    if (s.length) {
      const o = s[0];
      try {
        o.execute();
      } catch (a) {
        K.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), o.onError(a), n != null && n.updating || (s.shift(), this.executeNext(e));
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues[e].shift(), this.executeNext(e);
  }
  current(e) {
    return this.queues[e][0];
  }
}
const Sa = hn(), Ta = /([ha]vc.)(?:\.[^.,]+)+/;
class vE {
  // The level details used to determine duration, target-duration and live
  // cache the self generated object url to detect hijack of video tag
  // A queue of buffer operations which require the SourceBuffer to not be updating upon execution
  // References to event listeners for each SourceBuffer, so that they can be referenced for event removal
  // The number of BUFFER_CODEC events received before any sourceBuffers are created
  // The total number of BUFFER_CODEC events received
  // A reference to the attached media element
  // A reference to the active media source
  // Last MP3 audio chunk appended
  // counters
  constructor(e) {
    this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = () => {
      const {
        media: t,
        mediaSource: r
      } = this;
      K.log("[buffer-controller]: Media source opened"), t && (t.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(O.MEDIA_ATTACHED, {
        media: t
      })), r && r.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks();
    }, this._onMediaSourceClose = () => {
      K.log("[buffer-controller]: Media source closed");
    }, this._onMediaSourceEnded = () => {
      K.log("[buffer-controller]: Media source ended");
    }, this._onMediaEmptied = () => {
      const {
        media: t,
        _objectUrl: r
      } = this;
      t && t.src !== r && K.error(`Media element src was set while attaching MediaSource (${r} > ${t.src})`);
    }, this.hls = e, this._initSourceBuffer(), this.registerListeners();
  }
  hasSourceTypes() {
    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
  }
  destroy() {
    this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.MANIFEST_PARSED, this.onManifestParsed, this), e.on(O.BUFFER_RESET, this.onBufferReset, this), e.on(O.BUFFER_APPENDING, this.onBufferAppending, this), e.on(O.BUFFER_CODECS, this.onBufferCodecs, this), e.on(O.BUFFER_EOS, this.onBufferEos, this), e.on(O.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(O.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(O.FRAG_PARSED, this.onFragParsed, this), e.on(O.FRAG_CHANGED, this.onFragChanged, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(O.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.MANIFEST_PARSED, this.onManifestParsed, this), e.off(O.BUFFER_RESET, this.onBufferReset, this), e.off(O.BUFFER_APPENDING, this.onBufferAppending, this), e.off(O.BUFFER_CODECS, this.onBufferCodecs, this), e.off(O.BUFFER_EOS, this.onBufferEos, this), e.off(O.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(O.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(O.FRAG_PARSED, this.onFragParsed, this), e.off(O.FRAG_CHANGED, this.onFragChanged, this);
  }
  _initSourceBuffer() {
    this.sourceBuffer = {}, this.operationQueue = new mE(this.sourceBuffer), this.listeners = {
      audio: [],
      video: [],
      audiovideo: []
    }, this.lastMpegAudioChunk = null;
  }
  onManifestLoading() {
    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null;
  }
  onManifestParsed(e, t) {
    let r = 2;
    (t.audio && !t.video || !t.altAudio) && (r = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, K.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);
  }
  onMediaAttaching(e, t) {
    const r = this.media = t.media;
    if (r && Sa) {
      const n = this.mediaSource = new Sa();
      n.addEventListener("sourceopen", this._onMediaSourceOpen), n.addEventListener("sourceended", this._onMediaSourceEnded), n.addEventListener("sourceclose", this._onMediaSourceClose), r.src = self.URL.createObjectURL(n), this._objectUrl = r.src, r.addEventListener("emptied", this._onMediaEmptied);
    }
  }
  onMediaDetaching() {
    const {
      media: e,
      mediaSource: t,
      _objectUrl: r
    } = this;
    if (t) {
      if (K.log("[buffer-controller]: media source detaching"), t.readyState === "open")
        try {
          t.endOfStream();
        } catch (n) {
          K.warn(`[buffer-controller]: onMediaDetaching: ${n.message} while calling endOfStream`);
        }
      this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), e && (e.removeEventListener("emptied", this._onMediaEmptied), r && self.URL.revokeObjectURL(r), e.src === r ? (e.removeAttribute("src"), e.load()) : K.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {};
    }
    this.hls.trigger(O.MEDIA_DETACHED, void 0);
  }
  onBufferReset() {
    this.getSourceBufferTypes().forEach((e) => {
      const t = this.sourceBuffer[e];
      try {
        t && (this.removeBufferListeners(e), this.mediaSource && this.mediaSource.removeSourceBuffer(t), this.sourceBuffer[e] = void 0);
      } catch (r) {
        K.warn(`[buffer-controller]: Failed to reset the ${e} buffer`, r);
      }
    }), this._initSourceBuffer();
  }
  onBufferCodecs(e, t) {
    const r = this.getSourceBufferTypes().length;
    Object.keys(t).forEach((n) => {
      if (r) {
        const s = this.tracks[n];
        if (s && typeof s.buffer.changeType == "function") {
          const {
            id: o,
            codec: a,
            levelCodec: l,
            container: u,
            metadata: c
          } = t[n], d = (s.levelCodec || s.codec).replace(Ta, "$1"), h = (l || a).replace(Ta, "$1");
          if (d !== h) {
            const p = `${u};codecs=${l || a}`;
            this.appendChangeType(n, p), K.log(`[buffer-controller]: switching codec ${d} to ${h}`), this.tracks[n] = {
              buffer: s.buffer,
              codec: a,
              container: u,
              levelCodec: l,
              metadata: c,
              id: o
            };
          }
        }
      } else
        this.pendingTracks[n] = t[n];
    }), !r && (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && this.mediaSource.readyState === "open" && this.checkPendingTracks());
  }
  appendChangeType(e, t) {
    const {
      operationQueue: r
    } = this, n = {
      execute: () => {
        const s = this.sourceBuffer[e];
        s && (K.log(`[buffer-controller]: changing ${e} sourceBuffer type to ${t}`), s.changeType(t)), r.shiftAndExecuteNext(e);
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (s) => {
        K.warn(`[buffer-controller]: Failed to change ${e} SourceBuffer type`, s);
      }
    };
    r.append(n, e);
  }
  onBufferAppending(e, t) {
    const {
      hls: r,
      operationQueue: n,
      tracks: s
    } = this, {
      data: o,
      type: a,
      frag: l,
      part: u,
      chunkMeta: c
    } = t, d = c.buffering[a], h = self.performance.now();
    d.start = h;
    const p = l.stats.buffering, f = u ? u.stats.buffering : null;
    p.start === 0 && (p.start = h), f && f.start === 0 && (f.start = h);
    const g = s.audio;
    let m = !1;
    a === "audio" && (g == null ? void 0 : g.container) === "audio/mpeg" && (m = !this.lastMpegAudioChunk || c.id === 1 || this.lastMpegAudioChunk.sn !== c.sn, this.lastMpegAudioChunk = c);
    const v = l.start, E = {
      execute: () => {
        if (d.executeStart = self.performance.now(), m) {
          const A = this.sourceBuffer[a];
          if (A) {
            const _ = v - A.timestampOffset;
            Math.abs(_) >= 0.1 && (K.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${v} (delta: ${_}) sn: ${l.sn})`), A.timestampOffset = v);
          }
        }
        this.appendExecutor(o, a);
      },
      onStart: () => {
      },
      onComplete: () => {
        const A = self.performance.now();
        d.executeEnd = d.end = A, p.first === 0 && (p.first = A), f && f.first === 0 && (f.first = A);
        const {
          sourceBuffer: _
        } = this, y = {};
        for (const S in _)
          y[S] = je.getBuffered(_[S]);
        this.appendError = 0, this.hls.trigger(O.BUFFER_APPENDED, {
          type: a,
          frag: l,
          part: u,
          chunkMeta: c,
          parent: l.type,
          timeRanges: y
        });
      },
      onError: (A) => {
        K.error(`[buffer-controller]: Error encountered while trying to append to the ${a} SourceBuffer`, A);
        const _ = {
          type: fe.MEDIA_ERROR,
          parent: l.type,
          details: W.BUFFER_APPEND_ERROR,
          frag: l,
          part: u,
          chunkMeta: c,
          error: A,
          err: A,
          fatal: !1
        };
        A.code === DOMException.QUOTA_EXCEEDED_ERR ? _.details = W.BUFFER_FULL_ERROR : (this.appendError++, _.details = W.BUFFER_APPEND_ERROR, this.appendError > r.config.appendErrorMaxRetry && (K.error(`[buffer-controller]: Failed ${r.config.appendErrorMaxRetry} times to append segment in sourceBuffer`), _.fatal = !0)), r.trigger(O.ERROR, _);
      }
    };
    n.append(E, a);
  }
  onBufferFlushing(e, t) {
    const {
      operationQueue: r
    } = this, n = (s) => ({
      execute: this.removeExecutor.bind(this, s, t.startOffset, t.endOffset),
      onStart: () => {
      },
      onComplete: () => {
        this.hls.trigger(O.BUFFER_FLUSHED, {
          type: s
        });
      },
      onError: (o) => {
        K.warn(`[buffer-controller]: Failed to remove from ${s} SourceBuffer`, o);
      }
    });
    t.type ? r.append(n(t.type), t.type) : this.getSourceBufferTypes().forEach((s) => {
      r.append(n(s), s);
    });
  }
  onFragParsed(e, t) {
    const {
      frag: r,
      part: n
    } = t, s = [], o = n ? n.elementaryStreams : r.elementaryStreams;
    o[Ke.AUDIOVIDEO] ? s.push("audiovideo") : (o[Ke.AUDIO] && s.push("audio"), o[Ke.VIDEO] && s.push("video"));
    const a = () => {
      const l = self.performance.now();
      r.stats.buffering.end = l, n && (n.stats.buffering.end = l);
      const u = n ? n.stats : r.stats;
      this.hls.trigger(O.FRAG_BUFFERED, {
        frag: r,
        part: n,
        stats: u,
        id: r.type
      });
    };
    s.length === 0 && K.warn(`Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ${r.sn}`), this.blockBuffers(a, s);
  }
  onFragChanged(e, t) {
    this.flushBackBuffer();
  }
  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
  // an undefined data.type will mark all buffers as EOS.
  onBufferEos(e, t) {
    this.getSourceBufferTypes().reduce((n, s) => {
      const o = this.sourceBuffer[s];
      return o && (!t.type || t.type === s) && (o.ending = !0, o.ended || (o.ended = !0, K.log(`[buffer-controller]: ${s} sourceBuffer now EOS`))), n && !!(!o || o.ended);
    }, !0) && (K.log("[buffer-controller]: Queueing mediaSource.endOfStream()"), this.blockBuffers(() => {
      this.getSourceBufferTypes().forEach((s) => {
        const o = this.sourceBuffer[s];
        o && (o.ending = !1);
      });
      const {
        mediaSource: n
      } = this;
      if (!n || n.readyState !== "open") {
        n && K.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${n.readyState}`);
        return;
      }
      K.log("[buffer-controller]: Calling mediaSource.endOfStream()"), n.endOfStream();
    }));
  }
  onLevelUpdated(e, {
    details: t
  }) {
    t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration());
  }
  flushBackBuffer() {
    const {
      hls: e,
      details: t,
      media: r,
      sourceBuffer: n
    } = this;
    if (!r || t === null)
      return;
    const s = this.getSourceBufferTypes();
    if (!s.length)
      return;
    const o = t.live && e.config.liveBackBufferLength !== null ? e.config.liveBackBufferLength : e.config.backBufferLength;
    if (!de(o) || o < 0)
      return;
    const a = r.currentTime, l = t.levelTargetDuration, u = Math.max(o, l), c = Math.floor(a / l) * l - u;
    s.forEach((d) => {
      const h = n[d];
      if (h) {
        const p = je.getBuffered(h);
        if (p.length > 0 && c > p.start(0)) {
          if (e.trigger(O.BACK_BUFFER_REACHED, {
            bufferEnd: c
          }), t.live)
            e.trigger(O.LIVE_BACK_BUFFER_REACHED, {
              bufferEnd: c
            });
          else if (h.ended && p.end(p.length - 1) - a < l * 2) {
            K.info(`[buffer-controller]: Cannot flush ${d} back buffer while SourceBuffer is in ended state`);
            return;
          }
          e.trigger(O.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: c,
            type: d
          });
        }
      }
    });
  }
  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */
  updateMediaElementDuration() {
    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open")
      return;
    const {
      details: e,
      hls: t,
      media: r,
      mediaSource: n
    } = this, s = e.fragments[0].start + e.totalduration, o = r.duration, a = de(n.duration) ? n.duration : 0;
    e.live && t.config.liveDurationInfinity ? (K.log("[buffer-controller]: Media Source duration is set to Infinity"), n.duration = 1 / 0, this.updateSeekableRange(e)) : (s > a && s > o || !de(o)) && (K.log(`[buffer-controller]: Updating Media Source duration to ${s.toFixed(3)}`), n.duration = s);
  }
  updateSeekableRange(e) {
    const t = this.mediaSource, r = e.fragments;
    if (r.length && e.live && t != null && t.setLiveSeekableRange) {
      const s = Math.max(0, r[0].start), o = Math.max(s, s + e.totalduration);
      t.setLiveSeekableRange(s, o);
    }
  }
  checkPendingTracks() {
    const {
      bufferCodecEventsExpected: e,
      operationQueue: t,
      pendingTracks: r
    } = this, n = Object.keys(r).length;
    if (n && !e || n === 2) {
      this.createSourceBuffers(r), this.pendingTracks = {};
      const s = this.getSourceBufferTypes();
      if (s.length)
        this.hls.trigger(O.BUFFER_CREATED, {
          tracks: this.tracks
        }), s.forEach((o) => {
          t.executeNext(o);
        });
      else {
        const o = new Error("could not create source buffer for media codec(s)");
        this.hls.trigger(O.ERROR, {
          type: fe.MEDIA_ERROR,
          details: W.BUFFER_INCOMPATIBLE_CODECS_ERROR,
          fatal: !0,
          error: o,
          reason: o.message
        });
      }
    }
  }
  createSourceBuffers(e) {
    const {
      sourceBuffer: t,
      mediaSource: r
    } = this;
    if (!r)
      throw Error("createSourceBuffers called when mediaSource was null");
    for (const n in e)
      if (!t[n]) {
        const s = e[n];
        if (!s)
          throw Error(`source buffer exists for track ${n}, however track does not`);
        const o = s.levelCodec || s.codec, a = `${s.container};codecs=${o}`;
        K.log(`[buffer-controller]: creating sourceBuffer(${a})`);
        try {
          const l = t[n] = r.addSourceBuffer(a), u = n;
          this.addBufferListener(u, "updatestart", this._onSBUpdateStart), this.addBufferListener(u, "updateend", this._onSBUpdateEnd), this.addBufferListener(u, "error", this._onSBUpdateError), this.tracks[n] = {
            buffer: l,
            codec: o,
            container: s.container,
            levelCodec: s.levelCodec,
            metadata: s.metadata,
            id: s.id
          };
        } catch (l) {
          K.error(`[buffer-controller]: error while trying to add sourceBuffer: ${l.message}`), this.hls.trigger(O.ERROR, {
            type: fe.MEDIA_ERROR,
            details: W.BUFFER_ADD_CODEC_ERROR,
            fatal: !1,
            error: l,
            mimeType: a
          });
        }
      }
  }
  _onSBUpdateStart(e) {
    const {
      operationQueue: t
    } = this;
    t.current(e).onStart();
  }
  _onSBUpdateEnd(e) {
    const {
      operationQueue: t
    } = this;
    t.current(e).onComplete(), t.shiftAndExecuteNext(e);
  }
  _onSBUpdateError(e, t) {
    const r = new Error(`${e} SourceBuffer error`);
    K.error(`[buffer-controller]: ${r}`, t), this.hls.trigger(O.ERROR, {
      type: fe.MEDIA_ERROR,
      details: W.BUFFER_APPENDING_ERROR,
      error: r,
      fatal: !1
    });
    const n = this.operationQueue.current(e);
    n && n.onError(t);
  }
  // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually
  removeExecutor(e, t, r) {
    const {
      media: n,
      mediaSource: s,
      operationQueue: o,
      sourceBuffer: a
    } = this, l = a[e];
    if (!n || !s || !l) {
      K.warn(`[buffer-controller]: Attempting to remove from the ${e} SourceBuffer, but it does not exist`), o.shiftAndExecuteNext(e);
      return;
    }
    const u = de(n.duration) ? n.duration : 1 / 0, c = de(s.duration) ? s.duration : 1 / 0, d = Math.max(0, t), h = Math.min(r, u, c);
    h > d && !l.ending ? (l.ended = !1, K.log(`[buffer-controller]: Removing [${d},${h}] from the ${e} SourceBuffer`), l.remove(d, h)) : o.shiftAndExecuteNext(e);
  }
  // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually
  appendExecutor(e, t) {
    const {
      operationQueue: r,
      sourceBuffer: n
    } = this, s = n[t];
    if (!s) {
      K.warn(`[buffer-controller]: Attempting to append to the ${t} SourceBuffer, but it does not exist`), r.shiftAndExecuteNext(t);
      return;
    }
    s.ended = !1, s.appendBuffer(e);
  }
  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
  // upon completion, since we already do it here
  blockBuffers(e, t = this.getSourceBufferTypes()) {
    if (!t.length) {
      K.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e);
      return;
    }
    const {
      operationQueue: r
    } = this, n = t.map((s) => r.appendBlocker(s));
    Promise.all(n).then(() => {
      e(), t.forEach((s) => {
        const o = this.sourceBuffer[s];
        o != null && o.updating || r.shiftAndExecuteNext(s);
      });
    });
  }
  getSourceBufferTypes() {
    return Object.keys(this.sourceBuffer);
  }
  addBufferListener(e, t, r) {
    const n = this.sourceBuffer[e];
    if (!n)
      return;
    const s = r.bind(this, e);
    this.listeners[e].push({
      event: t,
      listener: s
    }), n.addEventListener(t, s);
  }
  removeBufferListeners(e) {
    const t = this.sourceBuffer[e];
    t && this.listeners[e].forEach((r) => {
      t.removeEventListener(r.event, r.listener);
    });
  }
}
const Ia = {
  42: 225,
  // lowercase a, acute accent
  92: 233,
  // lowercase e, acute accent
  94: 237,
  // lowercase i, acute accent
  95: 243,
  // lowercase o, acute accent
  96: 250,
  // lowercase u, acute accent
  123: 231,
  // lowercase c with cedilla
  124: 247,
  // division symbol
  125: 209,
  // uppercase N tilde
  126: 241,
  // lowercase n tilde
  127: 9608,
  // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  128: 174,
  // Registered symbol (R)
  129: 176,
  // degree sign
  130: 189,
  // 1/2 symbol
  131: 191,
  // Inverted (open) question mark
  132: 8482,
  // Trademark symbol (TM)
  133: 162,
  // Cents symbol
  134: 163,
  // Pounds sterling
  135: 9834,
  // Music 8'th note
  136: 224,
  // lowercase a, grave accent
  137: 32,
  // transparent space (regular)
  138: 232,
  // lowercase e, grave accent
  139: 226,
  // lowercase a, circumflex accent
  140: 234,
  // lowercase e, circumflex accent
  141: 238,
  // lowercase i, circumflex accent
  142: 244,
  // lowercase o, circumflex accent
  143: 251,
  // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  144: 193,
  // capital letter A with acute
  145: 201,
  // capital letter E with acute
  146: 211,
  // capital letter O with acute
  147: 218,
  // capital letter U with acute
  148: 220,
  // capital letter U with diaresis
  149: 252,
  // lowercase letter U with diaeresis
  150: 8216,
  // opening single quote
  151: 161,
  // inverted exclamation mark
  152: 42,
  // asterisk
  153: 8217,
  // closing single quote
  154: 9473,
  // box drawings heavy horizontal
  155: 169,
  // copyright sign
  156: 8480,
  // Service mark
  157: 8226,
  // (round) bullet
  158: 8220,
  // Left double quotation mark
  159: 8221,
  // Right double quotation mark
  160: 192,
  // uppercase A, grave accent
  161: 194,
  // uppercase A, circumflex
  162: 199,
  // uppercase C with cedilla
  163: 200,
  // uppercase E, grave accent
  164: 202,
  // uppercase E, circumflex
  165: 203,
  // capital letter E with diaresis
  166: 235,
  // lowercase letter e with diaresis
  167: 206,
  // uppercase I, circumflex
  168: 207,
  // uppercase I, with diaresis
  169: 239,
  // lowercase i, with diaresis
  170: 212,
  // uppercase O, circumflex
  171: 217,
  // uppercase U, grave accent
  172: 249,
  // lowercase u, grave accent
  173: 219,
  // uppercase U, circumflex
  174: 171,
  // left-pointing double angle quotation mark
  175: 187,
  // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  176: 195,
  // Uppercase A, tilde
  177: 227,
  // Lowercase a, tilde
  178: 205,
  // Uppercase I, acute accent
  179: 204,
  // Uppercase I, grave accent
  180: 236,
  // Lowercase i, grave accent
  181: 210,
  // Uppercase O, grave accent
  182: 242,
  // Lowercase o, grave accent
  183: 213,
  // Uppercase O, tilde
  184: 245,
  // Lowercase o, tilde
  185: 123,
  // Open curly brace
  186: 125,
  // Closing curly brace
  187: 92,
  // Backslash
  188: 94,
  // Caret
  189: 95,
  // Underscore
  190: 124,
  // Pipe (vertical line)
  191: 8764,
  // Tilde operator
  192: 196,
  // Uppercase A, umlaut
  193: 228,
  // Lowercase A, umlaut
  194: 214,
  // Uppercase O, umlaut
  195: 246,
  // Lowercase o, umlaut
  196: 223,
  // Esszett (sharp S)
  197: 165,
  // Yen symbol
  198: 164,
  // Generic currency sign
  199: 9475,
  // Box drawings heavy vertical
  200: 197,
  // Uppercase A, ring
  201: 229,
  // Lowercase A, ring
  202: 216,
  // Uppercase O, stroke
  203: 248,
  // Lowercase o, strok
  204: 9487,
  // Box drawings heavy down and right
  205: 9491,
  // Box drawings heavy down and left
  206: 9495,
  // Box drawings heavy up and right
  207: 9499
  // Box drawings heavy up and left
}, gu = function(e) {
  let t = e;
  return Ia.hasOwnProperty(e) && (t = Ia[e]), String.fromCharCode(t);
}, Bt = 15, Xt = 100, yE = {
  17: 1,
  18: 3,
  21: 5,
  22: 7,
  23: 9,
  16: 11,
  19: 12,
  20: 14
}, EE = {
  17: 2,
  18: 4,
  21: 6,
  22: 8,
  23: 10,
  19: 13,
  20: 15
}, AE = {
  25: 1,
  26: 3,
  29: 5,
  30: 7,
  31: 9,
  24: 11,
  27: 12,
  28: 14
}, _E = {
  25: 2,
  26: 4,
  29: 6,
  30: 8,
  31: 10,
  27: 13,
  28: 15
}, xE = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class SE {
  constructor() {
    this.time = null, this.verboseLevel = 0;
  }
  log(e, t) {
    if (this.verboseLevel >= e) {
      const r = typeof t == "function" ? t() : t;
      K.log(`${this.time} [${e}] ${r}`);
    }
  }
}
const vr = function(e) {
  const t = [];
  for (let r = 0; r < e.length; r++)
    t.push(e[r].toString(16));
  return t;
};
class mu {
  constructor(e, t, r, n, s) {
    this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || "white", this.underline = t || !1, this.italics = r || !1, this.background = n || "black", this.flash = s || !1;
  }
  reset() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  setStyles(e) {
    const t = ["foreground", "underline", "italics", "background", "flash"];
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      e.hasOwnProperty(n) && (this[n] = e[n]);
    }
  }
  isDefault() {
    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
  }
  equals(e) {
    return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash;
  }
  copy(e) {
    this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
  }
}
class TE {
  constructor(e, t, r, n, s, o) {
    this.uchar = void 0, this.penState = void 0, this.uchar = e || " ", this.penState = new mu(t, r, n, s, o);
  }
  reset() {
    this.uchar = " ", this.penState.reset();
  }
  setChar(e, t) {
    this.uchar = e, this.penState.copy(t);
  }
  setPenState(e) {
    this.penState.copy(e);
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState);
  }
  copy(e) {
    this.uchar = e.uchar, this.penState.copy(e.penState);
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault();
  }
}
class IE {
  constructor(e) {
    this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
    for (let t = 0; t < Xt; t++)
      this.chars.push(new TE());
    this.logger = e, this.pos = 0, this.currPenState = new mu();
  }
  equals(e) {
    let t = !0;
    for (let r = 0; r < Xt; r++)
      if (!this.chars[r].equals(e.chars[r])) {
        t = !1;
        break;
      }
    return t;
  }
  copy(e) {
    for (let t = 0; t < Xt; t++)
      this.chars[t].copy(e.chars[t]);
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < Xt; t++)
      if (!this.chars[t].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  /**
   *  Set the cursor to a valid column.
   */
  setCursor(e) {
    this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Xt && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = Xt);
  }
  /**
   * Move the cursor relative to current position.
   */
  moveCursor(e) {
    const t = this.pos + e;
    if (e > 1)
      for (let r = this.pos + 1; r < t + 1; r++)
        this.chars[r].setPenState(this.currPenState);
    this.setCursor(t);
  }
  /**
   * Backspace, move one step back and clear character.
   */
  backSpace() {
    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
  }
  insertChar(e) {
    e >= 144 && this.backSpace();
    const t = gu(e);
    if (this.pos >= Xt) {
      this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!");
      return;
    }
    this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1);
  }
  clearFromPos(e) {
    let t;
    for (t = e; t < Xt; t++)
      this.chars[t].reset();
  }
  clear() {
    this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos);
  }
  getTextString() {
    const e = [];
    let t = !0;
    for (let r = 0; r < Xt; r++) {
      const n = this.chars[r].uchar;
      n !== " " && (t = !1), e.push(n);
    }
    return t ? "" : e.join("");
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState);
  }
}
class Vn {
  constructor(e) {
    this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
    for (let t = 0; t < Bt; t++)
      this.rows.push(new IE(e));
    this.logger = e, this.currRow = Bt - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset();
  }
  reset() {
    for (let e = 0; e < Bt; e++)
      this.rows[e].clear();
    this.currRow = Bt - 1;
  }
  equals(e) {
    let t = !0;
    for (let r = 0; r < Bt; r++)
      if (!this.rows[r].equals(e.rows[r])) {
        t = !1;
        break;
      }
    return t;
  }
  copy(e) {
    for (let t = 0; t < Bt; t++)
      this.rows[t].copy(e.rows[t]);
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < Bt; t++)
      if (!this.rows[t].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  backSpace() {
    this.rows[this.currRow].backSpace();
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow();
  }
  /**
   * Insert a character (without styling) in the current row.
   */
  insertChar(e) {
    this.rows[this.currRow].insertChar(e);
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e);
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e);
  }
  setCursor(e) {
    this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e);
  }
  setPAC(e) {
    this.logger.log(2, () => "pacData = " + JSON.stringify(e));
    let t = e.row - 1;
    if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
      for (let a = 0; a < Bt; a++)
        this.rows[a].clear();
      const s = this.currRow + 1 - this.nrRollUpRows, o = this.lastOutputScreen;
      if (o) {
        const a = o.rows[s].cueStartTime, l = this.logger.time;
        if (a && l !== null && a < l)
          for (let u = 0; u < this.nrRollUpRows; u++)
            this.rows[t - this.nrRollUpRows + u + 1].copy(o.rows[s + u]);
      }
    }
    this.currRow = t;
    const r = this.rows[this.currRow];
    if (e.indent !== null) {
      const s = e.indent, o = Math.max(s - 1, 0);
      r.setCursor(e.indent), e.color = r.chars[o].penState.foreground;
    }
    const n = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: "black",
      flash: !1
    };
    this.setPen(n);
  }
  /**
   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
   */
  setBkgData(e) {
    this.logger.log(2, () => "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32);
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e;
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return;
    }
    this.logger.log(1, () => this.getDisplayText());
    const e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0];
    t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up");
  }
  /**
   * Get all non-empty rows with as unicode text.
   */
  getDisplayText(e) {
    e = e || !1;
    const t = [];
    let r = "", n = -1;
    for (let s = 0; s < Bt; s++) {
      const o = this.rows[s].getTextString();
      o && (n = s + 1, e ? t.push("Row " + n + ": '" + o + "'") : t.push(o.trim()));
    }
    return t.length > 0 && (e ? r = "[" + t.join(" | ") + "]" : r = t.join(`
`)), r;
  }
  getTextAndFormat() {
    return this.rows;
  }
}
class ba {
  constructor(e, t, r) {
    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new Vn(r), this.nonDisplayedMemory = new Vn(r), this.lastOutputScreen = new Vn(r), this.currRollUpRow = this.displayedMemory.rows[Bt - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r;
  }
  reset() {
    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[Bt - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
  }
  getHandler() {
    return this.outputFilter;
  }
  setHandler(e) {
    this.outputFilter = e;
  }
  setPAC(e) {
    this.writeScreen.setPAC(e);
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e);
  }
  setMode(e) {
    e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);
  }
  insertChars(e) {
    for (let r = 0; r < e.length; r++)
      this.writeScreen.insertChar(e[r]);
    const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
  }
  ccAOF() {
  }
  ccAON() {
  }
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
  }
  ccRU(e) {
    this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e);
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
      flash: !0
    });
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
  }
  ccTR() {
    this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
  }
  ccRTD() {
    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
  }
  ccEOC() {
    if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
      const e = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
    }
    this.outputDataUpdate(!0);
  }
  ccTO(e) {
    this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e);
  }
  ccMIDROW(e) {
    const t = {
      flash: !1
    };
    if (t.underline = e % 2 === 1, t.italics = e >= 46, t.italics)
      t.foreground = "white";
    else {
      const r = Math.floor(e / 2) - 16, n = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      t.foreground = n[r];
    }
    this.logger.log(2, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t);
  }
  outputDataUpdate(e = !1) {
    const t = this.logger.time;
    t !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t), this.lastOutputScreen.copy(this.displayedMemory));
  }
  cueSplitAtTime(e) {
    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));
  }
}
class La {
  constructor(e, t, r) {
    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
    const n = new SE();
    this.channels = [null, new ba(e, t, n), new ba(e + 1, r, n)], this.cmdHistory = Ra(), this.logger = n;
  }
  getHandler(e) {
    return this.channels[e].getHandler();
  }
  setHandler(e, t) {
    this.channels[e].setHandler(t);
  }
  /**
   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
   */
  addData(e, t) {
    let r, n, s, o = !1;
    this.logger.time = e;
    for (let a = 0; a < t.length; a += 2)
      if (n = t[a] & 127, s = t[a + 1] & 127, !(n === 0 && s === 0)) {
        if (this.logger.log(3, "[" + vr([t[a], t[a + 1]]) + "] -> (" + vr([n, s]) + ")"), r = this.parseCmd(n, s), r || (r = this.parseMidrow(n, s)), r || (r = this.parsePAC(n, s)), r || (r = this.parseBackgroundAttributes(n, s)), !r && (o = this.parseChars(n, s), o)) {
          const l = this.currentChannel;
          l && l > 0 ? this.channels[l].insertChars(o) : this.logger.log(2, "No channel found yet. TEXT-MODE?");
        }
        !r && !o && this.logger.log(2, "Couldn't parse cleaned data " + vr([n, s]) + " orig: " + vr([t[a], t[a + 1]]));
      }
  }
  /**
   * Parse Command.
   * @returns True if a command was found
   */
  parseCmd(e, t) {
    const {
      cmdHistory: r
    } = this, n = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47, s = (e === 23 || e === 31) && t >= 33 && t <= 35;
    if (!(n || s))
      return !1;
    if (Ca(e, t, r))
      return Mr(null, null, r), this.logger.log(3, "Repeated command (" + vr([e, t]) + ") is dropped"), !0;
    const o = e === 20 || e === 21 || e === 23 ? 1 : 2, a = this.channels[o];
    return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? a.ccRCL() : t === 33 ? a.ccBS() : t === 34 ? a.ccAOF() : t === 35 ? a.ccAON() : t === 36 ? a.ccDER() : t === 37 ? a.ccRU(2) : t === 38 ? a.ccRU(3) : t === 39 ? a.ccRU(4) : t === 40 ? a.ccFON() : t === 41 ? a.ccRDC() : t === 42 ? a.ccTR() : t === 43 ? a.ccRTD() : t === 44 ? a.ccEDM() : t === 45 ? a.ccCR() : t === 46 ? a.ccENM() : t === 47 && a.ccEOC() : a.ccTO(t - 32), Mr(e, t, r), this.currentChannel = o, !0;
  }
  /**
   * Parse midrow styling command
   */
  parseMidrow(e, t) {
    let r = 0;
    if ((e === 17 || e === 25) && t >= 32 && t <= 47) {
      if (e === 17 ? r = 1 : r = 2, r !== this.currentChannel)
        return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
      const n = this.channels[r];
      return n ? (n.ccMIDROW(t), this.logger.log(3, "MIDROW (" + vr([e, t]) + ")"), !0) : !1;
    }
    return !1;
  }
  /**
   * Parse Preable Access Codes (Table 53).
   * @returns {Boolean} Tells if PAC found
   */
  parsePAC(e, t) {
    let r;
    const n = this.cmdHistory, s = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127, o = (e === 16 || e === 24) && t >= 64 && t <= 95;
    if (!(s || o))
      return !1;
    if (Ca(e, t, n))
      return Mr(null, null, n), !0;
    const a = e <= 23 ? 1 : 2;
    t >= 64 && t <= 95 ? r = a === 1 ? yE[e] : AE[e] : r = a === 1 ? EE[e] : _E[e];
    const l = this.channels[a];
    return l ? (l.setPAC(this.interpretPAC(r, t)), Mr(e, t, n), this.currentChannel = a, !0) : !1;
  }
  /**
   * Interpret the second byte of the pac, and return the information.
   * @returns pacData with style parameters
   */
  interpretPAC(e, t) {
    let r;
    const n = {
      color: null,
      italics: !1,
      indent: null,
      underline: !1,
      row: e
    };
    return t > 95 ? r = t - 96 : r = t - 64, n.underline = (r & 1) === 1, r <= 13 ? n.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (n.italics = !0, n.color = "white") : n.indent = Math.floor((r - 16) / 2) * 4, n;
  }
  /**
   * Parse characters.
   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
   */
  parseChars(e, t) {
    let r, n = null, s = null;
    if (e >= 25 ? (r = 2, s = e - 8) : (r = 1, s = e), s >= 17 && s <= 19) {
      let o;
      s === 17 ? o = t + 80 : s === 18 ? o = t + 112 : o = t + 144, this.logger.log(2, "Special char '" + gu(o) + "' in channel " + r), n = [o];
    } else
      e >= 32 && e <= 127 && (n = t === 0 ? [e] : [e, t]);
    if (n) {
      const o = vr(n);
      this.logger.log(3, "Char codes =  " + o.join(",")), Mr(e, t, this.cmdHistory);
    }
    return n;
  }
  /**
   * Parse extended background attributes as well as new foreground color black.
   * @returns True if background attributes are found
   */
  parseBackgroundAttributes(e, t) {
    const r = (e === 16 || e === 24) && t >= 32 && t <= 47, n = (e === 23 || e === 31) && t >= 45 && t <= 47;
    if (!(r || n))
      return !1;
    let s;
    const o = {};
    e === 16 || e === 24 ? (s = Math.floor((t - 32) / 2), o.background = xE[s], t % 2 === 1 && (o.background = o.background + "_semi")) : t === 45 ? o.background = "transparent" : (o.foreground = "black", t === 47 && (o.underline = !0));
    const a = e <= 23 ? 1 : 2;
    return this.channels[a].setBkgData(o), Mr(e, t, this.cmdHistory), !0;
  }
  /**
   * Reset state of parser and its channels.
   */
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const t = this.channels[e];
      t && t.reset();
    }
    this.cmdHistory = Ra();
  }
  /**
   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
   */
  cueSplitAtTime(e) {
    for (let t = 0; t < this.channels.length; t++) {
      const r = this.channels[t];
      r && r.cueSplitAtTime(e);
    }
  }
}
function Mr(i, e, t) {
  t.a = i, t.b = e;
}
function Ca(i, e, t) {
  return t.a === i && t.b === e;
}
function Ra() {
  return {
    a: null,
    b: null
  };
}
class Mi {
  constructor(e, t) {
    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t;
  }
  dispatchCue() {
    this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null);
  }
  newCue(e, t, r) {
    (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName);
  }
  reset() {
    this.cueRanges = [], this.startTime = null;
  }
}
var Ws = function() {
  if (typeof self < "u" && self.VTTCue)
    return self.VTTCue;
  const i = ["", "lr", "rl"], e = ["start", "middle", "end", "left", "right"];
  function t(a, l) {
    if (typeof l != "string" || !Array.isArray(a))
      return !1;
    const u = l.toLowerCase();
    return ~a.indexOf(u) ? u : !1;
  }
  function r(a) {
    return t(i, a);
  }
  function n(a) {
    return t(e, a);
  }
  function s(a, ...l) {
    let u = 1;
    for (; u < arguments.length; u++) {
      const c = arguments[u];
      for (const d in c)
        a[d] = c[d];
    }
    return a;
  }
  function o(a, l, u) {
    const c = this, d = {
      enumerable: !0
    };
    c.hasBeenReset = !1;
    let h = "", p = !1, f = a, g = l, m = u, v = null, E = "", A = !0, _ = "auto", y = "start", S = 50, b = "middle", w = 50, P = "middle";
    Object.defineProperty(c, "id", s({}, d, {
      get: function() {
        return h;
      },
      set: function(C) {
        h = "" + C;
      }
    })), Object.defineProperty(c, "pauseOnExit", s({}, d, {
      get: function() {
        return p;
      },
      set: function(C) {
        p = !!C;
      }
    })), Object.defineProperty(c, "startTime", s({}, d, {
      get: function() {
        return f;
      },
      set: function(C) {
        if (typeof C != "number")
          throw new TypeError("Start time must be set to a number.");
        f = C, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "endTime", s({}, d, {
      get: function() {
        return g;
      },
      set: function(C) {
        if (typeof C != "number")
          throw new TypeError("End time must be set to a number.");
        g = C, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "text", s({}, d, {
      get: function() {
        return m;
      },
      set: function(C) {
        m = "" + C, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "region", s({}, d, {
      get: function() {
        return v;
      },
      set: function(C) {
        v = C, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "vertical", s({}, d, {
      get: function() {
        return E;
      },
      set: function(C) {
        const T = r(C);
        if (T === !1)
          throw new SyntaxError("An invalid or illegal string was specified.");
        E = T, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "snapToLines", s({}, d, {
      get: function() {
        return A;
      },
      set: function(C) {
        A = !!C, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "line", s({}, d, {
      get: function() {
        return _;
      },
      set: function(C) {
        if (typeof C != "number" && C !== "auto")
          throw new SyntaxError("An invalid number or illegal string was specified.");
        _ = C, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "lineAlign", s({}, d, {
      get: function() {
        return y;
      },
      set: function(C) {
        const T = n(C);
        if (!T)
          throw new SyntaxError("An invalid or illegal string was specified.");
        y = T, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "position", s({}, d, {
      get: function() {
        return S;
      },
      set: function(C) {
        if (C < 0 || C > 100)
          throw new Error("Position must be between 0 and 100.");
        S = C, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "positionAlign", s({}, d, {
      get: function() {
        return b;
      },
      set: function(C) {
        const T = n(C);
        if (!T)
          throw new SyntaxError("An invalid or illegal string was specified.");
        b = T, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "size", s({}, d, {
      get: function() {
        return w;
      },
      set: function(C) {
        if (C < 0 || C > 100)
          throw new Error("Size must be between 0 and 100.");
        w = C, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "align", s({}, d, {
      get: function() {
        return P;
      },
      set: function(C) {
        const T = n(C);
        if (!T)
          throw new SyntaxError("An invalid or illegal string was specified.");
        P = T, this.hasBeenReset = !0;
      }
    })), c.displayState = void 0;
  }
  return o.prototype.getCueAsHTML = function() {
    return self.WebVTT.convertCueToDOMTree(self, this.text);
  }, o;
}();
class bE {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  decode(e, t) {
    if (!e)
      return "";
    if (typeof e != "string")
      throw new Error("Error - expected string data.");
    return decodeURIComponent(encodeURIComponent(e));
  }
}
function vu(i) {
  function e(r, n, s, o) {
    return (r | 0) * 3600 + (n | 0) * 60 + (s | 0) + parseFloat(o || 0);
  }
  const t = i.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  return t ? parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null;
}
class LE {
  constructor() {
    this.values = /* @__PURE__ */ Object.create(null);
  }
  // Only accept the first assignment to any key.
  set(e, t) {
    !this.get(e) && t !== "" && (this.values[e] = t);
  }
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get(e, t, r) {
    return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t;
  }
  // Check whether we have a value for a key.
  has(e) {
    return e in this.values;
  }
  // Accept a setting if its one of the given alternatives.
  alt(e, t, r) {
    for (let n = 0; n < r.length; ++n)
      if (t === r[n]) {
        this.set(e, t);
        break;
      }
  }
  // Accept a setting if its a valid (signed) integer.
  integer(e, t) {
    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
  }
  // Accept a setting if its a valid percentage.
  percent(e, t) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
      const r = parseFloat(t);
      if (r >= 0 && r <= 100)
        return this.set(e, r), !0;
    }
    return !1;
  }
}
function yu(i, e, t, r) {
  const n = r ? i.split(r) : [i];
  for (const s in n) {
    if (typeof n[s] != "string")
      continue;
    const o = n[s].split(t);
    if (o.length !== 2)
      continue;
    const a = o[0], l = o[1];
    e(a, l);
  }
}
const as = new Ws(0, 0, ""), Bi = as.align === "middle" ? "middle" : "center";
function CE(i, e, t) {
  const r = i;
  function n() {
    const a = vu(i);
    if (a === null)
      throw new Error("Malformed timestamp: " + r);
    return i = i.replace(/^[^\sa-zA-Z-]+/, ""), a;
  }
  function s(a, l) {
    const u = new LE();
    yu(a, function(h, p) {
      let f;
      switch (h) {
        case "region":
          for (let g = t.length - 1; g >= 0; g--)
            if (t[g].id === p) {
              u.set(h, t[g].region);
              break;
            }
          break;
        case "vertical":
          u.alt(h, p, ["rl", "lr"]);
          break;
        case "line":
          f = p.split(","), u.integer(h, f[0]), u.percent(h, f[0]) && u.set("snapToLines", !1), u.alt(h, f[0], ["auto"]), f.length === 2 && u.alt("lineAlign", f[1], ["start", Bi, "end"]);
          break;
        case "position":
          f = p.split(","), u.percent(h, f[0]), f.length === 2 && u.alt("positionAlign", f[1], ["start", Bi, "end", "line-left", "line-right", "auto"]);
          break;
        case "size":
          u.percent(h, p);
          break;
        case "align":
          u.alt(h, p, ["start", Bi, "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/), l.region = u.get("region", null), l.vertical = u.get("vertical", "");
    let c = u.get("line", "auto");
    c === "auto" && as.line === -1 && (c = -1), l.line = c, l.lineAlign = u.get("lineAlign", "start"), l.snapToLines = u.get("snapToLines", !0), l.size = u.get("size", 100), l.align = u.get("align", Bi);
    let d = u.get("position", "auto");
    d === "auto" && as.position === 50 && (d = l.align === "start" || l.align === "left" ? 0 : l.align === "end" || l.align === "right" ? 100 : 50), l.position = d;
  }
  function o() {
    i = i.replace(/^\s+/, "");
  }
  if (o(), e.startTime = n(), o(), i.slice(0, 3) !== "-->")
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + r);
  i = i.slice(3), o(), e.endTime = n(), o(), s(i, e);
}
function Eu(i) {
  return i.replace(/<br(?: \/)?>/gi, `
`);
}
class RE {
  constructor() {
    this.state = "INITIAL", this.buffer = "", this.decoder = new bE(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0;
  }
  parse(e) {
    const t = this;
    e && (t.buffer += t.decoder.decode(e, {
      stream: !0
    }));
    function r() {
      let s = t.buffer, o = 0;
      for (s = Eu(s); o < s.length && s[o] !== "\r" && s[o] !== `
`; )
        ++o;
      const a = s.slice(0, o);
      return s[o] === "\r" && ++o, s[o] === `
` && ++o, t.buffer = s.slice(o), a;
    }
    function n(s) {
      yu(s, function(o, a) {
      }, /:/);
    }
    try {
      let s = "";
      if (t.state === "INITIAL") {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        s = r();
        const a = s.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
        if (!(a != null && a[0]))
          throw new Error("Malformed WebVTT signature.");
        t.state = "HEADER";
      }
      let o = !1;
      for (; t.buffer; ) {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        switch (o ? o = !1 : s = r(), t.state) {
          case "HEADER":
            /:/.test(s) ? n(s) : s || (t.state = "ID");
            continue;
          case "NOTE":
            s || (t.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(s)) {
              t.state = "NOTE";
              break;
            }
            if (!s)
              continue;
            if (t.cue = new Ws(0, 0, ""), t.state = "CUE", s.indexOf("-->") === -1) {
              t.cue.id = s;
              continue;
            }
          case "CUE":
            if (!t.cue) {
              t.state = "BADCUE";
              continue;
            }
            try {
              CE(s, t.cue, t.regionList);
            } catch {
              t.cue = null, t.state = "BADCUE";
              continue;
            }
            t.state = "CUETEXT";
            continue;
          case "CUETEXT":
            {
              const a = s.indexOf("-->") !== -1;
              if (!s || a && (o = !0)) {
                t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID";
                continue;
              }
              if (t.cue === null)
                continue;
              t.cue.text && (t.cue.text += `
`), t.cue.text += s;
            }
            continue;
          case "BADCUE":
            s || (t.state = "ID");
        }
      }
    } catch {
      t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  }
  flush() {
    const e = this;
    try {
      if ((e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL" || e.state === "BADWEBVTT")
        throw new Error("Malformed WebVTT signature.");
    } catch (t) {
      e.onparsingerror && e.onparsingerror(t);
    }
    return e.onflush && e.onflush(), this;
  }
}
const wE = /\r\n|\n\r|\n|\r/g, Hn = function(e, t, r = 0) {
  return e.slice(r, r + t.length) === t;
}, kE = function(e) {
  let t = parseInt(e.slice(-3));
  const r = parseInt(e.slice(-6, -4)), n = parseInt(e.slice(-9, -7)), s = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
  if (!de(t) || !de(r) || !de(n) || !de(s))
    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
  return t += 1e3 * r, t += 60 * 1e3 * n, t += 60 * 60 * 1e3 * s, t;
}, jn = function(e) {
  let t = 5381, r = e.length;
  for (; r; )
    t = t * 33 ^ e.charCodeAt(--r);
  return (t >>> 0).toString();
};
function Qs(i, e, t) {
  return jn(i.toString()) + jn(e.toString()) + jn(t);
}
const DE = function(e, t, r) {
  let n = e[t], s = e[n.prevCC];
  if (!s || !s.new && n.new) {
    e.ccOffset = e.presentationOffset = n.start, n.new = !1;
    return;
  }
  for (; (o = s) != null && o.new; ) {
    var o;
    e.ccOffset += n.start - s.start, n.new = !1, n = s, s = e[n.prevCC];
  }
  e.presentationOffset = r;
};
function OE(i, e, t, r, n, s, o) {
  const a = new RE(), l = Yt(new Uint8Array(i)).trim().replace(wE, `
`).split(`
`), u = [], c = jy(e.baseTime, e.timescale);
  let d = "00:00.000", h = 0, p = 0, f, g = !0;
  a.oncue = function(m) {
    const v = t[r];
    let E = t.ccOffset;
    const A = (h - c) / 9e4;
    v != null && v.new && (p !== void 0 ? E = t.ccOffset = v.start : DE(t, r, A)), A && (E = A - t.presentationOffset);
    const _ = m.endTime - m.startTime, y = Ct((m.startTime + E - p) * 9e4, n * 9e4) / 9e4;
    m.startTime = Math.max(y, 0), m.endTime = Math.max(y + _, 0);
    const S = m.text.trim();
    m.text = decodeURIComponent(encodeURIComponent(S)), m.id || (m.id = Qs(m.startTime, m.endTime, S)), m.endTime > 0 && u.push(m);
  }, a.onparsingerror = function(m) {
    f = m;
  }, a.onflush = function() {
    if (f) {
      o(f);
      return;
    }
    s(u);
  }, l.forEach((m) => {
    if (g)
      if (Hn(m, "X-TIMESTAMP-MAP=")) {
        g = !1, m.slice(16).split(",").forEach((v) => {
          Hn(v, "LOCAL:") ? d = v.slice(6) : Hn(v, "MPEGTS:") && (h = parseInt(v.slice(7)));
        });
        try {
          p = kE(d) / 1e3;
        } catch (v) {
          f = v;
        }
        return;
      } else
        m === "" && (g = !1);
    a.parse(m + `
`);
  }), a.flush();
}
const Wn = "stpp.ttml.im1t", Au = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, _u = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, PE = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
function wa(i, e, t, r) {
  const n = Pe(new Uint8Array(i), ["mdat"]);
  if (n.length === 0) {
    r(new Error("Could not parse IMSC1 mdat"));
    return;
  }
  const s = n.map((a) => Yt(a)), o = Hy(e.baseTime, 1, e.timescale);
  try {
    s.forEach((a) => t(ME(a, o)));
  } catch (a) {
    r(a);
  }
}
function ME(i, e) {
  const n = new DOMParser().parseFromString(i, "text/xml").getElementsByTagName("tt")[0];
  if (!n)
    throw new Error("Invalid ttml");
  const s = {
    frameRate: 30,
    subFrameRate: 1,
    frameRateMultiplier: 0,
    tickRate: 0
  }, o = Object.keys(s).reduce((d, h) => (d[h] = n.getAttribute(`ttp:${h}`) || s[h], d), {}), a = n.getAttribute("xml:space") !== "preserve", l = ka(Qn(n, "styling", "style")), u = ka(Qn(n, "layout", "region")), c = Qn(n, "body", "[begin]");
  return [].map.call(c, (d) => {
    const h = xu(d, a);
    if (!h || !d.hasAttribute("begin"))
      return null;
    const p = Yn(d.getAttribute("begin"), o), f = Yn(d.getAttribute("dur"), o);
    let g = Yn(d.getAttribute("end"), o);
    if (p === null)
      throw Da(d);
    if (g === null) {
      if (f === null)
        throw Da(d);
      g = p + f;
    }
    const m = new Ws(p - e, g - e, h);
    m.id = Qs(m.startTime, m.endTime, m.text);
    const v = u[d.getAttribute("region")], E = l[d.getAttribute("style")], A = BE(v, E, l), {
      textAlign: _
    } = A;
    if (_) {
      const y = PE[_];
      y && (m.lineAlign = y), m.align = _;
    }
    return et(m, A), m;
  }).filter((d) => d !== null);
}
function Qn(i, e, t) {
  const r = i.getElementsByTagName(e)[0];
  return r ? [].slice.call(r.querySelectorAll(t)) : [];
}
function ka(i) {
  return i.reduce((e, t) => {
    const r = t.getAttribute("xml:id");
    return r && (e[r] = t), e;
  }, {});
}
function xu(i, e) {
  return [].slice.call(i.childNodes).reduce((t, r, n) => {
    var s;
    return r.nodeName === "br" && n ? t + `
` : (s = r.childNodes) != null && s.length ? xu(r, e) : e ? t + r.textContent.trim().replace(/\s+/g, " ") : t + r.textContent;
  }, "");
}
function BE(i, e, t) {
  const r = "http://www.w3.org/ns/ttml#styling";
  let n = null;
  const s = [
    "displayAlign",
    "textAlign",
    "color",
    "backgroundColor",
    "fontSize",
    "fontFamily"
    // 'fontWeight',
    // 'lineHeight',
    // 'wrapOption',
    // 'fontStyle',
    // 'direction',
    // 'writingMode'
  ], o = i != null && i.hasAttribute("style") ? i.getAttribute("style") : null;
  return o && t.hasOwnProperty(o) && (n = t[o]), s.reduce((a, l) => {
    const u = Jn(e, r, l) || Jn(i, r, l) || Jn(n, r, l);
    return u && (a[l] = u), a;
  }, {});
}
function Jn(i, e, t) {
  return i && i.hasAttributeNS(e, t) ? i.getAttributeNS(e, t) : null;
}
function Da(i) {
  return new Error(`Could not parse ttml timestamp ${i}`);
}
function Yn(i, e) {
  if (!i)
    return null;
  let t = vu(i);
  return t === null && (Au.test(i) ? t = FE(i, e) : _u.test(i) && (t = NE(i, e))), t;
}
function FE(i, e) {
  const t = Au.exec(i), r = (t[4] | 0) + (t[5] | 0) / e.subFrameRate;
  return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + r / e.frameRate;
}
function NE(i, e) {
  const t = _u.exec(i), r = Number(t[1]);
  switch (t[2]) {
    case "h":
      return r * 3600;
    case "m":
      return r * 60;
    case "ms":
      return r * 1e3;
    case "f":
      return r / e.frameRate;
    case "t":
      return r / e.tickRate;
  }
  return r;
}
class UE {
  constructor(e) {
    if (this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = Oa(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
      textTrack1: {
        label: this.config.captionsTextTrack1Label,
        languageCode: this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: this.config.captionsTextTrack2Label,
        languageCode: this.config.captionsTextTrack2LanguageCode
      },
      textTrack3: {
        label: this.config.captionsTextTrack3Label,
        languageCode: this.config.captionsTextTrack3LanguageCode
      },
      textTrack4: {
        label: this.config.captionsTextTrack4Label,
        languageCode: this.config.captionsTextTrack4LanguageCode
      }
    }, this.config.enableCEA708Captions) {
      const t = new Mi(this, "textTrack1"), r = new Mi(this, "textTrack2"), n = new Mi(this, "textTrack3"), s = new Mi(this, "textTrack4");
      this.cea608Parser1 = new La(1, t, r), this.cea608Parser2 = new La(3, n, s);
    }
    e.on(O.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(O.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(O.FRAG_LOADING, this.onFragLoading, this), e.on(O.FRAG_LOADED, this.onFragLoaded, this), e.on(O.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(O.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(O.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(O.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(O.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  destroy() {
    const {
      hls: e
    } = this;
    e.off(O.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(O.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(O.FRAG_LOADING, this.onFragLoading, this), e.off(O.FRAG_LOADED, this.onFragLoaded, this), e.off(O.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(O.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(O.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(O.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(O.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;
  }
  addCues(e, t, r, n, s) {
    let o = !1;
    for (let a = s.length; a--; ) {
      const l = s[a], u = GE(l[0], l[1], t, r);
      if (u >= 0 && (l[0] = Math.min(l[0], t), l[1] = Math.max(l[1], r), o = !0, u / (r - t) > 0.5))
        return;
    }
    if (o || s.push([t, r]), this.config.renderTextTracksNatively) {
      const a = this.captionsTracks[e];
      this.Cues.newCue(a, t, r, n);
    } else {
      const a = this.Cues.newCue(null, t, r, n);
      this.hls.trigger(O.CUES_PARSED, {
        type: "captions",
        cues: a,
        track: e
      });
    }
  }
  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
  onInitPtsFound(e, {
    frag: t,
    id: r,
    initPTS: n,
    timescale: s
  }) {
    const {
      unparsedVttFrags: o
    } = this;
    r === "main" && (this.initPTS[t.cc] = {
      baseTime: n,
      timescale: s
    }), o.length && (this.unparsedVttFrags = [], o.forEach((a) => {
      this.onFragLoaded(O.FRAG_LOADED, a);
    }));
  }
  getExistingTrack(e) {
    const {
      media: t
    } = this;
    if (t)
      for (let r = 0; r < t.textTracks.length; r++) {
        const n = t.textTracks[r];
        if (n[e])
          return n;
      }
    return null;
  }
  createCaptionsTrack(e) {
    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e);
  }
  createNativeTrack(e) {
    if (this.captionsTracks[e])
      return;
    const {
      captionsProperties: t,
      captionsTracks: r,
      media: n
    } = this, {
      label: s,
      languageCode: o
    } = t[e], a = this.getExistingTrack(e);
    if (a)
      r[e] = a, Kr(r[e]), jl(r[e], n);
    else {
      const l = this.createTextTrack("captions", s, o);
      l && (l[e] = !0, r[e] = l);
    }
  }
  createNonNativeTrack(e) {
    if (this.nonNativeCaptionsTracks[e])
      return;
    const t = this.captionsProperties[e];
    if (!t)
      return;
    const r = t.label, n = {
      _id: e,
      label: r,
      kind: "captions",
      default: t.media ? !!t.media.default : !1,
      closedCaptions: t.media
    };
    this.nonNativeCaptionsTracks[e] = n, this.hls.trigger(O.NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [n]
    });
  }
  createTextTrack(e, t, r) {
    const n = this.media;
    if (n)
      return n.addTextTrack(e, t, r);
  }
  onMediaAttaching(e, t) {
    this.media = t.media, this._cleanTracks();
  }
  onMediaDetaching() {
    const {
      captionsTracks: e
    } = this;
    Object.keys(e).forEach((t) => {
      Kr(e[t]), delete e[t];
    }), this.nonNativeCaptionsTracks = {};
  }
  onManifestLoading() {
    this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = Oa(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset());
  }
  _cleanTracks() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const t = e.textTracks;
    if (t)
      for (let r = 0; r < t.length; r++)
        Kr(t[r]);
  }
  onSubtitleTracksUpdated(e, t) {
    const r = t.subtitleTracks || [], n = r.some((s) => s.textCodec === Wn);
    if (this.config.enableWebVTT || n && this.config.enableIMSC1) {
      if (pu(this.tracks, r)) {
        this.tracks = r;
        return;
      }
      if (this.textTracks = [], this.tracks = r, this.config.renderTextTracksNatively) {
        const o = this.media ? this.media.textTracks : null;
        this.tracks.forEach((a, l) => {
          let u;
          if (o && l < o.length) {
            let c = null;
            for (let d = 0; d < o.length; d++)
              if (KE(o[d], a)) {
                c = o[d];
                break;
              }
            c && (u = c);
          }
          if (u)
            Kr(u);
          else {
            const c = this._captionsOrSubtitlesFromCharacteristics(a);
            u = this.createTextTrack(c, a.name, a.lang), u && (u.mode = "disabled");
          }
          u && (u.groupId = a.groupId, this.textTracks.push(u));
        });
      } else if (this.tracks.length) {
        const o = this.tracks.map((a) => ({
          label: a.name,
          kind: a.type.toLowerCase(),
          default: a.default,
          subtitleTrack: a
        }));
        this.hls.trigger(O.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: o
        });
      }
    }
  }
  _captionsOrSubtitlesFromCharacteristics(e) {
    if (e.attrs.CHARACTERISTICS) {
      const t = /transcribes-spoken-dialog/gi.test(e.attrs.CHARACTERISTICS), r = /describes-music-and-sound/gi.test(e.attrs.CHARACTERISTICS);
      if (t && r)
        return "captions";
    }
    return "subtitles";
  }
  onManifestLoaded(e, t) {
    this.config.enableCEA708Captions && t.captions && t.captions.forEach((r) => {
      const n = /(?:CC|SERVICE)([1-4])/.exec(r.instreamId);
      if (!n)
        return;
      const s = `textTrack${n[1]}`, o = this.captionsProperties[s];
      o && (o.label = r.name, r.lang && (o.languageCode = r.lang), o.media = r);
    });
  }
  closedCaptionsForLevel(e) {
    const t = this.hls.levels[e.level];
    return t == null ? void 0 : t.attrs["CLOSED-CAPTIONS"];
  }
  onFragLoading(e, t) {
    const {
      cea608Parser1: r,
      cea608Parser2: n,
      lastSn: s,
      lastPartIndex: o
    } = this;
    if (!(!this.enabled || !(r && n)) && t.frag.type === ge.MAIN) {
      var a, l;
      const u = t.frag.sn, c = (a = t == null || (l = t.part) == null ? void 0 : l.index) != null ? a : -1;
      u === s + 1 || u === s && c === o + 1 || (r.reset(), n.reset()), this.lastSn = u, this.lastPartIndex = c;
    }
  }
  onFragLoaded(e, t) {
    const {
      frag: r,
      payload: n
    } = t, {
      initPTS: s,
      unparsedVttFrags: o
    } = this;
    if (r.type === ge.SUBTITLE)
      if (n.byteLength) {
        if (!s[r.cc]) {
          o.push(t), s.length && this.hls.trigger(O.SUBTITLE_FRAG_PROCESSED, {
            success: !1,
            frag: r,
            error: new Error("Missing initial subtitle PTS")
          });
          return;
        }
        const a = r.decryptdata, l = "stats" in t;
        if (a == null || !a.encrypted || l) {
          const u = this.tracks[r.level], c = this.vttCCs;
          c[r.cc] || (c[r.cc] = {
            start: r.start,
            prevCC: this.prevCC,
            new: !0
          }, this.prevCC = r.cc), u && u.textCodec === Wn ? this._parseIMSC1(r, n) : this._parseVTTs(r, n, c);
        }
      } else
        this.hls.trigger(O.SUBTITLE_FRAG_PROCESSED, {
          success: !1,
          frag: r,
          error: new Error("Empty subtitle payload")
        });
  }
  _parseIMSC1(e, t) {
    const r = this.hls;
    wa(t, this.initPTS[e.cc], (n) => {
      this._appendCues(n, e.level), r.trigger(O.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: e
      });
    }, (n) => {
      K.log(`Failed to parse IMSC1: ${n}`), r.trigger(O.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: e,
        error: n
      });
    });
  }
  _parseVTTs(e, t, r) {
    var n;
    const s = this.hls, o = (n = e.initSegment) != null && n.data ? Lr(e.initSegment.data, new Uint8Array(t)) : t;
    OE(o, this.initPTS[e.cc], r, e.cc, e.start, (a) => {
      this._appendCues(a, e.level), s.trigger(O.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: e
      });
    }, (a) => {
      this._fallbackToIMSC1(e, t), K.log(`Failed to parse VTT cue: ${a}`), s.trigger(O.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: e,
        error: a
      });
    });
  }
  _fallbackToIMSC1(e, t) {
    const r = this.tracks[e.level];
    r.textCodec || wa(t, this.initPTS[e.cc], () => {
      r.textCodec = Wn, this._parseIMSC1(e, t);
    }, () => {
      r.textCodec = "wvtt";
    });
  }
  _appendCues(e, t) {
    const r = this.hls;
    if (this.config.renderTextTracksNatively) {
      const n = this.textTracks[t];
      if (!n || n.mode === "disabled")
        return;
      e.forEach((s) => Wl(n, s));
    } else {
      const n = this.tracks[t];
      if (!n)
        return;
      const s = n.default ? "default" : "subtitles" + t;
      r.trigger(O.CUES_PARSED, {
        type: "subtitles",
        cues: e,
        track: s
      });
    }
  }
  onFragDecrypted(e, t) {
    const {
      frag: r
    } = t;
    if (r.type === ge.SUBTITLE) {
      if (!this.initPTS[r.cc]) {
        this.unparsedVttFrags.push(t);
        return;
      }
      this.onFragLoaded(O.FRAG_LOADED, t);
    }
  }
  onSubtitleTracksCleared() {
    this.tracks = [], this.captionsTracks = {};
  }
  onFragParsingUserdata(e, t) {
    const {
      cea608Parser1: r,
      cea608Parser2: n
    } = this;
    if (!this.enabled || !(r && n))
      return;
    const {
      frag: s,
      samples: o
    } = t;
    if (!(s.type === ge.MAIN && this.closedCaptionsForLevel(s) === "NONE"))
      for (let a = 0; a < o.length; a++) {
        const l = o[a].bytes;
        if (l) {
          const u = this.extractCea608Data(l);
          r.addData(o[a].pts, u[0]), n.addData(o[a].pts, u[1]);
        }
      }
  }
  onBufferFlushing(e, {
    startOffset: t,
    endOffset: r,
    endOffsetSubtitles: n,
    type: s
  }) {
    const {
      media: o
    } = this;
    if (!(!o || o.currentTime < r)) {
      if (!s || s === "video") {
        const {
          captionsTracks: a
        } = this;
        Object.keys(a).forEach((l) => ts(a[l], t, r));
      }
      if (this.config.renderTextTracksNatively && t === 0 && n !== void 0) {
        const {
          textTracks: a
        } = this;
        Object.keys(a).forEach((l) => ts(a[l], t, n));
      }
    }
  }
  extractCea608Data(e) {
    const t = [[], []], r = e[0] & 31;
    let n = 2;
    for (let s = 0; s < r; s++) {
      const o = e[n++], a = 127 & e[n++], l = 127 & e[n++];
      if (a === 0 && l === 0)
        continue;
      if ((4 & o) !== 0) {
        const c = 3 & o;
        (c === 0 || c === 1) && (t[c].push(a), t[c].push(l));
      }
    }
    return t;
  }
}
function KE(i, e) {
  return !!i && i.label === e.name && !(i.textTrack1 || i.textTrack2);
}
function GE(i, e, t, r) {
  return Math.min(e, r) - Math.max(i, t);
}
function Oa() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: !0
    }
  };
}
class Js {
  constructor(e) {
    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  destroy() {
    this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(O.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(O.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(O.MANIFEST_PARSED, this.onManifestParsed, this), e.on(O.BUFFER_CODECS, this.onBufferCodecs, this), e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListener() {
    const {
      hls: e
    } = this;
    e.off(O.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(O.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(O.MANIFEST_PARSED, this.onManifestParsed, this), e.off(O.BUFFER_CODECS, this.onBufferCodecs, this), e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  onFpsDropLevelCapping(e, t) {
    const r = this.hls.levels[t.droppedLevel];
    this.isLevelAllowed(r) && this.restrictedLevels.push({
      bitrate: r.bitrate,
      height: r.height,
      width: r.width
    });
  }
  onMediaAttaching(e, t) {
    this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null;
  }
  onManifestParsed(e, t) {
    const r = this.hls;
    this.restrictedLevels = [], this.firstLevel = t.firstLevel, r.config.capLevelToPlayerSize && t.video && this.startCapping();
  }
  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
  // to the first level
  onBufferCodecs(e, t) {
    this.hls.config.capLevelToPlayerSize && t.video && this.startCapping();
  }
  onMediaDetaching() {
    this.stopCapping();
  }
  detectPlayerSize() {
    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
      const e = this.hls.levels;
      if (e.length) {
        const t = this.hls;
        t.autoLevelCapping = this.getMaxLevel(e.length - 1), t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping;
      }
    }
  }
  /*
   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
   */
  getMaxLevel(e) {
    const t = this.hls.levels;
    if (!t.length)
      return -1;
    const r = t.filter((n, s) => this.isLevelAllowed(n) && s <= e);
    return this.clientRect = null, Js.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight);
  }
  startCapping() {
    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
  }
  stopCapping() {
    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);
  }
  getDimensions() {
    if (this.clientRect)
      return this.clientRect;
    const e = this.media, t = {
      width: 0,
      height: 0
    };
    if (e) {
      const r = e.getBoundingClientRect();
      t.width = r.width, t.height = r.height, !t.width && !t.height && (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0);
    }
    return this.clientRect = t, t;
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor;
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor;
  }
  get contentScaleFactor() {
    let e = 1;
    if (!this.hls.config.ignoreDevicePixelRatio)
      try {
        e = self.devicePixelRatio;
      } catch {
      }
    return e;
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some((r) => e.bitrate === r.bitrate && e.width === r.width && e.height === r.height);
  }
  static getMaxLevelByMediaSize(e, t, r) {
    if (!(e != null && e.length))
      return -1;
    const n = (o, a) => a ? o.width !== a.width || o.height !== a.height : !0;
    let s = e.length - 1;
    for (let o = 0; o < e.length; o += 1) {
      const a = e[o];
      if ((a.width >= t || a.height >= r) && n(a, e[o + 1])) {
        s = o;
        break;
      }
    }
    return s;
  }
}
class VE {
  // stream controller must be provided as a dependency!
  constructor(e) {
    this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  registerListeners() {
    this.hls.on(O.MEDIA_ATTACHING, this.onMediaAttaching, this);
  }
  unregisterListeners() {
    this.hls.off(O.MEDIA_ATTACHING, this.onMediaAttaching, this);
  }
  destroy() {
    this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;
  }
  onMediaAttaching(e, t) {
    const r = this.hls.config;
    if (r.capLevelOnFPSDrop) {
      const n = t.media instanceof self.HTMLVideoElement ? t.media : null;
      this.media = n, n && typeof n.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod);
    }
  }
  checkFPS(e, t, r) {
    const n = performance.now();
    if (t) {
      if (this.lastTime) {
        const s = n - this.lastTime, o = r - this.lastDroppedFrames, a = t - this.lastDecodedFrames, l = 1e3 * o / s, u = this.hls;
        if (u.trigger(O.FPS_DROP, {
          currentDropped: o,
          currentDecoded: a,
          totalDroppedFrames: r
        }), l > 0 && o > u.config.fpsDroppedMonitoringThreshold * a) {
          let c = u.currentLevel;
          K.warn("drop FPS ratio greater than max allowed value for currentLevel: " + c), c > 0 && (u.autoLevelCapping === -1 || u.autoLevelCapping >= c) && (c = c - 1, u.trigger(O.FPS_DROP_LEVEL_CAPPING, {
            level: c,
            droppedLevel: u.currentLevel
          }), u.autoLevelCapping = c, this.streamController.nextLevelSwitch());
        }
      }
      this.lastTime = n, this.lastDroppedFrames = r, this.lastDecodedFrames = t;
    }
  }
  checkFPSInterval() {
    const e = this.media;
    if (e)
      if (this.isVideoPlaybackQualityAvailable) {
        const t = e.getVideoPlaybackQuality();
        this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);
      } else
        this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);
  }
}
const Fi = "[eme]";
class Vr {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = Vr.CDMCleanupPromise ? [Vr.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = K.debug.bind(K, Fi), this.log = K.log.bind(K, Fi), this.warn = K.warn.bind(K, Fi), this.error = K.error.bind(K, Fi), this.hls = e, this.config = e.config, this.registerListeners();
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached();
    const e = this.config;
    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null;
  }
  registerListeners() {
    this.hls.on(O.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(O.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(O.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(O.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  unregisterListeners() {
    this.hls.off(O.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(O.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(O.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(O.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  getLicenseServerUrl(e) {
    const {
      drmSystems: t,
      widevineLicenseUrl: r
    } = this.config, n = t[e];
    if (n)
      return n.licenseUrl;
    if (e === Qe.WIDEVINE && r)
      return r;
    throw new Error(`no license server URL configured for key-system "${e}"`);
  }
  getServerCertificateUrl(e) {
    const {
      drmSystems: t
    } = this.config, r = t[e];
    if (r)
      return r.serverCertificateUrl;
    this.log(`No Server Certificate in config.drmSystems["${e}"]`);
  }
  attemptKeySystemAccess(e) {
    const t = this.hls.levels, r = (o, a, l) => !!o && l.indexOf(o) === a, n = t.map((o) => o.audioCodec).filter(r), s = t.map((o) => o.videoCodec).filter(r);
    return n.length + s.length === 0 && s.push("avc1.42e01e"), new Promise((o, a) => {
      const l = (u) => {
        const c = u.shift();
        this.getMediaKeysPromise(c, n, s).then((d) => o({
          keySystem: c,
          mediaKeys: d
        })).catch((d) => {
          u.length ? l(u) : d instanceof bt ? a(d) : a(new bt({
            type: fe.KEY_SYSTEM_ERROR,
            details: W.KEY_SYSTEM_NO_ACCESS,
            error: d,
            fatal: !0
          }, d.message));
        });
      };
      l(e);
    });
  }
  requestMediaKeySystemAccess(e, t) {
    const {
      requestMediaKeySystemAccessFunc: r
    } = this.config;
    if (typeof r != "function") {
      let n = `Configured requestMediaKeySystemAccess is not a function ${r}`;
      return Dl === null && self.location.protocol === "http:" && (n = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(n));
    }
    return r(e, t);
  }
  getMediaKeysPromise(e, t, r) {
    const n = rv(e, t, r, this.config.drmSystemOptions), s = this.keySystemAccessPromises[e];
    let o = s == null ? void 0 : s.keySystemAccess;
    if (!o) {
      this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(n)}`), o = this.requestMediaKeySystemAccess(e, n);
      const a = this.keySystemAccessPromises[e] = {
        keySystemAccess: o
      };
      return o.catch((l) => {
        this.log(`Failed to obtain access to key-system "${e}": ${l}`);
      }), o.then((l) => {
        this.log(`Access for key-system "${l.keySystem}" obtained`);
        const u = this.fetchServerCertificate(e);
        return this.log(`Create media-keys for "${e}"`), a.mediaKeys = l.createMediaKeys().then((c) => (this.log(`Media-keys created for "${e}"`), u.then((d) => d ? this.setMediaKeysServerCertificate(c, e, d) : c))), a.mediaKeys.catch((c) => {
          this.error(`Failed to create media-keys for "${e}"}: ${c}`);
        }), a.mediaKeys;
      });
    }
    return o.then(() => s.mediaKeys);
  }
  createMediaKeySessionContext({
    decryptdata: e,
    keySystem: t,
    mediaKeys: r
  }) {
    this.log(`Creating key-system session "${t}" keyId: ${Vt.hexDump(e.keyId || [])}`);
    const n = r.createSession(), s = {
      decryptdata: e,
      keySystem: t,
      mediaKeys: r,
      mediaKeysSession: n,
      keyStatus: "status-pending"
    };
    return this.mediaKeySessions.push(s), s;
  }
  renewKeySession(e) {
    const t = e.decryptdata;
    if (t.pssh) {
      const r = this.createMediaKeySessionContext(e), n = this.getKeyIdString(t), s = "cenc";
      this.keyIdToKeySessionPromise[n] = this.generateRequestWithPreferredKeySession(r, s, t.pssh, "expired");
    } else
      this.warn("Could not renew expired session. Missing pssh initData.");
    this.removeSession(e);
  }
  getKeyIdString(e) {
    if (!e)
      throw new Error("Could not read keyId of undefined decryptdata");
    if (e.keyId === null)
      throw new Error("keyId is null");
    return Vt.hexDump(e.keyId);
  }
  updateKeySession(e, t) {
    var r;
    const n = e.mediaKeysSession;
    return this.log(`Updating key-session "${n.sessionId}" for keyID ${Vt.hexDump(((r = e.decryptdata) == null ? void 0 : r.keyId) || [])}
      } (data length: ${t && t.byteLength})`), n.update(t);
  }
  selectKeySystemFormat(e) {
    const t = Object.keys(e.levelkeys || {});
    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise;
  }
  getKeyFormatPromise(e) {
    return new Promise((t, r) => {
      const n = bn(this.config), s = e.map(jo).filter((o) => !!o && n.indexOf(o) !== -1);
      return this.getKeySystemSelectionPromise(s).then(({
        keySystem: o
      }) => {
        const a = Wo(o);
        a ? t(a) : r(new Error(`Unable to find format for key-system "${o}"`));
      }).catch(r);
    });
  }
  loadKey(e) {
    const t = e.keyInfo.decryptdata, r = this.getKeyIdString(t), n = `(keyId: ${r} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
    this.log(`Starting session for key ${n}`);
    let s = this.keyIdToKeySessionPromise[r];
    return s || (s = this.keyIdToKeySessionPromise[r] = this.getKeySystemForKeyPromise(t).then(({
      keySystem: o,
      mediaKeys: a
    }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${n}`), this.attemptSetMediaKeys(o, a).then(() => {
      this.throwIfDestroyed();
      const l = this.createMediaKeySessionContext({
        keySystem: o,
        mediaKeys: a,
        decryptdata: t
      }), u = "cenc";
      return this.generateRequestWithPreferredKeySession(l, u, t.pssh, "playlist-key");
    }))), s.catch((o) => this.handleError(o))), s;
  }
  throwIfDestroyed(e = "Invalid state") {
    if (!this.hls)
      throw new Error("invalid state");
  }
  handleError(e) {
    this.hls && (this.error(e.message), e instanceof bt ? this.hls.trigger(O.ERROR, e.data) : this.hls.trigger(O.ERROR, {
      type: fe.KEY_SYSTEM_ERROR,
      details: W.KEY_SYSTEM_NO_KEYS,
      error: e,
      fatal: !0
    }));
  }
  getKeySystemForKeyPromise(e) {
    const t = this.getKeyIdString(e), r = this.keyIdToKeySessionPromise[t];
    if (!r) {
      const n = jo(e.keyFormat), s = n ? [n] : bn(this.config);
      return this.attemptKeySystemAccess(s);
    }
    return r;
  }
  getKeySystemSelectionPromise(e) {
    if (e.length || (e = bn(this.config)), e.length === 0)
      throw new bt({
        type: fe.KEY_SYSTEM_ERROR,
        details: W.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
        fatal: !0
      }, `Missing key-system license configuration options ${JSON.stringify({
        drmSystems: this.config.drmSystems
      })}`);
    return this.attemptKeySystemAccess(e);
  }
  _onMediaEncrypted(e) {
    const {
      initDataType: t,
      initData: r
    } = e;
    if (this.debug(`"${e.type}" event: init data type: "${t}"`), r === null)
      return;
    let n, s;
    if (t === "sinf" && this.config.drmSystems[Qe.FAIRPLAY]) {
      const c = ot(new Uint8Array(r));
      try {
        const d = Os(JSON.parse(c).sinf), h = Kl(new Uint8Array(d));
        if (!h)
          return;
        n = h.subarray(8, 24), s = Qe.FAIRPLAY;
      } catch {
        this.warn('Failed to parse sinf "encrypted" event message initData');
        return;
      }
    } else {
      const c = bv(r);
      if (c === null)
        return;
      c.version === 0 && c.systemId === kl.WIDEVINE && c.data && (n = c.data.subarray(8, 24)), s = tv(c.systemId);
    }
    if (!s || !n)
      return;
    const o = Vt.hexDump(n), {
      keyIdToKeySessionPromise: a,
      mediaKeySessions: l
    } = this;
    let u = a[o];
    for (let c = 0; c < l.length; c++) {
      const d = l[c], h = d.decryptdata;
      if (h.pssh || !h.keyId)
        continue;
      const p = Vt.hexDump(h.keyId);
      if (o === p || h.uri.replace(/-/g, "").indexOf(o) !== -1) {
        u = a[p], delete a[p], h.pssh = new Uint8Array(r), h.keyId = n, u = a[o] = u.then(() => this.generateRequestWithPreferredKeySession(d, t, r, "encrypted-event-key-match"));
        break;
      }
    }
    u || (u = a[o] = this.getKeySystemSelectionPromise([s]).then(({
      keySystem: c,
      mediaKeys: d
    }) => {
      var h;
      this.throwIfDestroyed();
      const p = new yi("ISO-23001-7", o, (h = Wo(c)) != null ? h : "");
      return p.pssh = new Uint8Array(r), p.keyId = n, this.attemptSetMediaKeys(c, d).then(() => {
        this.throwIfDestroyed();
        const f = this.createMediaKeySessionContext({
          decryptdata: p,
          keySystem: c,
          mediaKeys: d
        });
        return this.generateRequestWithPreferredKeySession(f, t, r, "encrypted-event-no-match");
      });
    })), u.catch((c) => this.handleError(c));
  }
  _onWaitingForKey(e) {
    this.log(`"${e.type}" event`);
  }
  attemptSetMediaKeys(e, t) {
    const r = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${e}"`);
    const n = Promise.all(r).then(() => {
      if (!this.media)
        throw new Error("Attempted to set mediaKeys without media element attached");
      return this.media.setMediaKeys(t);
    });
    return this.setMediaKeysQueue.push(n), n.then(() => {
      this.log(`Media-keys set for "${e}"`), r.push(n), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((s) => r.indexOf(s) === -1);
    });
  }
  generateRequestWithPreferredKeySession(e, t, r, n) {
    var s, o;
    const a = (s = this.config.drmSystems) == null || (o = s[e.keySystem]) == null ? void 0 : o.generateRequest;
    if (a)
      try {
        const h = a.call(this.hls, t, r, e);
        if (!h)
          throw new Error("Invalid response from configured generateRequest filter");
        t = h.initDataType, r = e.decryptdata.pssh = h.initData ? new Uint8Array(h.initData) : null;
      } catch (h) {
        var l;
        if (this.warn(h.message), (l = this.hls) != null && l.config.debug)
          throw h;
      }
    if (r === null)
      return this.log(`Skipping key-session request for "${n}" (no initData)`), Promise.resolve(e);
    const u = this.getKeyIdString(e.decryptdata);
    this.log(`Generating key-session request for "${n}": ${u} (init data type: ${t} length: ${r ? r.byteLength : null})`);
    const c = new js();
    e.mediaKeysSession.onmessage = (h) => {
      const p = e.mediaKeysSession;
      if (!p) {
        c.emit("error", new Error("invalid state"));
        return;
      }
      const {
        messageType: f,
        message: g
      } = h;
      this.log(`"${f}" message event for session "${p.sessionId}" message size: ${g.byteLength}`), f === "license-request" || f === "license-renewal" ? this.renewLicense(e, g).catch((m) => {
        this.handleError(m), c.emit("error", m);
      }) : f === "license-release" ? e.keySystem === Qe.FAIRPLAY && (this.updateKeySession(e, wl("acknowledged")), this.removeSession(e)) : this.warn(`unhandled media key message type "${f}"`);
    }, e.mediaKeysSession.onkeystatuseschange = (h) => {
      if (!e.mediaKeysSession) {
        c.emit("error", new Error("invalid state"));
        return;
      }
      this.onKeyStatusChange(e);
      const f = e.keyStatus;
      c.emit("keyStatus", f), f === "expired" && (this.warn(`${e.keySystem} expired for key ${u}`), this.renewKeySession(e));
    };
    const d = new Promise((h, p) => {
      c.on("error", p), c.on("keyStatus", (f) => {
        f.startsWith("usable") ? h() : f === "output-restricted" ? p(new bt({
          type: fe.KEY_SYSTEM_ERROR,
          details: W.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
          fatal: !1
        }, "HDCP level output restricted")) : f === "internal-error" ? p(new bt({
          type: fe.KEY_SYSTEM_ERROR,
          details: W.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
          fatal: !0
        }, `key status changed to "${f}"`)) : f === "expired" ? p(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${f}"`);
      });
    });
    return e.mediaKeysSession.generateRequest(t, r).then(() => {
      var h;
      this.log(`Request generated for key-session "${(h = e.mediaKeysSession) == null ? void 0 : h.sessionId}" keyId: ${u}`);
    }).catch((h) => {
      throw new bt({
        type: fe.KEY_SYSTEM_ERROR,
        details: W.KEY_SYSTEM_NO_SESSION,
        error: h,
        fatal: !1
      }, `Error generating key-session request: ${h}`);
    }).then(() => d).catch((h) => {
      throw c.removeAllListeners(), this.removeSession(e), h;
    }).then(() => (c.removeAllListeners(), e));
  }
  onKeyStatusChange(e) {
    e.mediaKeysSession.keyStatuses.forEach((t, r) => {
      this.log(`key status change "${t}" for keyStatuses keyId: ${Vt.hexDump("buffer" in r ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : new Uint8Array(r))} session keyId: ${Vt.hexDump(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`), e.keyStatus = t;
    });
  }
  fetchServerCertificate(e) {
    const t = this.config, r = t.loader, n = new r(t), s = this.getServerCertificateUrl(e);
    return s ? (this.log(`Fetching serverCertificate for "${e}"`), new Promise((o, a) => {
      const l = {
        responseType: "arraybuffer",
        url: s
      }, u = t.certLoadPolicy.default, c = {
        loadPolicy: u,
        timeout: u.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (h, p, f, g) => {
          o(h.data);
        },
        onError: (h, p, f, g) => {
          a(new bt({
            type: fe.KEY_SYSTEM_ERROR,
            details: W.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: f,
            response: Tt({
              url: l.url,
              data: void 0
            }, h)
          }, `"${e}" certificate request failed (${s}). Status: ${h.code} (${h.text})`));
        },
        onTimeout: (h, p, f) => {
          a(new bt({
            type: fe.KEY_SYSTEM_ERROR,
            details: W.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: f,
            response: {
              url: l.url,
              data: void 0
            }
          }, `"${e}" certificate request timed out (${s})`));
        },
        onAbort: (h, p, f) => {
          a(new Error("aborted"));
        }
      };
      n.load(l, c, d);
    })) : Promise.resolve();
  }
  setMediaKeysServerCertificate(e, t, r) {
    return new Promise((n, s) => {
      e.setServerCertificate(r).then((o) => {
        this.log(`setServerCertificate ${o ? "success" : "not supported by CDM"} (${r == null ? void 0 : r.byteLength}) on "${t}"`), n(e);
      }).catch((o) => {
        s(new bt({
          type: fe.KEY_SYSTEM_ERROR,
          details: W.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
          error: o,
          fatal: !0
        }, o.message));
      });
    });
  }
  renewLicense(e, t) {
    return this.requestLicense(e, new Uint8Array(t)).then((r) => this.updateKeySession(e, new Uint8Array(r)).catch((n) => {
      throw new bt({
        type: fe.KEY_SYSTEM_ERROR,
        details: W.KEY_SYSTEM_SESSION_UPDATE_FAILED,
        error: n,
        fatal: !0
      }, n.message);
    }));
  }
  setupLicenseXHR(e, t, r, n) {
    const s = this.config.licenseXhrSetup;
    return s ? Promise.resolve().then(() => {
      if (!r.decryptdata)
        throw new Error("Key removed");
      return s.call(this.hls, e, t, r, n);
    }).catch((o) => {
      if (!r.decryptdata)
        throw o;
      return e.open("POST", t, !0), s.call(this.hls, e, t, r, n);
    }).then((o) => (e.readyState || e.open("POST", t, !0), {
      xhr: e,
      licenseChallenge: o || n
    })) : (e.open("POST", t, !0), Promise.resolve({
      xhr: e,
      licenseChallenge: n
    }));
  }
  requestLicense(e, t) {
    const r = this.config.keyLoadPolicy.default;
    return new Promise((n, s) => {
      const o = this.getLicenseServerUrl(e.keySystem);
      this.log(`Sending license request to URL: ${o}`);
      const a = new XMLHttpRequest();
      a.responseType = "arraybuffer", a.onreadystatechange = () => {
        if (!this.hls || !e.mediaKeysSession)
          return s(new Error("invalid state"));
        if (a.readyState === 4)
          if (a.status === 200) {
            this._requestLicenseFailureCount = 0;
            let l = a.response;
            this.log(`License received ${l instanceof ArrayBuffer ? l.byteLength : l}`);
            const u = this.config.licenseResponseCallback;
            if (u)
              try {
                l = u.call(this.hls, a, o, e);
              } catch (c) {
                this.error(c);
              }
            n(l);
          } else {
            const l = r.errorRetry, u = l ? l.maxNumRetry : 0;
            if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > u || a.status >= 400 && a.status < 500)
              s(new bt({
                type: fe.KEY_SYSTEM_ERROR,
                details: W.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                fatal: !0,
                networkDetails: a,
                response: {
                  url: o,
                  data: void 0,
                  code: a.status,
                  text: a.statusText
                }
              }, `License Request XHR failed (${o}). Status: ${a.status} (${a.statusText})`));
            else {
              const c = u - this._requestLicenseFailureCount + 1;
              this.warn(`Retrying license request, ${c} attempts left`), this.requestLicense(e, t).then(n, s);
            }
          }
      }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = a, this.setupLicenseXHR(a, o, e, t).then(({
        xhr: l,
        licenseChallenge: u
      }) => {
        l.send(u);
      });
    });
  }
  onMediaAttached(e, t) {
    if (!this.config.emeEnabled)
      return;
    const r = t.media;
    this.media = r, r.addEventListener("encrypted", this.onMediaEncrypted), r.addEventListener("waitingforkey", this.onWaitingForKey);
  }
  onMediaDetached() {
    const e = this.media, t = this.mediaKeySessions;
    e && (e.removeEventListener("encrypted", this.onMediaEncrypted), e.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, yi.clearKeyUriToKeyIdMap();
    const r = t.length;
    Vr.CDMCleanupPromise = Promise.all(t.map((n) => this.removeSession(n)).concat(e == null ? void 0 : e.setMediaKeys(null).catch((n) => {
      this.log(`Could not clear media keys: ${n}. media.src: ${e == null ? void 0 : e.src}`);
    }))).then(() => {
      r && (this.log("finished closing key sessions and clearing media keys"), t.length = 0);
    }).catch((n) => {
      this.log(`Could not close sessions and clear media keys: ${n}. media.src: ${e == null ? void 0 : e.src}`);
    });
  }
  onManifestLoading() {
    this.keyFormatPromise = null;
  }
  onManifestLoaded(e, {
    sessionKeys: t
  }) {
    if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) {
      const r = t.reduce((n, s) => (n.indexOf(s.keyFormat) === -1 && n.push(s.keyFormat), n), []);
      this.log(`Selecting key-system from session-keys ${r.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(r);
    }
  }
  removeSession(e) {
    const {
      mediaKeysSession: t,
      licenseXhr: r
    } = e;
    if (t) {
      this.log(`Remove licenses and keys and close session ${t.sessionId}`), t.onmessage = null, t.onkeystatuseschange = null, r && r.readyState !== XMLHttpRequest.DONE && r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
      const n = this.mediaKeySessions.indexOf(e);
      return n > -1 && this.mediaKeySessions.splice(n, 1), t.remove().catch((s) => {
        this.log(`Could not remove session: ${s}`);
      }).then(() => t.close()).catch((s) => {
        this.log(`Could not close session: ${s}`);
      });
    }
  }
}
Vr.CDMCleanupPromise = void 0;
class bt extends Error {
  constructor(e, t) {
    super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error;
  }
}
const HE = 1;
var vt = {
  MANIFEST: "m",
  AUDIO: "a",
  VIDEO: "v",
  MUXED: "av",
  INIT: "i",
  CAPTION: "c",
  TIMED_TEXT: "tt",
  KEY: "k",
  OTHER: "o"
};
const jE = "h";
class ur {
  // eslint-disable-line no-restricted-globals
  // eslint-disable-line no-restricted-globals
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
      this.initialized && (this.starved = !0), this.buffering = !0;
    }, this.onPlaying = () => {
      this.initialized || (this.initialized = !0), this.buffering = !1;
    }, this.applyPlaylistData = (n) => {
      try {
        this.apply(n, {
          ot: vt.MANIFEST,
          su: !this.initialized
        });
      } catch (s) {
        K.warn("Could not generate manifest CMCD data.", s);
      }
    }, this.applyFragmentData = (n) => {
      try {
        const s = n.frag, o = this.hls.levels[s.level], a = this.getObjectType(s), l = {
          d: s.duration * 1e3,
          ot: a
        };
        (a === vt.VIDEO || a === vt.AUDIO || a == vt.MUXED) && (l.br = o.bitrate / 1e3, l.tb = this.getTopBandwidth(a) / 1e3, l.bl = this.getBufferLength(a)), this.apply(n, l);
      } catch (s) {
        K.warn("Could not generate segment CMCD data.", s);
      }
    }, this.hls = e;
    const t = this.config = e.config, {
      cmcd: r
    } = t;
    r != null && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = r.sessionId || ur.uuid(), this.cid = r.contentId, this.useHeaders = r.useHeaders === !0, this.registerListeners());
  }
  registerListeners() {
    const e = this.hls;
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(O.MEDIA_DETACHED, this.onMediaDetached, this), e.on(O.BUFFER_CREATED, this.onBufferCreated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(O.MEDIA_DETACHED, this.onMediaDetached, this), e.off(O.BUFFER_CREATED, this.onBufferCreated, this);
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
  }
  onMediaAttached(e, t) {
    this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying);
  }
  onMediaDetached() {
    this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null);
  }
  onBufferCreated(e, t) {
    var r, n;
    this.audioBuffer = (r = t.tracks.audio) == null ? void 0 : r.buffer, this.videoBuffer = (n = t.tracks.video) == null ? void 0 : n.buffer;
  }
  /**
   * Create baseline CMCD data
   */
  createData() {
    var e;
    return {
      v: HE,
      sf: jE,
      sid: this.sid,
      cid: this.cid,
      pr: (e = this.media) == null ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    };
  }
  /**
   * Apply CMCD data to a request.
   */
  apply(e, t = {}) {
    et(t, this.createData());
    const r = t.ot === vt.INIT || t.ot === vt.VIDEO || t.ot === vt.MUXED;
    if (this.starved && r && (t.bs = !0, t.su = !0, this.starved = !1), t.su == null && (t.su = this.buffering), this.useHeaders) {
      const n = ur.toHeaders(t);
      if (!Object.keys(n).length)
        return;
      e.headers || (e.headers = {}), et(e.headers, n);
    } else {
      const n = ur.toQuery(t);
      if (!n)
        return;
      e.url = ur.appendQueryToUri(e.url, n);
    }
  }
  /**
   * The CMCD object type.
   */
  getObjectType(e) {
    const {
      type: t
    } = e;
    if (t === "subtitle")
      return vt.TIMED_TEXT;
    if (e.sn === "initSegment")
      return vt.INIT;
    if (t === "audio")
      return vt.AUDIO;
    if (t === "main")
      return this.hls.audioTracks.length ? vt.VIDEO : vt.MUXED;
  }
  /**
   * Get the highest bitrate.
   */
  getTopBandwidth(e) {
    let t = 0, r;
    const n = this.hls;
    if (e === vt.AUDIO)
      r = n.audioTracks;
    else {
      const s = n.maxAutoLevel, o = s > -1 ? s + 1 : n.levels.length;
      r = n.levels.slice(0, o);
    }
    for (const s of r)
      s.bitrate > t && (t = s.bitrate);
    return t > 0 ? t : NaN;
  }
  /**
   * Get the buffer length for a media type in milliseconds
   */
  getBufferLength(e) {
    const t = this.hls.media, r = e === vt.AUDIO ? this.audioBuffer : this.videoBuffer;
    return !r || !t ? NaN : je.bufferInfo(r, t.currentTime, this.config.maxBufferHole).len * 1e3;
  }
  /**
   * Create a playlist loader
   */
  createPlaylistLoader() {
    const {
      pLoader: e
    } = this.config, t = this.applyPlaylistData, r = e || this.config.loader;
    return class {
      constructor(s) {
        this.loader = void 0, this.loader = new r(s);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(s, o, a) {
        t(s), this.loader.load(s, o, a);
      }
    };
  }
  /**
   * Create a playlist loader
   */
  createFragmentLoader() {
    const {
      fLoader: e
    } = this.config, t = this.applyFragmentData, r = e || this.config.loader;
    return class {
      constructor(s) {
        this.loader = void 0, this.loader = new r(s);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(s, o, a) {
        t(s), this.loader.load(s, o, a);
      }
    };
  }
  /**
   * Generate a random v4 UUI
   *
   * @returns {string}
   */
  static uuid() {
    const e = URL.createObjectURL(new Blob()), t = e.toString();
    return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1);
  }
  /**
   * Serialize a CMCD data object according to the rules defined in the
   * section 3.2 of
   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).
   */
  static serialize(e) {
    const t = [], r = (u) => !Number.isNaN(u) && u != null && u !== "" && u !== !1, n = (u) => Math.round(u), s = (u) => n(u / 100) * 100, a = {
      br: n,
      d: n,
      bl: s,
      dl: s,
      mtp: s,
      nor: (u) => encodeURIComponent(u),
      rtp: s,
      tb: n
    }, l = Object.keys(e || {}).sort();
    for (const u of l) {
      let c = e[u];
      if (!r(c) || u === "v" && c === 1 || u == "pr" && c === 1)
        continue;
      const d = a[u];
      d && (c = d(c));
      const h = typeof c;
      let p;
      u === "ot" || u === "sf" || u === "st" ? p = `${u}=${c}` : h === "boolean" ? p = u : h === "number" ? p = `${u}=${c}` : p = `${u}=${JSON.stringify(c)}`, t.push(p);
    }
    return t.join(",");
  }
  /**
   * Convert a CMCD data object to request headers according to the rules
   * defined in the section 2.1 and 3.2 of
   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).
   */
  static toHeaders(e) {
    const t = Object.keys(e), r = {}, n = ["Object", "Request", "Session", "Status"], s = [{}, {}, {}, {}], o = {
      br: 0,
      d: 0,
      ot: 0,
      tb: 0,
      bl: 1,
      dl: 1,
      mtp: 1,
      nor: 1,
      nrr: 1,
      su: 1,
      cid: 2,
      pr: 2,
      sf: 2,
      sid: 2,
      st: 2,
      v: 2,
      bs: 3,
      rtp: 3
    };
    for (const a of t) {
      const l = o[a] != null ? o[a] : 1;
      s[l][a] = e[a];
    }
    for (let a = 0; a < s.length; a++) {
      const l = ur.serialize(s[a]);
      l && (r[`CMCD-${n[a]}`] = l);
    }
    return r;
  }
  /**
   * Convert a CMCD data object to query args according to the rules
   * defined in the section 2.2 and 3.2 of
   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).
   */
  static toQuery(e) {
    return `CMCD=${encodeURIComponent(ur.serialize(e))}`;
  }
  /**
   * Append query args to a uri.
   */
  static appendQueryToUri(e, t) {
    if (!t)
      return e;
    const r = e.includes("?") ? "&" : "?";
    return `${e}${r}${t}`;
  }
}
const WE = 3e5;
class QE {
  constructor(e) {
    this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = K.log.bind(K, "[content-steering]:"), this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(O.MANIFEST_LOADING, this.onManifestLoading, this), e.on(O.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(O.MANIFEST_PARSED, this.onManifestParsed, this), e.on(O.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(O.MANIFEST_LOADING, this.onManifestLoading, this), e.off(O.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(O.MANIFEST_PARSED, this.onManifestParsed, this), e.off(O.ERROR, this.onError, this));
  }
  startLoad() {
    if (this.started = !0, self.clearTimeout(this.reloadTimer), this.enabled && this.uri)
      if (this.updated) {
        const e = Math.max(this.timeToLoad * 1e3 - (performance.now() - this.updated), 0);
        this.scheduleRefresh(this.uri, e);
      } else
        this.loadSteeringManifest(this.uri);
  }
  stopLoad() {
    this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), self.clearTimeout(this.reloadTimer);
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  removeLevel(e) {
    const t = this.levels;
    t && (this.levels = t.filter((r) => r !== e));
  }
  onManifestLoading() {
    this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  onManifestLoaded(e, t) {
    const {
      contentSteering: r
    } = t;
    r !== null && (this.pathwayId = r.pathwayId, this.uri = r.uri, this.started && this.startLoad());
  }
  onManifestParsed(e, t) {
    this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks;
  }
  onError(e, t) {
    const {
      errorAction: r
    } = t;
    if ((r == null ? void 0 : r.action) === Et.SendAlternateToPenaltyBox && r.flags === Mt.MoveAllAlternatesMatchingHost) {
      let n = this.pathwayPriority;
      const s = this.pathwayId;
      this.penalizedPathways[s] || (this.penalizedPathways[s] = performance.now()), !n && this.levels && (n = this.levels.reduce((o, a) => (o.indexOf(a.pathwayId) === -1 && o.push(a.pathwayId), o), [])), n && n.length > 1 && (this.updatePathwayPriority(n), r.resolved = this.pathwayId !== s);
    }
  }
  filterParsedLevels(e) {
    this.levels = e;
    let t = this.getLevelsForPathway(this.pathwayId);
    if (t.length === 0) {
      const r = e[0].pathwayId;
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${r}"`), t = this.getLevelsForPathway(r), this.pathwayId = r;
    }
    return t.length !== e.length ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t) : e;
  }
  getLevelsForPathway(e) {
    return this.levels === null ? [] : this.levels.filter((t) => e === t.pathwayId);
  }
  updatePathwayPriority(e) {
    this.pathwayPriority = e;
    let t;
    const r = this.penalizedPathways, n = performance.now();
    Object.keys(r).forEach((s) => {
      n - r[s] > WE && delete r[s];
    });
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (r[o])
        continue;
      if (o === this.pathwayId)
        return;
      const a = this.hls.nextLoadLevel, l = this.hls.levels[a];
      if (t = this.getLevelsForPathway(o), t.length > 0) {
        this.log(`Setting Pathway to "${o}"`), this.pathwayId = o, this.hls.trigger(O.LEVELS_UPDATED, {
          levels: t
        });
        const u = this.hls.levels[a];
        l && u && this.levels && (u.attrs["STABLE-VARIANT-ID"] !== l.attrs["STABLE-VARIANT-ID"] && u.bitrate !== l.bitrate && this.log(`Unstable Pathways change from bitrate ${l.bitrate} to ${u.bitrate}`), this.hls.nextLoadLevel = a);
        break;
      }
    }
  }
  clonePathways(e) {
    const t = this.levels;
    if (!t)
      return;
    const r = {}, n = {};
    e.forEach((s) => {
      const {
        ID: o,
        "BASE-ID": a,
        "URI-REPLACEMENT": l
      } = s;
      if (t.some((c) => c.pathwayId === o))
        return;
      const u = this.getLevelsForPathway(a).map((c) => {
        const d = et({}, c);
        d.details = void 0, d.url = Su(c.uri, c.attrs["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", l);
        const h = new We(c.attrs);
        h["PATHWAY-ID"] = o;
        const p = h.AUDIO && `${h.AUDIO}_clone_${o}`, f = h.SUBTITLES && `${h.SUBTITLES}_clone_${o}`;
        p && (r[h.AUDIO] = p, h.AUDIO = p), f && (n[h.SUBTITLES] = f, h.SUBTITLES = f), d.attrs = h;
        const g = new Ei(d);
        return Xi(g, "audio", p), Xi(g, "text", f), g;
      });
      t.push(...u), Pa(this.audioTracks, r, l, o), Pa(this.subtitleTracks, n, l, o);
    });
  }
  loadSteeringManifest(e) {
    const t = this.hls.config, r = t.loader;
    this.loader && this.loader.destroy(), this.loader = new r(t);
    let n;
    try {
      n = new self.URL(e);
    } catch {
      this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`);
      return;
    }
    if (n.protocol !== "data:") {
      const c = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0;
      n.searchParams.set("_HLS_pathway", this.pathwayId), n.searchParams.set("_HLS_throughput", "" + c);
    }
    const s = {
      responseType: "json",
      url: n.href
    }, o = t.steeringManifestLoadPolicy.default, a = o.errorRetry || o.timeoutRetry || {}, l = {
      loadPolicy: o,
      timeout: o.maxLoadTimeMs,
      maxRetry: a.maxNumRetry || 0,
      retryDelay: a.retryDelayMs || 0,
      maxRetryDelay: a.maxRetryDelayMs || 0
    }, u = {
      onSuccess: (c, d, h, p) => {
        this.log(`Loaded steering manifest: "${n}"`);
        const f = c.data;
        if (f.VERSION !== 1) {
          this.log(`Steering VERSION ${f.VERSION} not supported!`);
          return;
        }
        this.updated = performance.now(), this.timeToLoad = f.TTL;
        const {
          "RELOAD-URI": g,
          "PATHWAY-CLONES": m,
          "PATHWAY-PRIORITY": v
        } = f;
        if (g)
          try {
            this.uri = new self.URL(g, n).href;
          } catch {
            this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${g}`);
            return;
          }
        this.scheduleRefresh(this.uri || h.url), m && this.clonePathways(m), v && this.updatePathwayPriority(v);
      },
      onError: (c, d, h, p) => {
        if (this.log(`Error loading steering manifest: ${c.code} ${c.text} (${d.url})`), this.stopLoad(), c.code === 410) {
          this.enabled = !1, this.log(`Steering manifest ${d.url} no longer available`);
          return;
        }
        let f = this.timeToLoad * 1e3;
        if (c.code === 429) {
          const g = this.loader;
          if (typeof (g == null ? void 0 : g.getResponseHeader) == "function") {
            const m = g.getResponseHeader("Retry-After");
            m && (f = parseFloat(m) * 1e3);
          }
          this.log(`Steering manifest ${d.url} rate limited`);
          return;
        }
        this.scheduleRefresh(this.uri || d.url, f);
      },
      onTimeout: (c, d, h) => {
        this.log(`Timeout loading steering manifest (${d.url})`), this.scheduleRefresh(this.uri || d.url);
      }
    };
    this.log(`Requesting steering manifest: ${n}`), this.loader.load(s, l, u);
  }
  scheduleRefresh(e, t = this.timeToLoad * 1e3) {
    self.clearTimeout(this.reloadTimer), this.reloadTimer = self.setTimeout(() => {
      this.loadSteeringManifest(e);
    }, t);
  }
}
function Pa(i, e, t, r) {
  i && Object.keys(e).forEach((n) => {
    const s = i.filter((o) => o.groupId === n).map((o) => {
      const a = et({}, o);
      return a.details = void 0, a.attrs = new We(a.attrs), a.url = a.attrs.URI = Su(o.url, o.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", t), a.groupId = a.attrs["GROUP-ID"] = e[n], a.attrs["PATHWAY-ID"] = r, a;
    });
    i.push(...s);
  });
}
function Su(i, e, t, r) {
  const {
    HOST: n,
    PARAMS: s,
    [t]: o
  } = r;
  let a;
  e && (a = o == null ? void 0 : o[e], a && (i = a));
  const l = new self.URL(i);
  return n && !a && (l.host = n), s && Object.keys(s).sort().forEach((u) => {
    u && l.searchParams.set(u, s[u]);
  }), l.href;
}
const JE = /^age:\s*[\d.]+\s*$/im;
class Tu {
  constructor(e) {
    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new cn(), this.retryDelay = 0;
  }
  destroy() {
    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null;
  }
  abortInternal() {
    const e = this.loader;
    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort()));
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);
  }
  load(e, t, r) {
    if (this.stats.loading.start)
      throw new Error("Loader can only be used once.");
    this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = r, this.loadInternal();
  }
  loadInternal() {
    const {
      config: e,
      context: t
    } = this;
    if (!e)
      return;
    const r = this.loader = new self.XMLHttpRequest(), n = this.stats;
    n.loading.first = 0, n.loaded = 0;
    const s = this.xhrSetup;
    s ? Promise.resolve().then(() => {
      if (!this.stats.aborted)
        return s(r, t.url);
    }).catch((o) => (r.open("GET", t.url, !0), s(r, t.url))).then(() => {
      this.stats.aborted || this.openAndSendXhr(r, t, e);
    }).catch((o) => {
      this.callbacks.onError({
        code: r.status,
        text: o.message
      }, t, r, n);
    }) : this.openAndSendXhr(r, t, e);
  }
  openAndSendXhr(e, t, r) {
    e.readyState || e.open("GET", t.url, !0);
    const n = this.context.headers, {
      maxTimeToFirstByteMs: s,
      maxLoadTimeMs: o
    } = r.loadPolicy;
    if (n)
      for (const a in n)
        e.setRequestHeader(a, n[a]);
    t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), r.timeout = s && de(s) ? s : o, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send();
  }
  readystatechange() {
    const {
      context: e,
      loader: t,
      stats: r
    } = this;
    if (!e || !t)
      return;
    const n = t.readyState, s = this.config;
    if (!r.aborted && n >= 2 && (r.loading.first === 0 && (r.loading.first = Math.max(self.performance.now(), r.loading.start), s.timeout !== s.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), s.timeout = s.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)))), n === 4)) {
      self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;
      const o = t.status, a = t.responseType !== "text";
      if (o >= 200 && o < 300 && (a && t.response || t.responseText !== null)) {
        r.loading.end = Math.max(self.performance.now(), r.loading.first);
        const l = a ? t.response : t.responseText, u = t.responseType === "arraybuffer" ? l.byteLength : l.length;
        if (r.loaded = r.total = u, r.bwEstimate = r.total * 8e3 / (r.loading.end - r.loading.first), !this.callbacks)
          return;
        const c = this.callbacks.onProgress;
        if (c && c(r, e, l, t), !this.callbacks)
          return;
        const d = {
          url: t.responseURL,
          data: l,
          code: o
        };
        this.callbacks.onSuccess(d, r, e, t);
      } else {
        const l = s.loadPolicy.errorRetry, u = r.retry;
        Zi(l, u, !1, o) ? this.retry(l) : (K.error(`${o} while loading ${e.url}`), this.callbacks.onError({
          code: o,
          text: t.statusText
        }, e, t, r));
      }
    }
  }
  loadtimeout() {
    var e;
    const t = (e = this.config) == null ? void 0 : e.loadPolicy.timeoutRetry, r = this.stats.retry;
    if (Zi(t, r, !0))
      this.retry(t);
    else {
      K.warn(`timeout while loading ${this.context.url}`);
      const n = this.callbacks;
      n && (this.abortInternal(), n.onTimeout(this.stats, this.context, this.loader));
    }
  }
  retry(e) {
    const {
      context: t,
      stats: r
    } = this;
    this.retryDelay = Ms(e, r.retry), r.retry++, K.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t.url}, retrying ${r.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
  }
  loadprogress(e) {
    const t = this.stats;
    t.loaded = e.loaded, e.lengthComputable && (t.total = e.total);
  }
  getCacheAge() {
    let e = null;
    if (this.loader && JE.test(this.loader.getAllResponseHeaders())) {
      const t = this.loader.getResponseHeader("age");
      e = t ? parseFloat(t) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null;
  }
}
function YE() {
  if (
    // @ts-ignore
    self.fetch && self.AbortController && self.ReadableStream && self.Request
  )
    try {
      return new self.ReadableStream({}), !0;
    } catch {
    }
  return !1;
}
const zE = /(\d+)-(\d+)\/(\d+)/;
class Ma {
  constructor(e) {
    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || $E, this.controller = new self.AbortController(), this.stats = new cn();
  }
  destroy() {
    this.loader = this.callbacks = null, this.abortInternal();
  }
  abortInternal() {
    const e = this.response;
    e != null && e.ok || (this.stats.aborted = !0, this.controller.abort());
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);
  }
  load(e, t, r) {
    const n = this.stats;
    if (n.loading.start)
      throw new Error("Loader can only be used once.");
    n.loading.start = self.performance.now();
    const s = qE(e, this.controller.signal), o = r.onProgress, a = e.responseType === "arraybuffer", l = a ? "byteLength" : "length", {
      maxTimeToFirstByteMs: u,
      maxLoadTimeMs: c
    } = t.loadPolicy;
    this.context = e, this.config = t, this.callbacks = r, this.request = this.fetchSetup(e, s), self.clearTimeout(this.requestTimeout), t.timeout = u && de(u) ? u : c, this.requestTimeout = self.setTimeout(() => {
      this.abortInternal(), r.onTimeout(n, e, this.response);
    }, t.timeout), self.fetch(this.request).then((d) => {
      this.response = this.loader = d;
      const h = Math.max(self.performance.now(), n.loading.start);
      if (self.clearTimeout(this.requestTimeout), t.timeout = c, this.requestTimeout = self.setTimeout(() => {
        this.abortInternal(), r.onTimeout(n, e, this.response);
      }, c - (h - n.loading.start)), !d.ok) {
        const {
          status: p,
          statusText: f
        } = d;
        throw new eA(f || "fetch, bad network response", p, d);
      }
      return n.loading.first = h, n.total = XE(d.headers) || n.total, o && de(t.highWaterMark) ? this.loadProgressively(d, n, e, t.highWaterMark, o) : a ? d.arrayBuffer() : e.responseType === "json" ? d.json() : d.text();
    }).then((d) => {
      const {
        response: h
      } = this;
      self.clearTimeout(this.requestTimeout), n.loading.end = Math.max(self.performance.now(), n.loading.first);
      const p = d[l];
      p && (n.loaded = n.total = p);
      const f = {
        url: h.url,
        data: d,
        code: h.status
      };
      o && !de(t.highWaterMark) && o(n, e, d, h), r.onSuccess(f, n, e, h);
    }).catch((d) => {
      if (self.clearTimeout(this.requestTimeout), n.aborted)
        return;
      const h = d && d.code || 0, p = d ? d.message : null;
      r.onError({
        code: h,
        text: p
      }, e, d ? d.details : null, n);
    });
  }
  getCacheAge() {
    let e = null;
    if (this.response) {
      const t = this.response.headers.get("age");
      e = t ? parseFloat(t) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null;
  }
  loadProgressively(e, t, r, n = 0, s) {
    const o = new fu(), a = e.body.getReader(), l = () => a.read().then((u) => {
      if (u.done)
        return o.dataLength && s(t, r, o.flush(), e), Promise.resolve(new ArrayBuffer(0));
      const c = u.value, d = c.length;
      return t.loaded += d, d < n || o.dataLength ? (o.push(c), o.dataLength >= n && s(t, r, o.flush(), e)) : s(t, r, c, e), l();
    }).catch(() => Promise.reject());
    return l();
  }
}
function qE(i, e) {
  const t = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal: e,
    headers: new self.Headers(et({}, i.headers))
  };
  return i.rangeEnd && t.headers.set("Range", "bytes=" + i.rangeStart + "-" + String(i.rangeEnd - 1)), t;
}
function ZE(i) {
  const e = zE.exec(i);
  if (e)
    return parseInt(e[2]) - parseInt(e[1]) + 1;
}
function XE(i) {
  const e = i.get("Content-Range");
  if (e) {
    const r = ZE(e);
    if (de(r))
      return r;
  }
  const t = i.get("Content-Length");
  if (t)
    return parseInt(t);
}
function $E(i, e) {
  return new self.Request(i.url, e);
}
class eA extends Error {
  constructor(e, t, r) {
    super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = r;
  }
}
const tA = /\s/, rA = {
  newCue(i, e, t, r) {
    const n = [];
    let s, o, a, l, u;
    const c = self.VTTCue || self.TextTrackCue;
    for (let h = 0; h < r.rows.length; h++)
      if (s = r.rows[h], a = !0, l = 0, u = "", !s.isEmpty()) {
        var d;
        for (let g = 0; g < s.chars.length; g++)
          tA.test(s.chars[g].uchar) && a ? l++ : (u += s.chars[g].uchar, a = !1);
        s.cueStartTime = e, e === t && (t += 1e-4), l >= 16 ? l-- : l++;
        const p = Eu(u.trim()), f = Qs(e, t, p);
        i != null && (d = i.cues) != null && d.getCueById(f) || (o = new c(e, t, p), o.id = f, o.line = h + 1, o.align = "left", o.position = 10 + Math.min(80, Math.floor(l * 8 / 32) * 10), n.push(o));
      }
    return i && n.length && (n.sort((h, p) => h.line === "auto" || p.line === "auto" ? 0 : h.line > 8 && p.line > 8 ? p.line - h.line : h.line - p.line), n.forEach((h) => Wl(i, h))), n;
  }
}, iA = {
  maxTimeToFirstByteMs: 8e3,
  maxLoadTimeMs: 2e4,
  timeoutRetry: null,
  errorRetry: null
}, nA = Tt(Tt({
  autoStartLoad: !0,
  // used by stream-controller
  startPosition: -1,
  // used by stream-controller
  defaultAudioCodec: void 0,
  // used by stream-controller
  debug: !1,
  // used by logger
  capLevelOnFPSDrop: !1,
  // used by fps-controller
  capLevelToPlayerSize: !1,
  // used by cap-level-controller
  ignoreDevicePixelRatio: !1,
  // used by cap-level-controller
  initialLiveManifestSize: 1,
  // used by stream-controller
  maxBufferLength: 30,
  // used by stream-controller
  backBufferLength: 1 / 0,
  // used by buffer-controller
  maxBufferSize: 60 * 1e3 * 1e3,
  // used by stream-controller
  maxBufferHole: 0.1,
  // used by stream-controller
  highBufferWatchdogPeriod: 2,
  // used by stream-controller
  nudgeOffset: 0.1,
  // used by stream-controller
  nudgeMaxRetry: 3,
  // used by stream-controller
  maxFragLookUpTolerance: 0.25,
  // used by stream-controller
  liveSyncDurationCount: 3,
  // used by latency-controller
  liveMaxLatencyDurationCount: 1 / 0,
  // used by latency-controller
  liveSyncDuration: void 0,
  // used by latency-controller
  liveMaxLatencyDuration: void 0,
  // used by latency-controller
  maxLiveSyncPlaybackRate: 1,
  // used by latency-controller
  liveDurationInfinity: !1,
  // used by buffer-controller
  /**
   * @deprecated use backBufferLength
   */
  liveBackBufferLength: null,
  // used by buffer-controller
  maxMaxBufferLength: 600,
  // used by stream-controller
  enableWorker: !0,
  // used by transmuxer
  workerPath: null,
  // used by transmuxer
  enableSoftwareAES: !0,
  // used by decrypter
  startLevel: void 0,
  // used by level-controller
  startFragPrefetch: !1,
  // used by stream-controller
  fpsDroppedMonitoringPeriod: 5e3,
  // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2,
  // used by fps-controller
  appendErrorMaxRetry: 3,
  // used by buffer-controller
  loader: Tu,
  // loader: FetchLoader,
  fLoader: void 0,
  // used by fragment-loader
  pLoader: void 0,
  // used by playlist-loader
  xhrSetup: void 0,
  // used by xhr-loader
  licenseXhrSetup: void 0,
  // used by eme-controller
  licenseResponseCallback: void 0,
  // used by eme-controller
  abrController: lE,
  bufferController: vE,
  capLevelController: Js,
  errorController: ey,
  fpsController: VE,
  stretchShortVideoTrack: !1,
  // used by mp4-remuxer
  maxAudioFramesDrift: 1,
  // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: !0,
  // used by ts-demuxer
  abrEwmaFastLive: 3,
  // used by abr-controller
  abrEwmaSlowLive: 9,
  // used by abr-controller
  abrEwmaFastVoD: 3,
  // used by abr-controller
  abrEwmaSlowVoD: 9,
  // used by abr-controller
  abrEwmaDefaultEstimate: 5e5,
  // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95,
  // used by abr-controller
  abrBandWidthUpFactor: 0.7,
  // used by abr-controller
  abrMaxWithRealBitrate: !1,
  // used by abr-controller
  maxStarvationDelay: 4,
  // used by abr-controller
  maxLoadingDelay: 4,
  // used by abr-controller
  minAutoBitrate: 0,
  // used by hls
  emeEnabled: !1,
  // used by eme-controller
  widevineLicenseUrl: void 0,
  // used by eme-controller
  drmSystems: {},
  // used by eme-controller
  drmSystemOptions: {},
  // used by eme-controller
  requestMediaKeySystemAccessFunc: Dl,
  // used by eme-controller
  testBandwidth: !0,
  progressive: !1,
  lowLatencyMode: !0,
  cmcd: void 0,
  enableDateRangeMetadataCues: !0,
  enableEmsgMetadataCues: !0,
  enableID3MetadataCues: !0,
  certLoadPolicy: {
    default: iA
  },
  keyLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      },
      errorRetry: {
        maxNumRetry: 8,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      }
    }
  },
  manifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1 / 0,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  playlistLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 2,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  fragLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 12e4,
      timeoutRetry: {
        maxNumRetry: 4,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 6,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  steeringManifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  // These default settings are deprecated in favor of the above policies
  // and are maintained for backwards compatibility
  manifestLoadingTimeOut: 1e4,
  manifestLoadingMaxRetry: 1,
  manifestLoadingRetryDelay: 1e3,
  manifestLoadingMaxRetryTimeout: 64e3,
  levelLoadingTimeOut: 1e4,
  levelLoadingMaxRetry: 4,
  levelLoadingRetryDelay: 1e3,
  levelLoadingMaxRetryTimeout: 64e3,
  fragLoadingTimeOut: 2e4,
  fragLoadingMaxRetry: 6,
  fragLoadingRetryDelay: 1e3,
  fragLoadingMaxRetryTimeout: 64e3
}, sA()), {}, {
  subtitleStreamController: fE,
  subtitleTrackController: gE,
  timelineController: UE,
  audioStreamController: cE,
  audioTrackController: dE,
  emeController: Vr,
  cmcdController: ur,
  contentSteeringController: QE
});
function sA() {
  return {
    cueHandler: rA,
    // used by timeline-controller
    enableWebVTT: !0,
    // used by timeline-controller
    enableIMSC1: !0,
    // used by timeline-controller
    enableCEA708Captions: !0,
    // used by timeline-controller
    captionsTextTrack1Label: "English",
    // used by timeline-controller
    captionsTextTrack1LanguageCode: "en",
    // used by timeline-controller
    captionsTextTrack2Label: "Spanish",
    // used by timeline-controller
    captionsTextTrack2LanguageCode: "es",
    // used by timeline-controller
    captionsTextTrack3Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack3LanguageCode: "",
    // used by timeline-controller
    captionsTextTrack4Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack4LanguageCode: "",
    // used by timeline-controller
    renderTextTracksNatively: !0
  };
}
function oA(i, e) {
  if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration))
    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  const t = ls(i), r = ["manifest", "level", "frag"], n = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  return r.forEach((s) => {
    const o = `${s === "level" ? "playlist" : s}LoadPolicy`, a = e[o] === void 0, l = [];
    n.forEach((u) => {
      const c = `${s}Loading${u}`, d = e[c];
      if (d !== void 0 && a) {
        l.push(c);
        const h = t[o].default;
        switch (e[o] = {
          default: h
        }, u) {
          case "TimeOut":
            h.maxLoadTimeMs = d, h.maxTimeToFirstByteMs = d;
            break;
          case "MaxRetry":
            h.errorRetry.maxNumRetry = d, h.timeoutRetry.maxNumRetry = d;
            break;
          case "RetryDelay":
            h.errorRetry.retryDelayMs = d, h.timeoutRetry.retryDelayMs = d;
            break;
          case "MaxRetryTimeout":
            h.errorRetry.maxRetryDelayMs = d, h.timeoutRetry.maxRetryDelayMs = d;
            break;
        }
      }
    }), l.length && K.warn(`hls.js config: "${l.join('", "')}" setting(s) are deprecated, use "${o}": ${JSON.stringify(e[o])}`);
  }), Tt(Tt({}, t), e);
}
function ls(i) {
  return i && typeof i == "object" ? Array.isArray(i) ? i.map(ls) : Object.keys(i).reduce((e, t) => (e[t] = ls(i[t]), e), {}) : i;
}
function aA(i) {
  const e = i.loader;
  e !== Ma && e !== Tu ? (K.log("[config]: Custom loader detected, cannot enable progressive streaming"), i.progressive = !1) : YE() && (i.loader = Ma, i.progressive = !0, i.enableSoftwareAES = !0, K.log("[config]: Progressive streaming enabled, using FetchLoader"));
}
class rt {
  /**
   * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.
   */
  /**
   * The configuration object provided on player instantiation.
   */
  /**
   * Get the video-dev/hls.js package version.
   */
  static get version() {
    return "1.4.3";
  }
  /**
   * Check if the required MediaSource Extensions are available.
   */
  static isSupported() {
    return Ey();
  }
  static get Events() {
    return O;
  }
  static get ErrorTypes() {
    return fe;
  }
  static get ErrorDetails() {
    return W;
  }
  /**
   * Get the default configuration applied to new instances.
   */
  static get DefaultConfig() {
    return rt.defaultConfig ? rt.defaultConfig : nA;
  }
  /**
   * Replace the default configuration applied to new instances.
   */
  static set DefaultConfig(e) {
    rt.defaultConfig = e;
  }
  /**
   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
   */
  constructor(e = {}) {
    this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new js(), this._autoLevelCapping = void 0, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, Wm(e.debug || !1, "Hls instance");
    const t = this.config = oA(rt.DefaultConfig, e);
    this.userConfig = e, this._autoLevelCapping = -1, t.progressive && aA(t);
    const {
      abrController: r,
      bufferController: n,
      capLevelController: s,
      errorController: o,
      fpsController: a
    } = t, l = new o(this), u = this.abrController = new r(this), c = this.bufferController = new n(this), d = this.capLevelController = new s(this), h = new a(this), p = new Mv(this), f = new Kv(this), g = t.contentSteeringController, m = g ? new g(this) : null, v = this.levelController = new ry(this, m), E = new iy(this), A = new sy(this.config), _ = this.streamController = new oE(this, E, A);
    d.setStreamController(_), h.setStreamController(_);
    const y = [p, v, _];
    m && y.splice(1, 0, m), this.networkControllers = y;
    const S = [u, c, d, h, f, E];
    this.audioTrackController = this.createController(t.audioTrackController, y);
    const b = t.audioStreamController;
    b && y.push(new b(this, E, A)), this.subtitleTrackController = this.createController(t.subtitleTrackController, y);
    const w = t.subtitleStreamController;
    w && y.push(new w(this, E, A)), this.createController(t.timelineController, S), A.emeController = this.emeController = this.createController(t.emeController, S), this.cmcdController = this.createController(t.cmcdController, S), this.latencyController = this.createController(Gv, S), this.coreComponents = S, y.push(l);
    const P = l.onErrorOut;
    typeof P == "function" && this.on(O.ERROR, P, l);
  }
  createController(e, t) {
    if (e) {
      const r = new e(this);
      return t && t.push(r), r;
    }
    return null;
  }
  // Delegate the EventEmitter through the public API of Hls.js
  on(e, t, r = this) {
    this._emitter.on(e, t, r);
  }
  once(e, t, r = this) {
    this._emitter.once(e, t, r);
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e);
  }
  off(e, t, r = this, n) {
    this._emitter.off(e, t, r, n);
  }
  listeners(e) {
    return this._emitter.listeners(e);
  }
  emit(e, t, r) {
    return this._emitter.emit(e, t, r);
  }
  trigger(e, t) {
    if (this.config.debug)
      return this.emit(e, e, t);
    try {
      return this.emit(e, e, t);
    } catch (r) {
      K.error("An internal error happened while handling event " + e + '. Error message: "' + r.message + '". Here is a stacktrace:', r), this.trigger(O.ERROR, {
        type: fe.OTHER_ERROR,
        details: W.INTERNAL_EXCEPTION,
        fatal: !1,
        event: e,
        error: r
      });
    }
    return !1;
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e);
  }
  /**
   * Dispose of the instance
   */
  destroy() {
    K.log("destroy"), this.trigger(O.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach((t) => t.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach((t) => t.destroy()), this.coreComponents.length = 0;
    const e = this.config;
    e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null;
  }
  /**
   * Attaches Hls.js to a media element
   */
  attachMedia(e) {
    K.log("attachMedia"), this._media = e, this.trigger(O.MEDIA_ATTACHING, {
      media: e
    });
  }
  /**
   * Detach Hls.js from the media
   */
  detachMedia() {
    K.log("detachMedia"), this.trigger(O.MEDIA_DETACHING, void 0), this._media = null;
  }
  /**
   * Set the source URL. Can be relative or absolute.
   */
  loadSource(e) {
    this.stopLoad();
    const t = this.media, r = this.url, n = this.url = Ds.buildAbsoluteURL(self.location.href, e, {
      alwaysNormalize: !0
    });
    K.log(`loadSource:${n}`), t && r && (r !== n || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(O.MANIFEST_LOADING, {
      url: e
    });
  }
  /**
   * Start loading data from the stream source.
   * Depending on default config, client starts loading automatically when a source is set.
   *
   * @param startPosition - Set the start position to stream from.
   * Defaults to -1 (None: starts from earliest point)
   */
  startLoad(e = -1) {
    K.log(`startLoad(${e})`), this.networkControllers.forEach((t) => {
      t.startLoad(e);
    });
  }
  /**
   * Stop loading of any stream data.
   */
  stopLoad() {
    K.log("stopLoad"), this.networkControllers.forEach((e) => {
      e.stopLoad();
    });
  }
  /**
   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
   */
  swapAudioCodec() {
    K.log("swapAudioCodec"), this.streamController.swapAudioCodec();
  }
  /**
   * When the media-element fails, this allows to detach and then re-attach it
   * as one call (convenience method).
   *
   * Automatic recovery of media-errors by this process is configurable.
   */
  recoverMediaError() {
    K.log("recoverMediaError");
    const e = this._media;
    this.detachMedia(), e && this.attachMedia(e);
  }
  removeLevel(e, t = 0) {
    this.levelController.removeLevel(e, t);
  }
  /**
   * @returns an array of levels (variants) sorted by HDCP-LEVEL, BANDWIDTH, SCORE, and RESOLUTION (height)
   */
  get levels() {
    const e = this.levelController.levels;
    return e || [];
  }
  /**
   * Index of quality level (variant) currently played
   */
  get currentLevel() {
    return this.streamController.currentLevel;
  }
  /**
   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
   */
  set currentLevel(e) {
    K.log(`set currentLevel:${e}`), this.loadLevel = e, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch();
  }
  /**
   * Index of next quality level loaded as scheduled by stream controller.
   */
  get nextLevel() {
    return this.streamController.nextLevel;
  }
  /**
   * Set quality level index for next loaded data.
   * This will switch the video quality asap, without interrupting playback.
   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
   * @param newLevel - Pass -1 for automatic level selection
   */
  set nextLevel(e) {
    K.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();
  }
  /**
   * Return the quality level of the currently or last (of none is loaded currently) segment
   */
  get loadLevel() {
    return this.levelController.level;
  }
  /**
   * Set quality level index for next loaded data in a conservative way.
   * This will switch the quality without flushing, but interrupt current loading.
   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
   * @param newLevel - Pass -1 for automatic level selection
   */
  set loadLevel(e) {
    K.log(`set loadLevel:${e}`), this.levelController.manualLevel = e;
  }
  /**
   * get next quality level loaded
   */
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel;
  }
  /**
   * Set quality level of next loaded segment in a fully "non-destructive" way.
   * Same as `loadLevel` but will wait for next switch (until current loading is done).
   */
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e;
  }
  /**
   * Return "first level": like a default level, if not set,
   * falls back to index of first level referenced in manifest
   */
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
  }
  /**
   * Sets "first-level", see getter.
   */
  set firstLevel(e) {
    K.log(`set firstLevel:${e}`), this.levelController.firstLevel = e;
  }
  /**
   * Return start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */
  get startLevel() {
    return this.levelController.startLevel;
  }
  /**
   * set  start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */
  set startLevel(e) {
    K.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;
  }
  /**
   * Whether level capping is enabled.
   * Default value is set via `config.capLevelToPlayerSize`.
   */
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize;
  }
  /**
   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
   */
  set capLevelToPlayerSize(e) {
    const t = !!e;
    t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t);
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  get autoLevelCapping() {
    return this._autoLevelCapping;
  }
  /**
   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
   */
  get bandwidthEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimate() : NaN;
  }
  /**
   * get time to first byte estimate
   * @type {number}
   */
  get ttfbEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimateTTFB() : NaN;
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e && (K.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e);
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel;
  }
  set maxHdcpLevel(e) {
    is.indexOf(e) > -1 && (this._maxHdcpLevel = e);
  }
  /**
   * True when automatic level selection enabled
   */
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1;
  }
  /**
   * Level set manually (if any)
   */
  get manualLevel() {
    return this.levelController.manualLevel;
  }
  /**
   * min level selectable in auto mode according to config.minAutoBitrate
   */
  get minAutoLevel() {
    const {
      levels: e,
      config: {
        minAutoBitrate: t
      }
    } = this;
    if (!e)
      return 0;
    const r = e.length;
    for (let n = 0; n < r; n++)
      if (e[n].maxBitrate >= t)
        return n;
    return 0;
  }
  /**
   * max level selectable in auto mode according to autoLevelCapping
   */
  get maxAutoLevel() {
    const {
      levels: e,
      autoLevelCapping: t,
      maxHdcpLevel: r
    } = this;
    let n;
    if (t === -1 && e && e.length ? n = e.length - 1 : n = t, r)
      for (let s = n; s--; ) {
        const o = e[s].attrs["HDCP-LEVEL"];
        if (o && o <= r)
          return s;
      }
    return n;
  }
  /**
   * next automatically selected quality level
   */
  get nextAutoLevel() {
    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);
  }
  /**
   * this setter is used to force next auto level.
   * this is useful to force a switch down in auto mode:
   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
   * forced value is valid for one fragment. upon successful frag loading at forced level,
   * this value will be resetted to -1 by ABR controller.
   */
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e);
  }
  /**
   * get the datetime value relative to media.currentTime for the active level Program Date Time if present
   */
  get playingDate() {
    return this.streamController.currentProgramDateTime;
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo();
  }
  /**
   * Get the list of selectable audio tracks
   */
  get audioTracks() {
    const e = this.audioTrackController;
    return e ? e.audioTracks : [];
  }
  /**
   * index of the selected audio track (index in audio track lists)
   */
  get audioTrack() {
    const e = this.audioTrackController;
    return e ? e.audioTrack : -1;
  }
  /**
   * selects an audio track, based on its index in audio track lists
   */
  set audioTrack(e) {
    const t = this.audioTrackController;
    t && (t.audioTrack = e);
  }
  /**
   * get alternate subtitle tracks list from playlist
   */
  get subtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTracks : [];
  }
  /**
   * index of the selected subtitle track (index in subtitle track lists)
   */
  get subtitleTrack() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTrack : -1;
  }
  get media() {
    return this._media;
  }
  /**
   * select an subtitle track, based on its index in subtitle track lists
   */
  set subtitleTrack(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleTrack = e);
  }
  /**
   * Whether subtitle display is enabled or not
   */
  get subtitleDisplay() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleDisplay : !1;
  }
  /**
   * Enable/disable subtitle display rendering
   */
  set subtitleDisplay(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleDisplay = e);
  }
  /**
   * get mode for Low-Latency HLS loading
   */
  get lowLatencyMode() {
    return this.config.lowLatencyMode;
  }
  /**
   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
   */
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e;
  }
  /**
   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
   * @returns null prior to loading live Playlist
   */
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition;
  }
  /**
   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
   * @returns 0 before first playlist is loaded
   */
  get latency() {
    return this.latencyController.latency;
  }
  /**
   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
   * @returns 0 before first playlist is loaded
   */
  get maxLatency() {
    return this.latencyController.maxLatency;
  }
  /**
   * target distance from the edge as calculated by the latency controller
   */
  get targetLatency() {
    return this.latencyController.targetLatency;
  }
  /**
   * the rate at which the edge of the current live playlist is advancing or 1 if there is none
   */
  get drift() {
    return this.latencyController.drift;
  }
  /**
   * set to true when startLoad is called before MANIFEST_PARSED event
   */
  get forceStartLoad() {
    return this.streamController.forceStartLoad;
  }
}
rt.defaultConfig = void 0;
var Iu = { exports: {} };
(function(i, e) {
  (function(r, n) {
    i.exports = n();
  })(self, function() {
    return (
      /******/
      function() {
        var t = {
          /***/
          "./node_modules/es6-promise/dist/es6-promise.js": (
            /*!******************************************************!*\
              !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
              \******************************************************/
            /***/
            function(o, a, l) {
              /*!
               * @overview es6-promise - a tiny implementation of Promises/A+.
               * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
               * @license   Licensed under MIT license
               *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
               * @version   v4.2.8+1e68dce6
               */
              (function(u, c) {
                o.exports = c();
              })(this, function() {
                function u(Q) {
                  var $ = typeof Q;
                  return Q !== null && ($ === "object" || $ === "function");
                }
                function c(Q) {
                  return typeof Q == "function";
                }
                var d = void 0;
                Array.isArray ? d = Array.isArray : d = function(Q) {
                  return Object.prototype.toString.call(Q) === "[object Array]";
                };
                var h = d, p = 0, f = void 0, g = void 0, m = function($, re) {
                  L[p] = $, L[p + 1] = re, p += 2, p === 2 && (g ? g(I) : B());
                };
                function v(Q) {
                  g = Q;
                }
                function E(Q) {
                  m = Q;
                }
                var A = typeof window < "u" ? window : void 0, _ = A || {}, y = _.MutationObserver || _.WebKitMutationObserver, S = typeof self > "u" && typeof process < "u" && {}.toString.call(process) === "[object process]", b = typeof Uint8ClampedArray < "u" && typeof importScripts < "u" && typeof MessageChannel < "u";
                function w() {
                  return function() {
                    return process.nextTick(I);
                  };
                }
                function P() {
                  return typeof f < "u" ? function() {
                    f(I);
                  } : x();
                }
                function C() {
                  var Q = 0, $ = new y(I), re = document.createTextNode("");
                  return $.observe(re, { characterData: !0 }), function() {
                    re.data = Q = ++Q % 2;
                  };
                }
                function T() {
                  var Q = new MessageChannel();
                  return Q.port1.onmessage = I, function() {
                    return Q.port2.postMessage(0);
                  };
                }
                function x() {
                  var Q = setTimeout;
                  return function() {
                    return Q(I, 1);
                  };
                }
                var L = new Array(1e3);
                function I() {
                  for (var Q = 0; Q < p; Q += 2) {
                    var $ = L[Q], re = L[Q + 1];
                    $(re), L[Q] = void 0, L[Q + 1] = void 0;
                  }
                  p = 0;
                }
                function R() {
                  try {
                    var Q = Function("return this")().require("vertx");
                    return f = Q.runOnLoop || Q.runOnContext, P();
                  } catch {
                    return x();
                  }
                }
                var B = void 0;
                S ? B = w() : y ? B = C() : b ? B = T() : A === void 0 ? B = R() : B = x();
                function D(Q, $) {
                  var re = this, ue = new this.constructor(U);
                  ue[F] === void 0 && be(ue);
                  var ve = re._state;
                  if (ve) {
                    var xe = arguments[ve - 1];
                    m(function() {
                      return Ve(ve, ue, xe, re._result);
                    });
                  } else
                    Ae(re, ue, Q, $);
                  return ue;
                }
                function k(Q) {
                  var $ = this;
                  if (Q && typeof Q == "object" && Q.constructor === $)
                    return Q;
                  var re = new $(U);
                  return ae(re, Q), re;
                }
                var F = Math.random().toString(36).substring(2);
                function U() {
                }
                var G = void 0, N = 1, V = 2;
                function j() {
                  return new TypeError("You cannot resolve a promise with itself");
                }
                function ee() {
                  return new TypeError("A promises callback cannot return that same promise.");
                }
                function Y(Q, $, re, ue) {
                  try {
                    Q.call($, re, ue);
                  } catch (ve) {
                    return ve;
                  }
                }
                function te(Q, $, re) {
                  m(function(ue) {
                    var ve = !1, xe = Y(re, $, function(qe) {
                      ve || (ve = !0, $ !== qe ? ae(ue, qe) : ce(ue, qe));
                    }, function(qe) {
                      ve || (ve = !0, ie(ue, qe));
                    }, "Settle: " + (ue._label || " unknown promise"));
                    !ve && xe && (ve = !0, ie(ue, xe));
                  }, Q);
                }
                function oe(Q, $) {
                  $._state === N ? ce(Q, $._result) : $._state === V ? ie(Q, $._result) : Ae($, void 0, function(re) {
                    return ae(Q, re);
                  }, function(re) {
                    return ie(Q, re);
                  });
                }
                function pe(Q, $, re) {
                  $.constructor === Q.constructor && re === D && $.constructor.resolve === k ? oe(Q, $) : re === void 0 ? ce(Q, $) : c(re) ? te(Q, $, re) : ce(Q, $);
                }
                function ae(Q, $) {
                  if (Q === $)
                    ie(Q, j());
                  else if (u($)) {
                    var re = void 0;
                    try {
                      re = $.then;
                    } catch (ue) {
                      ie(Q, ue);
                      return;
                    }
                    pe(Q, $, re);
                  } else
                    ce(Q, $);
                }
                function Ie(Q) {
                  Q._onerror && Q._onerror(Q._result), we(Q);
                }
                function ce(Q, $) {
                  Q._state === G && (Q._result = $, Q._state = N, Q._subscribers.length !== 0 && m(we, Q));
                }
                function ie(Q, $) {
                  Q._state === G && (Q._state = V, Q._result = $, m(Ie, Q));
                }
                function Ae(Q, $, re, ue) {
                  var ve = Q._subscribers, xe = ve.length;
                  Q._onerror = null, ve[xe] = $, ve[xe + N] = re, ve[xe + V] = ue, xe === 0 && Q._state && m(we, Q);
                }
                function we(Q) {
                  var $ = Q._subscribers, re = Q._state;
                  if ($.length !== 0) {
                    for (var ue = void 0, ve = void 0, xe = Q._result, qe = 0; qe < $.length; qe += 3)
                      ue = $[qe], ve = $[qe + re], ue ? Ve(re, ue, ve, xe) : ve(xe);
                    Q._subscribers.length = 0;
                  }
                }
                function Ve(Q, $, re, ue) {
                  var ve = c(re), xe = void 0, qe = void 0, Zt = !0;
                  if (ve) {
                    try {
                      xe = re(ue);
                    } catch (Rr) {
                      Zt = !1, qe = Rr;
                    }
                    if ($ === xe) {
                      ie($, ee());
                      return;
                    }
                  } else
                    xe = ue;
                  $._state !== G || (ve && Zt ? ae($, xe) : Zt === !1 ? ie($, qe) : Q === N ? ce($, xe) : Q === V && ie($, xe));
                }
                function He(Q, $) {
                  try {
                    $(function(ue) {
                      ae(Q, ue);
                    }, function(ue) {
                      ie(Q, ue);
                    });
                  } catch (re) {
                    ie(Q, re);
                  }
                }
                var Ge = 0;
                function Me() {
                  return Ge++;
                }
                function be(Q) {
                  Q[F] = Ge++, Q._state = void 0, Q._result = void 0, Q._subscribers = [];
                }
                function Ne() {
                  return new Error("Array Methods must be provided an Array");
                }
                var Ue = function() {
                  function Q($, re) {
                    this._instanceConstructor = $, this.promise = new $(U), this.promise[F] || be(this.promise), h(re) ? (this.length = re.length, this._remaining = re.length, this._result = new Array(this.length), this.length === 0 ? ce(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(re), this._remaining === 0 && ce(this.promise, this._result))) : ie(this.promise, Ne());
                  }
                  return Q.prototype._enumerate = function(re) {
                    for (var ue = 0; this._state === G && ue < re.length; ue++)
                      this._eachEntry(re[ue], ue);
                  }, Q.prototype._eachEntry = function(re, ue) {
                    var ve = this._instanceConstructor, xe = ve.resolve;
                    if (xe === k) {
                      var qe = void 0, Zt = void 0, Rr = !1;
                      try {
                        qe = re.then;
                      } catch (gr) {
                        Rr = !0, Zt = gr;
                      }
                      if (qe === D && re._state !== G)
                        this._settledAt(re._state, ue, re._result);
                      else if (typeof qe != "function")
                        this._remaining--, this._result[ue] = re;
                      else if (ve === Ye) {
                        var wr = new ve(U);
                        Rr ? ie(wr, Zt) : pe(wr, re, qe), this._willSettleAt(wr, ue);
                      } else
                        this._willSettleAt(new ve(function(gr) {
                          return gr(re);
                        }), ue);
                    } else
                      this._willSettleAt(xe(re), ue);
                  }, Q.prototype._settledAt = function(re, ue, ve) {
                    var xe = this.promise;
                    xe._state === G && (this._remaining--, re === V ? ie(xe, ve) : this._result[ue] = ve), this._remaining === 0 && ce(xe, this._result);
                  }, Q.prototype._willSettleAt = function(re, ue) {
                    var ve = this;
                    Ae(re, void 0, function(xe) {
                      return ve._settledAt(N, ue, xe);
                    }, function(xe) {
                      return ve._settledAt(V, ue, xe);
                    });
                  }, Q;
                }();
                function tt(Q) {
                  return new Ue(this, Q).promise;
                }
                function Z(Q) {
                  var $ = this;
                  return h(Q) ? new $(function(re, ue) {
                    for (var ve = Q.length, xe = 0; xe < ve; xe++)
                      $.resolve(Q[xe]).then(re, ue);
                  }) : new $(function(re, ue) {
                    return ue(new TypeError("You must pass an array to race."));
                  });
                }
                function Le(Q) {
                  var $ = this, re = new $(U);
                  return ie(re, Q), re;
                }
                function Je() {
                  throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                }
                function ft() {
                  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                }
                var Ye = function() {
                  function Q($) {
                    this[F] = Me(), this._result = this._state = void 0, this._subscribers = [], U !== $ && (typeof $ != "function" && Je(), this instanceof Q ? He(this, $) : ft());
                  }
                  return Q.prototype.catch = function(re) {
                    return this.then(null, re);
                  }, Q.prototype.finally = function(re) {
                    var ue = this, ve = ue.constructor;
                    return c(re) ? ue.then(function(xe) {
                      return ve.resolve(re()).then(function() {
                        return xe;
                      });
                    }, function(xe) {
                      return ve.resolve(re()).then(function() {
                        throw xe;
                      });
                    }) : ue.then(re, re);
                  }, Q;
                }();
                Ye.prototype.then = D, Ye.all = tt, Ye.race = Z, Ye.resolve = k, Ye.reject = Le, Ye._setScheduler = v, Ye._setAsap = E, Ye._asap = m;
                function pn() {
                  var Q = void 0;
                  if (typeof l.g < "u")
                    Q = l.g;
                  else if (typeof self < "u")
                    Q = self;
                  else
                    try {
                      Q = Function("return this")();
                    } catch {
                      throw new Error("polyfill failed because global object is unavailable in this environment");
                    }
                  var $ = Q.Promise;
                  if ($) {
                    var re = null;
                    try {
                      re = Object.prototype.toString.call($.resolve());
                    } catch {
                    }
                    if (re === "[object Promise]" && !$.cast)
                      return;
                  }
                  Q.Promise = Ye;
                }
                return Ye.polyfill = pn, Ye.Promise = Ye, Ye;
              });
            }
          ),
          /***/
          "./node_modules/events/events.js": (
            /*!***************************************!*\
              !*** ./node_modules/events/events.js ***!
              \***************************************/
            /***/
            function(o) {
              var a = typeof Reflect == "object" ? Reflect : null, l = a && typeof a.apply == "function" ? a.apply : function(x, L, I) {
                return Function.prototype.apply.call(x, L, I);
              }, u;
              a && typeof a.ownKeys == "function" ? u = a.ownKeys : Object.getOwnPropertySymbols ? u = function(x) {
                return Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));
              } : u = function(x) {
                return Object.getOwnPropertyNames(x);
              };
              function c(T) {
                console && console.warn && console.warn(T);
              }
              var d = Number.isNaN || function(x) {
                return x !== x;
              };
              function h() {
                h.init.call(this);
              }
              o.exports = h, o.exports.once = w, h.EventEmitter = h, h.prototype._events = void 0, h.prototype._eventsCount = 0, h.prototype._maxListeners = void 0;
              var p = 10;
              function f(T) {
                if (typeof T != "function")
                  throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof T);
              }
              Object.defineProperty(h, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                  return p;
                },
                set: function(T) {
                  if (typeof T != "number" || T < 0 || d(T))
                    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + T + ".");
                  p = T;
                }
              }), h.init = function() {
                (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
              }, h.prototype.setMaxListeners = function(x) {
                if (typeof x != "number" || x < 0 || d(x))
                  throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + x + ".");
                return this._maxListeners = x, this;
              };
              function g(T) {
                return T._maxListeners === void 0 ? h.defaultMaxListeners : T._maxListeners;
              }
              h.prototype.getMaxListeners = function() {
                return g(this);
              }, h.prototype.emit = function(x) {
                for (var L = [], I = 1; I < arguments.length; I++)
                  L.push(arguments[I]);
                var R = x === "error", B = this._events;
                if (B !== void 0)
                  R = R && B.error === void 0;
                else if (!R)
                  return !1;
                if (R) {
                  var D;
                  if (L.length > 0 && (D = L[0]), D instanceof Error)
                    throw D;
                  var k = new Error("Unhandled error." + (D ? " (" + D.message + ")" : ""));
                  throw k.context = D, k;
                }
                var F = B[x];
                if (F === void 0)
                  return !1;
                if (typeof F == "function")
                  l(F, this, L);
                else
                  for (var U = F.length, G = y(F, U), I = 0; I < U; ++I)
                    l(G[I], this, L);
                return !0;
              };
              function m(T, x, L, I) {
                var R, B, D;
                if (f(L), B = T._events, B === void 0 ? (B = T._events = /* @__PURE__ */ Object.create(null), T._eventsCount = 0) : (B.newListener !== void 0 && (T.emit("newListener", x, L.listener ? L.listener : L), B = T._events), D = B[x]), D === void 0)
                  D = B[x] = L, ++T._eventsCount;
                else if (typeof D == "function" ? D = B[x] = I ? [L, D] : [D, L] : I ? D.unshift(L) : D.push(L), R = g(T), R > 0 && D.length > R && !D.warned) {
                  D.warned = !0;
                  var k = new Error("Possible EventEmitter memory leak detected. " + D.length + " " + String(x) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                  k.name = "MaxListenersExceededWarning", k.emitter = T, k.type = x, k.count = D.length, c(k);
                }
                return T;
              }
              h.prototype.addListener = function(x, L) {
                return m(this, x, L, !1);
              }, h.prototype.on = h.prototype.addListener, h.prototype.prependListener = function(x, L) {
                return m(this, x, L, !0);
              };
              function v() {
                if (!this.fired)
                  return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
              }
              function E(T, x, L) {
                var I = { fired: !1, wrapFn: void 0, target: T, type: x, listener: L }, R = v.bind(I);
                return R.listener = L, I.wrapFn = R, R;
              }
              h.prototype.once = function(x, L) {
                return f(L), this.on(x, E(this, x, L)), this;
              }, h.prototype.prependOnceListener = function(x, L) {
                return f(L), this.prependListener(x, E(this, x, L)), this;
              }, h.prototype.removeListener = function(x, L) {
                var I, R, B, D, k;
                if (f(L), R = this._events, R === void 0)
                  return this;
                if (I = R[x], I === void 0)
                  return this;
                if (I === L || I.listener === L)
                  --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete R[x], R.removeListener && this.emit("removeListener", x, I.listener || L));
                else if (typeof I != "function") {
                  for (B = -1, D = I.length - 1; D >= 0; D--)
                    if (I[D] === L || I[D].listener === L) {
                      k = I[D].listener, B = D;
                      break;
                    }
                  if (B < 0)
                    return this;
                  B === 0 ? I.shift() : S(I, B), I.length === 1 && (R[x] = I[0]), R.removeListener !== void 0 && this.emit("removeListener", x, k || L);
                }
                return this;
              }, h.prototype.off = h.prototype.removeListener, h.prototype.removeAllListeners = function(x) {
                var L, I, R;
                if (I = this._events, I === void 0)
                  return this;
                if (I.removeListener === void 0)
                  return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : I[x] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete I[x]), this;
                if (arguments.length === 0) {
                  var B = Object.keys(I), D;
                  for (R = 0; R < B.length; ++R)
                    D = B[R], D !== "removeListener" && this.removeAllListeners(D);
                  return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
                }
                if (L = I[x], typeof L == "function")
                  this.removeListener(x, L);
                else if (L !== void 0)
                  for (R = L.length - 1; R >= 0; R--)
                    this.removeListener(x, L[R]);
                return this;
              };
              function A(T, x, L) {
                var I = T._events;
                if (I === void 0)
                  return [];
                var R = I[x];
                return R === void 0 ? [] : typeof R == "function" ? L ? [R.listener || R] : [R] : L ? b(R) : y(R, R.length);
              }
              h.prototype.listeners = function(x) {
                return A(this, x, !0);
              }, h.prototype.rawListeners = function(x) {
                return A(this, x, !1);
              }, h.listenerCount = function(T, x) {
                return typeof T.listenerCount == "function" ? T.listenerCount(x) : _.call(T, x);
              }, h.prototype.listenerCount = _;
              function _(T) {
                var x = this._events;
                if (x !== void 0) {
                  var L = x[T];
                  if (typeof L == "function")
                    return 1;
                  if (L !== void 0)
                    return L.length;
                }
                return 0;
              }
              h.prototype.eventNames = function() {
                return this._eventsCount > 0 ? u(this._events) : [];
              };
              function y(T, x) {
                for (var L = new Array(x), I = 0; I < x; ++I)
                  L[I] = T[I];
                return L;
              }
              function S(T, x) {
                for (; x + 1 < T.length; x++)
                  T[x] = T[x + 1];
                T.pop();
              }
              function b(T) {
                for (var x = new Array(T.length), L = 0; L < x.length; ++L)
                  x[L] = T[L].listener || T[L];
                return x;
              }
              function w(T, x) {
                return new Promise(function(L, I) {
                  function R(D) {
                    T.removeListener(x, B), I(D);
                  }
                  function B() {
                    typeof T.removeListener == "function" && T.removeListener("error", R), L([].slice.call(arguments));
                  }
                  C(T, x, B, { once: !0 }), x !== "error" && P(T, R, { once: !0 });
                });
              }
              function P(T, x, L) {
                typeof T.on == "function" && C(T, "error", x, L);
              }
              function C(T, x, L, I) {
                if (typeof T.on == "function")
                  I.once ? T.once(x, L) : T.on(x, L);
                else if (typeof T.addEventListener == "function")
                  T.addEventListener(x, function R(B) {
                    I.once && T.removeEventListener(x, R), L(B);
                  });
                else
                  throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof T);
              }
            }
          ),
          /***/
          "./node_modules/webworkify-webpack/index.js": (
            /*!**************************************************!*\
              !*** ./node_modules/webworkify-webpack/index.js ***!
              \**************************************************/
            /***/
            function(o, a, l) {
              function u(v) {
                var E = {};
                function A(y) {
                  if (E[y])
                    return E[y].exports;
                  var S = E[y] = {
                    /******/
                    i: y,
                    /******/
                    l: !1,
                    /******/
                    exports: {}
                    /******/
                  };
                  return v[y].call(S.exports, S, S.exports, A), S.l = !0, S.exports;
                }
                A.m = v, A.c = E, A.i = function(y) {
                  return y;
                }, A.d = function(y, S, b) {
                  A.o(y, S) || Object.defineProperty(y, S, {
                    /******/
                    configurable: !1,
                    /******/
                    enumerable: !0,
                    /******/
                    get: b
                    /******/
                  });
                }, A.r = function(y) {
                  Object.defineProperty(y, "__esModule", { value: !0 });
                }, A.n = function(y) {
                  var S = y && y.__esModule ? (
                    /******/
                    function() {
                      return y.default;
                    }
                  ) : (
                    /******/
                    function() {
                      return y;
                    }
                  );
                  return A.d(S, "a", S), S;
                }, A.o = function(y, S) {
                  return Object.prototype.hasOwnProperty.call(y, S);
                }, A.p = "/", A.oe = function(y) {
                  throw console.error(y), y;
                };
                var _ = A(A.s = ENTRY_MODULE);
                return _.default || _;
              }
              var c = "[\\.|\\-|\\+|\\w|/|@]+", d = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" + c + ").*?\\)";
              function h(v) {
                return (v + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
              }
              function p(v) {
                return !isNaN(1 * v);
              }
              function f(v, E, A) {
                var _ = {};
                _[A] = [];
                var y = E.toString(), S = y.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);
                if (!S)
                  return _;
                for (var b = S[1], w = new RegExp("(\\\\n|\\W)" + h(b) + d, "g"), P; P = w.exec(y); )
                  P[3] !== "dll-reference" && _[A].push(P[3]);
                for (w = new RegExp("\\(" + h(b) + '\\("(dll-reference\\s(' + c + '))"\\)\\)' + d, "g"); P = w.exec(y); )
                  v[P[2]] || (_[A].push(P[1]), v[P[2]] = l(P[1]).m), _[P[2]] = _[P[2]] || [], _[P[2]].push(P[4]);
                for (var C = Object.keys(_), T = 0; T < C.length; T++)
                  for (var x = 0; x < _[C[T]].length; x++)
                    p(_[C[T]][x]) && (_[C[T]][x] = 1 * _[C[T]][x]);
                return _;
              }
              function g(v) {
                var E = Object.keys(v);
                return E.reduce(function(A, _) {
                  return A || v[_].length > 0;
                }, !1);
              }
              function m(v, E) {
                for (var A = {
                  main: [E]
                }, _ = {
                  main: []
                }, y = {
                  main: {}
                }; g(A); )
                  for (var S = Object.keys(A), b = 0; b < S.length; b++) {
                    var w = S[b], P = A[w], C = P.pop();
                    if (y[w] = y[w] || {}, !(y[w][C] || !v[w][C])) {
                      y[w][C] = !0, _[w] = _[w] || [], _[w].push(C);
                      for (var T = f(v, v[w][C], w), x = Object.keys(T), L = 0; L < x.length; L++)
                        A[x[L]] = A[x[L]] || [], A[x[L]] = A[x[L]].concat(T[x[L]]);
                    }
                  }
                return _;
              }
              o.exports = function(v, E) {
                E = E || {};
                var A = {
                  main: l.m
                }, _ = E.all ? { main: Object.keys(A.main) } : m(A, v), y = "";
                Object.keys(_).filter(function(C) {
                  return C !== "main";
                }).forEach(function(C) {
                  for (var T = 0; _[C][T]; )
                    T++;
                  _[C].push(T), A[C][T] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", y = y + "var " + C + " = (" + u.toString().replace("ENTRY_MODULE", JSON.stringify(T)) + ")({" + _[C].map(function(x) {
                    return "" + JSON.stringify(x) + ": " + A[C][x].toString();
                  }).join(",") + `});
`;
                }), y = y + "new ((" + u.toString().replace("ENTRY_MODULE", JSON.stringify(v)) + ")({" + _.main.map(function(C) {
                  return "" + JSON.stringify(C) + ": " + A.main[C].toString();
                }).join(",") + "}))(self);";
                var S = new window.Blob([y], { type: "text/javascript" });
                if (E.bare)
                  return S;
                var b = window.URL || window.webkitURL || window.mozURL || window.msURL, w = b.createObjectURL(S), P = new window.Worker(w);
                return P.objectURL = w, P;
              };
            }
          ),
          /***/
          "./src/config.js": (
            /*!***********************!*\
              !*** ./src/config.js ***!
              \***********************/
            /***/
            function(o, a, l) {
              l.r(a), l.d(a, {
                /* harmony export */
                defaultConfig: function() {
                  return (
                    /* binding */
                    u
                  );
                },
                /* harmony export */
                createDefaultConfig: function() {
                  return (
                    /* binding */
                    c
                  );
                }
                /* harmony export */
              });
              var u = {
                enableWorker: !1,
                enableStashBuffer: !0,
                stashInitialSize: void 0,
                isLive: !1,
                lazyLoad: !0,
                lazyLoadMaxDuration: 3 * 60,
                lazyLoadRecoverDuration: 30,
                deferLoadAfterSourceOpen: !0,
                // autoCleanupSourceBuffer: default as false, leave unspecified
                autoCleanupMaxBackwardDuration: 3 * 60,
                autoCleanupMinBackwardDuration: 2 * 60,
                statisticsInfoReportInterval: 600,
                fixAudioTimestampGap: !0,
                accurateSeek: !1,
                seekType: "range",
                seekParamStart: "bstart",
                seekParamEnd: "bend",
                rangeLoadZeroStart: !1,
                customSeekHandler: void 0,
                reuseRedirectedURL: !1,
                // referrerPolicy: leave as unspecified
                headers: void 0,
                customLoader: void 0
              };
              function c() {
                return Object.assign({}, u);
              }
            }
          ),
          /***/
          "./src/core/features.js": (
            /*!******************************!*\
              !*** ./src/core/features.js ***!
              \******************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../io/io-controller.js */
                "./src/io/io-controller.js"
              ), c = l(
                /*! ../config.js */
                "./src/config.js"
              ), d = (
                /** @class */
                function() {
                  function h() {
                  }
                  return h.supportMSEH264Playback = function() {
                    return window.MediaSource && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                  }, h.supportNetworkStreamIO = function() {
                    var p = new u.default({}, (0, c.createDefaultConfig)()), f = p.loaderType;
                    return p.destroy(), f == "fetch-stream-loader" || f == "xhr-moz-chunked-loader";
                  }, h.getNetworkLoaderTypeName = function() {
                    var p = new u.default({}, (0, c.createDefaultConfig)()), f = p.loaderType;
                    return p.destroy(), f;
                  }, h.supportNativeMediaPlayback = function(p) {
                    h.videoElement == null && (h.videoElement = window.document.createElement("video"));
                    var f = h.videoElement.canPlayType(p);
                    return f === "probably" || f == "maybe";
                  }, h.getFeatureList = function() {
                    var p = {
                      mseFlvPlayback: !1,
                      mseLiveFlvPlayback: !1,
                      networkStreamIO: !1,
                      networkLoaderName: "",
                      nativeMP4H264Playback: !1,
                      nativeWebmVP8Playback: !1,
                      nativeWebmVP9Playback: !1
                    };
                    return p.mseFlvPlayback = h.supportMSEH264Playback(), p.networkStreamIO = h.supportNetworkStreamIO(), p.networkLoaderName = h.getNetworkLoaderTypeName(), p.mseLiveFlvPlayback = p.mseFlvPlayback && p.networkStreamIO, p.nativeMP4H264Playback = h.supportNativeMediaPlayback('video/mp4; codecs="avc1.42001E, mp4a.40.2"'), p.nativeWebmVP8Playback = h.supportNativeMediaPlayback('video/webm; codecs="vp8.0, vorbis"'), p.nativeWebmVP9Playback = h.supportNativeMediaPlayback('video/webm; codecs="vp9"'), p;
                  }, h;
                }()
              );
              a.default = d;
            }
          ),
          /***/
          "./src/core/media-info.js": (
            /*!********************************!*\
              !*** ./src/core/media-info.js ***!
              \********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = (
                /** @class */
                function() {
                  function c() {
                    this.mimeType = null, this.duration = null, this.hasAudio = null, this.hasVideo = null, this.audioCodec = null, this.videoCodec = null, this.audioDataRate = null, this.videoDataRate = null, this.audioSampleRate = null, this.audioChannelCount = null, this.width = null, this.height = null, this.fps = null, this.profile = null, this.level = null, this.refFrames = null, this.chromaFormat = null, this.sarNum = null, this.sarDen = null, this.metadata = null, this.segments = null, this.segmentCount = null, this.hasKeyframesIndex = null, this.keyframesIndex = null;
                  }
                  return c.prototype.isComplete = function() {
                    var d = this.hasAudio === !1 || this.hasAudio === !0 && this.audioCodec != null && this.audioSampleRate != null && this.audioChannelCount != null, h = this.hasVideo === !1 || this.hasVideo === !0 && this.videoCodec != null && this.width != null && this.height != null && this.fps != null && this.profile != null && this.level != null && this.refFrames != null && this.chromaFormat != null && this.sarNum != null && this.sarDen != null;
                    return this.mimeType != null && this.duration != null && this.metadata != null && this.hasKeyframesIndex != null && d && h;
                  }, c.prototype.isSeekable = function() {
                    return this.hasKeyframesIndex === !0;
                  }, c.prototype.getNearestKeyframe = function(d) {
                    if (this.keyframesIndex == null)
                      return null;
                    var h = this.keyframesIndex, p = this._search(h.times, d);
                    return {
                      index: p,
                      milliseconds: h.times[p],
                      fileposition: h.filepositions[p]
                    };
                  }, c.prototype._search = function(d, h) {
                    var p = 0, f = d.length - 1, g = 0, m = 0, v = f;
                    for (h < d[0] && (p = 0, m = v + 1); m <= v; )
                      if (g = m + Math.floor((v - m) / 2), g === f || h >= d[g] && h < d[g + 1]) {
                        p = g;
                        break;
                      } else
                        d[g] < h ? m = g + 1 : v = g - 1;
                    return p;
                  }, c;
                }()
              );
              a.default = u;
            }
          ),
          /***/
          "./src/core/media-segment-info.js": (
            /*!****************************************!*\
              !*** ./src/core/media-segment-info.js ***!
              \****************************************/
            /***/
            function(o, a, l) {
              l.r(a), l.d(a, {
                /* harmony export */
                SampleInfo: function() {
                  return (
                    /* binding */
                    u
                  );
                },
                /* harmony export */
                MediaSegmentInfo: function() {
                  return (
                    /* binding */
                    c
                  );
                },
                /* harmony export */
                IDRSampleList: function() {
                  return (
                    /* binding */
                    d
                  );
                },
                /* harmony export */
                MediaSegmentInfoList: function() {
                  return (
                    /* binding */
                    h
                  );
                }
                /* harmony export */
              });
              var u = (
                /** @class */
                function() {
                  function p(f, g, m, v, E) {
                    this.dts = f, this.pts = g, this.duration = m, this.originalDts = v, this.isSyncPoint = E, this.fileposition = null;
                  }
                  return p;
                }()
              ), c = (
                /** @class */
                function() {
                  function p() {
                    this.beginDts = 0, this.endDts = 0, this.beginPts = 0, this.endPts = 0, this.originalBeginDts = 0, this.originalEndDts = 0, this.syncPoints = [], this.firstSample = null, this.lastSample = null;
                  }
                  return p.prototype.appendSyncPoint = function(f) {
                    f.isSyncPoint = !0, this.syncPoints.push(f);
                  }, p;
                }()
              ), d = (
                /** @class */
                function() {
                  function p() {
                    this._list = [];
                  }
                  return p.prototype.clear = function() {
                    this._list = [];
                  }, p.prototype.appendArray = function(f) {
                    var g = this._list;
                    f.length !== 0 && (g.length > 0 && f[0].originalDts < g[g.length - 1].originalDts && this.clear(), Array.prototype.push.apply(g, f));
                  }, p.prototype.getLastSyncPointBeforeDts = function(f) {
                    if (this._list.length == 0)
                      return null;
                    var g = this._list, m = 0, v = g.length - 1, E = 0, A = 0, _ = v;
                    for (f < g[0].dts && (m = 0, A = _ + 1); A <= _; )
                      if (E = A + Math.floor((_ - A) / 2), E === v || f >= g[E].dts && f < g[E + 1].dts) {
                        m = E;
                        break;
                      } else
                        g[E].dts < f ? A = E + 1 : _ = E - 1;
                    return this._list[m];
                  }, p;
                }()
              ), h = (
                /** @class */
                function() {
                  function p(f) {
                    this._type = f, this._list = [], this._lastAppendLocation = -1;
                  }
                  return Object.defineProperty(p.prototype, "type", {
                    get: function() {
                      return this._type;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "length", {
                    get: function() {
                      return this._list.length;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), p.prototype.isEmpty = function() {
                    return this._list.length === 0;
                  }, p.prototype.clear = function() {
                    this._list = [], this._lastAppendLocation = -1;
                  }, p.prototype._searchNearestSegmentBefore = function(f) {
                    var g = this._list;
                    if (g.length === 0)
                      return -2;
                    var m = g.length - 1, v = 0, E = 0, A = m, _ = 0;
                    if (f < g[0].originalBeginDts)
                      return _ = -1, _;
                    for (; E <= A; )
                      if (v = E + Math.floor((A - E) / 2), v === m || f > g[v].lastSample.originalDts && f < g[v + 1].originalBeginDts) {
                        _ = v;
                        break;
                      } else
                        g[v].originalBeginDts < f ? E = v + 1 : A = v - 1;
                    return _;
                  }, p.prototype._searchNearestSegmentAfter = function(f) {
                    return this._searchNearestSegmentBefore(f) + 1;
                  }, p.prototype.append = function(f) {
                    var g = this._list, m = f, v = this._lastAppendLocation, E = 0;
                    v !== -1 && v < g.length && m.originalBeginDts >= g[v].lastSample.originalDts && (v === g.length - 1 || v < g.length - 1 && m.originalBeginDts < g[v + 1].originalBeginDts) ? E = v + 1 : g.length > 0 && (E = this._searchNearestSegmentBefore(m.originalBeginDts) + 1), this._lastAppendLocation = E, this._list.splice(E, 0, m);
                  }, p.prototype.getLastSegmentBefore = function(f) {
                    var g = this._searchNearestSegmentBefore(f);
                    return g >= 0 ? this._list[g] : null;
                  }, p.prototype.getLastSampleBefore = function(f) {
                    var g = this.getLastSegmentBefore(f);
                    return g != null ? g.lastSample : null;
                  }, p.prototype.getLastSyncPointBefore = function(f) {
                    for (var g = this._searchNearestSegmentBefore(f), m = this._list[g].syncPoints; m.length === 0 && g > 0; )
                      g--, m = this._list[g].syncPoints;
                    return m.length > 0 ? m[m.length - 1] : null;
                  }, p;
                }()
              );
            }
          ),
          /***/
          "./src/core/mse-controller.js": (
            /*!************************************!*\
              !*** ./src/core/mse-controller.js ***!
              \************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! events */
                "./node_modules/events/events.js"
              ), c = /* @__PURE__ */ l.n(u), d = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), h = l(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              ), p = l(
                /*! ./mse-events.js */
                "./src/core/mse-events.js"
              ), f = l(
                /*! ./media-segment-info.js */
                "./src/core/media-segment-info.js"
              ), g = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), m = (
                /** @class */
                function() {
                  function v(E) {
                    this.TAG = "MSEController", this._config = E, this._emitter = new (c())(), this._config.isLive && this._config.autoCleanupSourceBuffer == null && (this._config.autoCleanupSourceBuffer = !0), this.e = {
                      onSourceOpen: this._onSourceOpen.bind(this),
                      onSourceEnded: this._onSourceEnded.bind(this),
                      onSourceClose: this._onSourceClose.bind(this),
                      onSourceBufferError: this._onSourceBufferError.bind(this),
                      onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)
                    }, this._mediaSource = null, this._mediaSourceObjectURL = null, this._mediaElement = null, this._isBufferFull = !1, this._hasPendingEos = !1, this._requireSetMediaDuration = !1, this._pendingMediaDuration = 0, this._pendingSourceBufferInit = [], this._mimeTypes = {
                      video: null,
                      audio: null
                    }, this._sourceBuffers = {
                      video: null,
                      audio: null
                    }, this._lastInitSegments = {
                      video: null,
                      audio: null
                    }, this._pendingSegments = {
                      video: [],
                      audio: []
                    }, this._pendingRemoveRanges = {
                      video: [],
                      audio: []
                    }, this._idrList = new f.IDRSampleList();
                  }
                  return v.prototype.destroy = function() {
                    (this._mediaElement || this._mediaSource) && this.detachMediaElement(), this.e = null, this._emitter.removeAllListeners(), this._emitter = null;
                  }, v.prototype.on = function(E, A) {
                    this._emitter.addListener(E, A);
                  }, v.prototype.off = function(E, A) {
                    this._emitter.removeListener(E, A);
                  }, v.prototype.attachMediaElement = function(E) {
                    if (this._mediaSource)
                      throw new g.IllegalStateException("MediaSource has been attached to an HTMLMediaElement!");
                    var A = this._mediaSource = new window.MediaSource();
                    A.addEventListener("sourceopen", this.e.onSourceOpen), A.addEventListener("sourceended", this.e.onSourceEnded), A.addEventListener("sourceclose", this.e.onSourceClose), this._mediaElement = E, this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource), E.src = this._mediaSourceObjectURL;
                  }, v.prototype.detachMediaElement = function() {
                    if (this._mediaSource) {
                      var E = this._mediaSource;
                      for (var A in this._sourceBuffers) {
                        var _ = this._pendingSegments[A];
                        _.splice(0, _.length), this._pendingSegments[A] = null, this._pendingRemoveRanges[A] = null, this._lastInitSegments[A] = null;
                        var y = this._sourceBuffers[A];
                        if (y) {
                          if (E.readyState !== "closed") {
                            try {
                              E.removeSourceBuffer(y);
                            } catch (S) {
                              d.default.e(this.TAG, S.message);
                            }
                            y.removeEventListener("error", this.e.onSourceBufferError), y.removeEventListener("updateend", this.e.onSourceBufferUpdateEnd);
                          }
                          this._mimeTypes[A] = null, this._sourceBuffers[A] = null;
                        }
                      }
                      if (E.readyState === "open")
                        try {
                          E.endOfStream();
                        } catch (S) {
                          d.default.e(this.TAG, S.message);
                        }
                      E.removeEventListener("sourceopen", this.e.onSourceOpen), E.removeEventListener("sourceended", this.e.onSourceEnded), E.removeEventListener("sourceclose", this.e.onSourceClose), this._pendingSourceBufferInit = [], this._isBufferFull = !1, this._idrList.clear(), this._mediaSource = null;
                    }
                    this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src"), this._mediaElement = null), this._mediaSourceObjectURL && (window.URL.revokeObjectURL(this._mediaSourceObjectURL), this._mediaSourceObjectURL = null);
                  }, v.prototype.appendInitSegment = function(E, A) {
                    if (!this._mediaSource || this._mediaSource.readyState !== "open") {
                      this._pendingSourceBufferInit.push(E), this._pendingSegments[E.type].push(E);
                      return;
                    }
                    var _ = E, y = "" + _.container;
                    _.codec && _.codec.length > 0 && (y += ";codecs=" + _.codec);
                    var S = !1;
                    if (d.default.v(this.TAG, "Received Initialization Segment, mimeType: " + y), this._lastInitSegments[_.type] = _, y !== this._mimeTypes[_.type]) {
                      if (this._mimeTypes[_.type])
                        d.default.v(this.TAG, "Notice: " + _.type + " mimeType changed, origin: " + this._mimeTypes[_.type] + ", target: " + y);
                      else {
                        S = !0;
                        try {
                          var b = this._sourceBuffers[_.type] = this._mediaSource.addSourceBuffer(y);
                          b.addEventListener("error", this.e.onSourceBufferError), b.addEventListener("updateend", this.e.onSourceBufferUpdateEnd);
                        } catch (w) {
                          d.default.e(this.TAG, w.message), this._emitter.emit(p.default.ERROR, { code: w.code, msg: w.message });
                          return;
                        }
                      }
                      this._mimeTypes[_.type] = y;
                    }
                    A || this._pendingSegments[_.type].push(_), S || this._sourceBuffers[_.type] && !this._sourceBuffers[_.type].updating && this._doAppendSegments(), h.default.safari && _.container === "audio/mpeg" && _.mediaDuration > 0 && (this._requireSetMediaDuration = !0, this._pendingMediaDuration = _.mediaDuration / 1e3, this._updateMediaSourceDuration());
                  }, v.prototype.appendMediaSegment = function(E) {
                    var A = E;
                    this._pendingSegments[A.type].push(A), this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer() && this._doCleanupSourceBuffer();
                    var _ = this._sourceBuffers[A.type];
                    _ && !_.updating && !this._hasPendingRemoveRanges() && this._doAppendSegments();
                  }, v.prototype.seek = function(E) {
                    for (var A in this._sourceBuffers)
                      if (this._sourceBuffers[A]) {
                        var _ = this._sourceBuffers[A];
                        if (this._mediaSource.readyState === "open")
                          try {
                            _.abort();
                          } catch (C) {
                            d.default.e(this.TAG, C.message);
                          }
                        this._idrList.clear();
                        var y = this._pendingSegments[A];
                        if (y.splice(0, y.length), this._mediaSource.readyState !== "closed") {
                          for (var S = 0; S < _.buffered.length; S++) {
                            var b = _.buffered.start(S), w = _.buffered.end(S);
                            this._pendingRemoveRanges[A].push({ start: b, end: w });
                          }
                          if (_.updating || this._doRemoveRanges(), h.default.safari) {
                            var P = this._lastInitSegments[A];
                            P && (this._pendingSegments[A].push(P), _.updating || this._doAppendSegments());
                          }
                        }
                      }
                  }, v.prototype.endOfStream = function() {
                    var E = this._mediaSource, A = this._sourceBuffers;
                    if (!E || E.readyState !== "open") {
                      E && E.readyState === "closed" && this._hasPendingSegments() && (this._hasPendingEos = !0);
                      return;
                    }
                    A.video && A.video.updating || A.audio && A.audio.updating ? this._hasPendingEos = !0 : (this._hasPendingEos = !1, E.endOfStream());
                  }, v.prototype.getNearestKeyframe = function(E) {
                    return this._idrList.getLastSyncPointBeforeDts(E);
                  }, v.prototype._needCleanupSourceBuffer = function() {
                    if (!this._config.autoCleanupSourceBuffer)
                      return !1;
                    var E = this._mediaElement.currentTime;
                    for (var A in this._sourceBuffers) {
                      var _ = this._sourceBuffers[A];
                      if (_) {
                        var y = _.buffered;
                        if (y.length >= 1 && E - y.start(0) >= this._config.autoCleanupMaxBackwardDuration)
                          return !0;
                      }
                    }
                    return !1;
                  }, v.prototype._doCleanupSourceBuffer = function() {
                    var E = this._mediaElement.currentTime;
                    for (var A in this._sourceBuffers) {
                      var _ = this._sourceBuffers[A];
                      if (_) {
                        for (var y = _.buffered, S = !1, b = 0; b < y.length; b++) {
                          var w = y.start(b), P = y.end(b);
                          if (w <= E && E < P + 3) {
                            if (E - w >= this._config.autoCleanupMaxBackwardDuration) {
                              S = !0;
                              var C = E - this._config.autoCleanupMinBackwardDuration;
                              this._pendingRemoveRanges[A].push({ start: w, end: C });
                            }
                          } else
                            P < E && (S = !0, this._pendingRemoveRanges[A].push({ start: w, end: P }));
                        }
                        S && !_.updating && this._doRemoveRanges();
                      }
                    }
                  }, v.prototype._updateMediaSourceDuration = function() {
                    var E = this._sourceBuffers;
                    if (!(this._mediaElement.readyState === 0 || this._mediaSource.readyState !== "open") && !(E.video && E.video.updating || E.audio && E.audio.updating)) {
                      var A = this._mediaSource.duration, _ = this._pendingMediaDuration;
                      _ > 0 && (isNaN(A) || _ > A) && (d.default.v(this.TAG, "Update MediaSource duration from " + A + " to " + _), this._mediaSource.duration = _), this._requireSetMediaDuration = !1, this._pendingMediaDuration = 0;
                    }
                  }, v.prototype._doRemoveRanges = function() {
                    for (var E in this._pendingRemoveRanges)
                      if (!(!this._sourceBuffers[E] || this._sourceBuffers[E].updating))
                        for (var A = this._sourceBuffers[E], _ = this._pendingRemoveRanges[E]; _.length && !A.updating; ) {
                          var y = _.shift();
                          A.remove(y.start, y.end);
                        }
                  }, v.prototype._doAppendSegments = function() {
                    var E = this._pendingSegments;
                    for (var A in E)
                      if (!(!this._sourceBuffers[A] || this._sourceBuffers[A].updating) && E[A].length > 0) {
                        var _ = E[A].shift();
                        if (_.timestampOffset) {
                          var y = this._sourceBuffers[A].timestampOffset, S = _.timestampOffset / 1e3, b = Math.abs(y - S);
                          b > 0.1 && (d.default.v(this.TAG, "Update MPEG audio timestampOffset from " + y + " to " + S), this._sourceBuffers[A].timestampOffset = S), delete _.timestampOffset;
                        }
                        if (!_.data || _.data.byteLength === 0)
                          continue;
                        try {
                          this._sourceBuffers[A].appendBuffer(_.data), this._isBufferFull = !1, A === "video" && _.hasOwnProperty("info") && this._idrList.appendArray(_.info.syncPoints);
                        } catch (w) {
                          this._pendingSegments[A].unshift(_), w.code === 22 ? (this._isBufferFull || this._emitter.emit(p.default.BUFFER_FULL), this._isBufferFull = !0) : (d.default.e(this.TAG, w.message), this._emitter.emit(p.default.ERROR, { code: w.code, msg: w.message }));
                        }
                      }
                  }, v.prototype._onSourceOpen = function() {
                    if (d.default.v(this.TAG, "MediaSource onSourceOpen"), this._mediaSource.removeEventListener("sourceopen", this.e.onSourceOpen), this._pendingSourceBufferInit.length > 0)
                      for (var E = this._pendingSourceBufferInit; E.length; ) {
                        var A = E.shift();
                        this.appendInitSegment(A, !0);
                      }
                    this._hasPendingSegments() && this._doAppendSegments(), this._emitter.emit(p.default.SOURCE_OPEN);
                  }, v.prototype._onSourceEnded = function() {
                    d.default.v(this.TAG, "MediaSource onSourceEnded");
                  }, v.prototype._onSourceClose = function() {
                    d.default.v(this.TAG, "MediaSource onSourceClose"), this._mediaSource && this.e != null && (this._mediaSource.removeEventListener("sourceopen", this.e.onSourceOpen), this._mediaSource.removeEventListener("sourceended", this.e.onSourceEnded), this._mediaSource.removeEventListener("sourceclose", this.e.onSourceClose));
                  }, v.prototype._hasPendingSegments = function() {
                    var E = this._pendingSegments;
                    return E.video.length > 0 || E.audio.length > 0;
                  }, v.prototype._hasPendingRemoveRanges = function() {
                    var E = this._pendingRemoveRanges;
                    return E.video.length > 0 || E.audio.length > 0;
                  }, v.prototype._onSourceBufferUpdateEnd = function() {
                    this._requireSetMediaDuration ? this._updateMediaSourceDuration() : this._hasPendingRemoveRanges() ? this._doRemoveRanges() : this._hasPendingSegments() ? this._doAppendSegments() : this._hasPendingEos && this.endOfStream(), this._emitter.emit(p.default.UPDATE_END);
                  }, v.prototype._onSourceBufferError = function(E) {
                    d.default.e(this.TAG, "SourceBuffer Error: " + E);
                  }, v;
                }()
              );
              a.default = m;
            }
          ),
          /***/
          "./src/core/mse-events.js": (
            /*!********************************!*\
              !*** ./src/core/mse-events.js ***!
              \********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = {
                ERROR: "error",
                SOURCE_OPEN: "source_open",
                UPDATE_END: "update_end",
                BUFFER_FULL: "buffer_full"
              };
              a.default = u;
            }
          ),
          /***/
          "./src/core/transmuxer.js": (
            /*!********************************!*\
              !*** ./src/core/transmuxer.js ***!
              \********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! events */
                "./node_modules/events/events.js"
              ), c = /* @__PURE__ */ l.n(u), d = l(
                /*! webworkify-webpack */
                "./node_modules/webworkify-webpack/index.js"
              ), h = /* @__PURE__ */ l.n(d), p = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), f = l(
                /*! ../utils/logging-control.js */
                "./src/utils/logging-control.js"
              ), g = l(
                /*! ./transmuxing-controller.js */
                "./src/core/transmuxing-controller.js"
              ), m = l(
                /*! ./transmuxing-events.js */
                "./src/core/transmuxing-events.js"
              ), v = l(
                /*! ./media-info.js */
                "./src/core/media-info.js"
              ), E = (
                /** @class */
                function() {
                  function A(_, y) {
                    if (this.TAG = "Transmuxer", this._emitter = new (c())(), y.enableWorker && typeof Worker < "u")
                      try {
                        this._worker = h()(
                          /*require.resolve*/
                          /*! ./transmuxing-worker */
                          "./src/core/transmuxing-worker.js"
                        ), this._workerDestroying = !1, this._worker.addEventListener("message", this._onWorkerMessage.bind(this)), this._worker.postMessage({ cmd: "init", param: [_, y] }), this.e = {
                          onLoggingConfigChanged: this._onLoggingConfigChanged.bind(this)
                        }, f.default.registerListener(this.e.onLoggingConfigChanged), this._worker.postMessage({ cmd: "logging_config", param: f.default.getConfig() });
                      } catch {
                        p.default.e(this.TAG, "Error while initialize transmuxing worker, fallback to inline transmuxing"), this._worker = null, this._controller = new g.default(_, y);
                      }
                    else
                      this._controller = new g.default(_, y);
                    if (this._controller) {
                      var S = this._controller;
                      S.on(m.default.IO_ERROR, this._onIOError.bind(this)), S.on(m.default.DEMUX_ERROR, this._onDemuxError.bind(this)), S.on(m.default.INIT_SEGMENT, this._onInitSegment.bind(this)), S.on(m.default.MEDIA_SEGMENT, this._onMediaSegment.bind(this)), S.on(m.default.LOADING_COMPLETE, this._onLoadingComplete.bind(this)), S.on(m.default.RECOVERED_EARLY_EOF, this._onRecoveredEarlyEof.bind(this)), S.on(m.default.MEDIA_INFO, this._onMediaInfo.bind(this)), S.on(m.default.METADATA_ARRIVED, this._onMetaDataArrived.bind(this)), S.on(m.default.SCRIPTDATA_ARRIVED, this._onScriptDataArrived.bind(this)), S.on(m.default.STATISTICS_INFO, this._onStatisticsInfo.bind(this)), S.on(m.default.RECOMMEND_SEEKPOINT, this._onRecommendSeekpoint.bind(this));
                    }
                  }
                  return A.prototype.destroy = function() {
                    this._worker ? this._workerDestroying || (this._workerDestroying = !0, this._worker.postMessage({ cmd: "destroy" }), f.default.removeListener(this.e.onLoggingConfigChanged), this.e = null) : (this._controller.destroy(), this._controller = null), this._emitter.removeAllListeners(), this._emitter = null;
                  }, A.prototype.on = function(_, y) {
                    this._emitter.addListener(_, y);
                  }, A.prototype.off = function(_, y) {
                    this._emitter.removeListener(_, y);
                  }, A.prototype.hasWorker = function() {
                    return this._worker != null;
                  }, A.prototype.open = function() {
                    this._worker ? this._worker.postMessage({ cmd: "start" }) : this._controller.start();
                  }, A.prototype.close = function() {
                    this._worker ? this._worker.postMessage({ cmd: "stop" }) : this._controller.stop();
                  }, A.prototype.seek = function(_) {
                    this._worker ? this._worker.postMessage({ cmd: "seek", param: _ }) : this._controller.seek(_);
                  }, A.prototype.pause = function() {
                    this._worker ? this._worker.postMessage({ cmd: "pause" }) : this._controller.pause();
                  }, A.prototype.resume = function() {
                    this._worker ? this._worker.postMessage({ cmd: "resume" }) : this._controller.resume();
                  }, A.prototype._onInitSegment = function(_, y) {
                    var S = this;
                    Promise.resolve().then(function() {
                      S._emitter.emit(m.default.INIT_SEGMENT, _, y);
                    });
                  }, A.prototype._onMediaSegment = function(_, y) {
                    var S = this;
                    Promise.resolve().then(function() {
                      S._emitter.emit(m.default.MEDIA_SEGMENT, _, y);
                    });
                  }, A.prototype._onLoadingComplete = function() {
                    var _ = this;
                    Promise.resolve().then(function() {
                      _._emitter.emit(m.default.LOADING_COMPLETE);
                    });
                  }, A.prototype._onRecoveredEarlyEof = function() {
                    var _ = this;
                    Promise.resolve().then(function() {
                      _._emitter.emit(m.default.RECOVERED_EARLY_EOF);
                    });
                  }, A.prototype._onMediaInfo = function(_) {
                    var y = this;
                    Promise.resolve().then(function() {
                      y._emitter.emit(m.default.MEDIA_INFO, _);
                    });
                  }, A.prototype._onMetaDataArrived = function(_) {
                    var y = this;
                    Promise.resolve().then(function() {
                      y._emitter.emit(m.default.METADATA_ARRIVED, _);
                    });
                  }, A.prototype._onScriptDataArrived = function(_) {
                    var y = this;
                    Promise.resolve().then(function() {
                      y._emitter.emit(m.default.SCRIPTDATA_ARRIVED, _);
                    });
                  }, A.prototype._onStatisticsInfo = function(_) {
                    var y = this;
                    Promise.resolve().then(function() {
                      y._emitter.emit(m.default.STATISTICS_INFO, _);
                    });
                  }, A.prototype._onIOError = function(_, y) {
                    var S = this;
                    Promise.resolve().then(function() {
                      S._emitter.emit(m.default.IO_ERROR, _, y);
                    });
                  }, A.prototype._onDemuxError = function(_, y) {
                    var S = this;
                    Promise.resolve().then(function() {
                      S._emitter.emit(m.default.DEMUX_ERROR, _, y);
                    });
                  }, A.prototype._onRecommendSeekpoint = function(_) {
                    var y = this;
                    Promise.resolve().then(function() {
                      y._emitter.emit(m.default.RECOMMEND_SEEKPOINT, _);
                    });
                  }, A.prototype._onLoggingConfigChanged = function(_) {
                    this._worker && this._worker.postMessage({ cmd: "logging_config", param: _ });
                  }, A.prototype._onWorkerMessage = function(_) {
                    var y = _.data, S = y.data;
                    if (y.msg === "destroyed" || this._workerDestroying) {
                      this._workerDestroying = !1, this._worker.terminate(), this._worker = null;
                      return;
                    }
                    switch (y.msg) {
                      case m.default.INIT_SEGMENT:
                      case m.default.MEDIA_SEGMENT:
                        this._emitter.emit(y.msg, S.type, S.data);
                        break;
                      case m.default.LOADING_COMPLETE:
                      case m.default.RECOVERED_EARLY_EOF:
                        this._emitter.emit(y.msg);
                        break;
                      case m.default.MEDIA_INFO:
                        Object.setPrototypeOf(S, v.default.prototype), this._emitter.emit(y.msg, S);
                        break;
                      case m.default.METADATA_ARRIVED:
                      case m.default.SCRIPTDATA_ARRIVED:
                      case m.default.STATISTICS_INFO:
                        this._emitter.emit(y.msg, S);
                        break;
                      case m.default.IO_ERROR:
                      case m.default.DEMUX_ERROR:
                        this._emitter.emit(y.msg, S.type, S.info);
                        break;
                      case m.default.RECOMMEND_SEEKPOINT:
                        this._emitter.emit(y.msg, S);
                        break;
                      case "logcat_callback":
                        p.default.emitter.emit("log", S.type, S.logcat);
                        break;
                    }
                  }, A;
                }()
              );
              a.default = E;
            }
          ),
          /***/
          "./src/core/transmuxing-controller.js": (
            /*!********************************************!*\
              !*** ./src/core/transmuxing-controller.js ***!
              \********************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! events */
                "./node_modules/events/events.js"
              ), c = /* @__PURE__ */ l.n(u), d = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), h = l(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              ), p = l(
                /*! ./media-info.js */
                "./src/core/media-info.js"
              ), f = l(
                /*! ../demux/flv-demuxer.js */
                "./src/demux/flv-demuxer.js"
              ), g = l(
                /*! ../remux/mp4-remuxer.js */
                "./src/remux/mp4-remuxer.js"
              ), m = l(
                /*! ../demux/demux-errors.js */
                "./src/demux/demux-errors.js"
              ), v = l(
                /*! ../io/io-controller.js */
                "./src/io/io-controller.js"
              ), E = l(
                /*! ./transmuxing-events.js */
                "./src/core/transmuxing-events.js"
              ), A = (
                /** @class */
                function() {
                  function _(y, S) {
                    this.TAG = "TransmuxingController", this._emitter = new (c())(), this._config = S, y.segments || (y.segments = [{
                      duration: y.duration,
                      filesize: y.filesize,
                      url: y.url
                    }]), typeof y.cors != "boolean" && (y.cors = !0), typeof y.withCredentials != "boolean" && (y.withCredentials = !1), this._mediaDataSource = y, this._currentSegmentIndex = 0;
                    var b = 0;
                    this._mediaDataSource.segments.forEach(function(w) {
                      w.timestampBase = b, b += w.duration, w.cors = y.cors, w.withCredentials = y.withCredentials, S.referrerPolicy && (w.referrerPolicy = S.referrerPolicy);
                    }), !isNaN(b) && this._mediaDataSource.duration !== b && (this._mediaDataSource.duration = b), this._mediaInfo = null, this._demuxer = null, this._remuxer = null, this._ioctl = null, this._pendingSeekTime = null, this._pendingResolveSeekPoint = null, this._statisticsReporter = null;
                  }
                  return _.prototype.destroy = function() {
                    this._mediaInfo = null, this._mediaDataSource = null, this._statisticsReporter && this._disableStatisticsReporter(), this._ioctl && (this._ioctl.destroy(), this._ioctl = null), this._demuxer && (this._demuxer.destroy(), this._demuxer = null), this._remuxer && (this._remuxer.destroy(), this._remuxer = null), this._emitter.removeAllListeners(), this._emitter = null;
                  }, _.prototype.on = function(y, S) {
                    this._emitter.addListener(y, S);
                  }, _.prototype.off = function(y, S) {
                    this._emitter.removeListener(y, S);
                  }, _.prototype.start = function() {
                    this._loadSegment(0), this._enableStatisticsReporter();
                  }, _.prototype._loadSegment = function(y, S) {
                    this._currentSegmentIndex = y;
                    var b = this._mediaDataSource.segments[y], w = this._ioctl = new v.default(b, this._config, y);
                    w.onError = this._onIOException.bind(this), w.onSeeked = this._onIOSeeked.bind(this), w.onComplete = this._onIOComplete.bind(this), w.onRedirect = this._onIORedirect.bind(this), w.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this), S ? this._demuxer.bindDataSource(this._ioctl) : w.onDataArrival = this._onInitChunkArrival.bind(this), w.open(S);
                  }, _.prototype.stop = function() {
                    this._internalAbort(), this._disableStatisticsReporter();
                  }, _.prototype._internalAbort = function() {
                    this._ioctl && (this._ioctl.destroy(), this._ioctl = null);
                  }, _.prototype.pause = function() {
                    this._ioctl && this._ioctl.isWorking() && (this._ioctl.pause(), this._disableStatisticsReporter());
                  }, _.prototype.resume = function() {
                    this._ioctl && this._ioctl.isPaused() && (this._ioctl.resume(), this._enableStatisticsReporter());
                  }, _.prototype.seek = function(y) {
                    if (!(this._mediaInfo == null || !this._mediaInfo.isSeekable())) {
                      var S = this._searchSegmentIndexContains(y);
                      if (S === this._currentSegmentIndex) {
                        var b = this._mediaInfo.segments[S];
                        if (b == null)
                          this._pendingSeekTime = y;
                        else {
                          var w = b.getNearestKeyframe(y);
                          this._remuxer.seek(w.milliseconds), this._ioctl.seek(w.fileposition), this._pendingResolveSeekPoint = w.milliseconds;
                        }
                      } else {
                        var P = this._mediaInfo.segments[S];
                        if (P == null)
                          this._pendingSeekTime = y, this._internalAbort(), this._remuxer.seek(), this._remuxer.insertDiscontinuity(), this._loadSegment(S);
                        else {
                          var w = P.getNearestKeyframe(y);
                          this._internalAbort(), this._remuxer.seek(y), this._remuxer.insertDiscontinuity(), this._demuxer.resetMediaInfo(), this._demuxer.timestampBase = this._mediaDataSource.segments[S].timestampBase, this._loadSegment(S, w.fileposition), this._pendingResolveSeekPoint = w.milliseconds, this._reportSegmentMediaInfo(S);
                        }
                      }
                      this._enableStatisticsReporter();
                    }
                  }, _.prototype._searchSegmentIndexContains = function(y) {
                    for (var S = this._mediaDataSource.segments, b = S.length - 1, w = 0; w < S.length; w++)
                      if (y < S[w].timestampBase) {
                        b = w - 1;
                        break;
                      }
                    return b;
                  }, _.prototype._onInitChunkArrival = function(y, S) {
                    var b = this, w = null, P = 0;
                    if (S > 0)
                      this._demuxer.bindDataSource(this._ioctl), this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase, P = this._demuxer.parseChunks(y, S);
                    else if ((w = f.default.probe(y)).match) {
                      this._demuxer = new f.default(w, this._config), this._remuxer || (this._remuxer = new g.default(this._config));
                      var C = this._mediaDataSource;
                      C.duration != null && !isNaN(C.duration) && (this._demuxer.overridedDuration = C.duration), typeof C.hasAudio == "boolean" && (this._demuxer.overridedHasAudio = C.hasAudio), typeof C.hasVideo == "boolean" && (this._demuxer.overridedHasVideo = C.hasVideo), this._demuxer.timestampBase = C.segments[this._currentSegmentIndex].timestampBase, this._demuxer.onError = this._onDemuxException.bind(this), this._demuxer.onMediaInfo = this._onMediaInfo.bind(this), this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this), this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this), this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl)), this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this), this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this), P = this._demuxer.parseChunks(y, S);
                    } else
                      w = null, d.default.e(this.TAG, "Non-FLV, Unsupported media type!"), Promise.resolve().then(function() {
                        b._internalAbort();
                      }), this._emitter.emit(E.default.DEMUX_ERROR, m.default.FORMAT_UNSUPPORTED, "Non-FLV, Unsupported media type"), P = 0;
                    return P;
                  }, _.prototype._onMediaInfo = function(y) {
                    var S = this;
                    this._mediaInfo == null && (this._mediaInfo = Object.assign({}, y), this._mediaInfo.keyframesIndex = null, this._mediaInfo.segments = [], this._mediaInfo.segmentCount = this._mediaDataSource.segments.length, Object.setPrototypeOf(this._mediaInfo, p.default.prototype));
                    var b = Object.assign({}, y);
                    Object.setPrototypeOf(b, p.default.prototype), this._mediaInfo.segments[this._currentSegmentIndex] = b, this._reportSegmentMediaInfo(this._currentSegmentIndex), this._pendingSeekTime != null && Promise.resolve().then(function() {
                      var w = S._pendingSeekTime;
                      S._pendingSeekTime = null, S.seek(w);
                    });
                  }, _.prototype._onMetaDataArrived = function(y) {
                    this._emitter.emit(E.default.METADATA_ARRIVED, y);
                  }, _.prototype._onScriptDataArrived = function(y) {
                    this._emitter.emit(E.default.SCRIPTDATA_ARRIVED, y);
                  }, _.prototype._onIOSeeked = function() {
                    this._remuxer.insertDiscontinuity();
                  }, _.prototype._onIOComplete = function(y) {
                    var S = y, b = S + 1;
                    b < this._mediaDataSource.segments.length ? (this._internalAbort(), this._remuxer.flushStashedSamples(), this._loadSegment(b)) : (this._remuxer.flushStashedSamples(), this._emitter.emit(E.default.LOADING_COMPLETE), this._disableStatisticsReporter());
                  }, _.prototype._onIORedirect = function(y) {
                    var S = this._ioctl.extraData;
                    this._mediaDataSource.segments[S].redirectedURL = y;
                  }, _.prototype._onIORecoveredEarlyEof = function() {
                    this._emitter.emit(E.default.RECOVERED_EARLY_EOF);
                  }, _.prototype._onIOException = function(y, S) {
                    d.default.e(this.TAG, "IOException: type = " + y + ", code = " + S.code + ", msg = " + S.msg), this._emitter.emit(E.default.IO_ERROR, y, S), this._disableStatisticsReporter();
                  }, _.prototype._onDemuxException = function(y, S) {
                    d.default.e(this.TAG, "DemuxException: type = " + y + ", info = " + S), this._emitter.emit(E.default.DEMUX_ERROR, y, S);
                  }, _.prototype._onRemuxerInitSegmentArrival = function(y, S) {
                    this._emitter.emit(E.default.INIT_SEGMENT, y, S);
                  }, _.prototype._onRemuxerMediaSegmentArrival = function(y, S) {
                    if (this._pendingSeekTime == null && (this._emitter.emit(E.default.MEDIA_SEGMENT, y, S), this._pendingResolveSeekPoint != null && y === "video")) {
                      var b = S.info.syncPoints, w = this._pendingResolveSeekPoint;
                      this._pendingResolveSeekPoint = null, h.default.safari && b.length > 0 && b[0].originalDts === w && (w = b[0].pts), this._emitter.emit(E.default.RECOMMEND_SEEKPOINT, w);
                    }
                  }, _.prototype._enableStatisticsReporter = function() {
                    this._statisticsReporter == null && (this._statisticsReporter = self.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval));
                  }, _.prototype._disableStatisticsReporter = function() {
                    this._statisticsReporter && (self.clearInterval(this._statisticsReporter), this._statisticsReporter = null);
                  }, _.prototype._reportSegmentMediaInfo = function(y) {
                    var S = this._mediaInfo.segments[y], b = Object.assign({}, S);
                    b.duration = this._mediaInfo.duration, b.segmentCount = this._mediaInfo.segmentCount, delete b.segments, delete b.keyframesIndex, this._emitter.emit(E.default.MEDIA_INFO, b);
                  }, _.prototype._reportStatisticsInfo = function() {
                    var y = {};
                    y.url = this._ioctl.currentURL, y.hasRedirect = this._ioctl.hasRedirect, y.hasRedirect && (y.redirectedURL = this._ioctl.currentRedirectedURL), y.speed = this._ioctl.currentSpeed, y.loaderType = this._ioctl.loaderType, y.currentSegmentIndex = this._currentSegmentIndex, y.totalSegmentCount = this._mediaDataSource.segments.length, this._emitter.emit(E.default.STATISTICS_INFO, y);
                  }, _;
                }()
              );
              a.default = A;
            }
          ),
          /***/
          "./src/core/transmuxing-events.js": (
            /*!****************************************!*\
              !*** ./src/core/transmuxing-events.js ***!
              \****************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = {
                IO_ERROR: "io_error",
                DEMUX_ERROR: "demux_error",
                INIT_SEGMENT: "init_segment",
                MEDIA_SEGMENT: "media_segment",
                LOADING_COMPLETE: "loading_complete",
                RECOVERED_EARLY_EOF: "recovered_early_eof",
                MEDIA_INFO: "media_info",
                METADATA_ARRIVED: "metadata_arrived",
                SCRIPTDATA_ARRIVED: "scriptdata_arrived",
                STATISTICS_INFO: "statistics_info",
                RECOMMEND_SEEKPOINT: "recommend_seekpoint"
              };
              a.default = u;
            }
          ),
          /***/
          "./src/core/transmuxing-worker.js": (
            /*!****************************************!*\
              !*** ./src/core/transmuxing-worker.js ***!
              \****************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/logging-control.js */
                "./src/utils/logging-control.js"
              ), c = l(
                /*! ../utils/polyfill.js */
                "./src/utils/polyfill.js"
              ), d = l(
                /*! ./transmuxing-controller.js */
                "./src/core/transmuxing-controller.js"
              ), h = l(
                /*! ./transmuxing-events.js */
                "./src/core/transmuxing-events.js"
              ), p = function(f) {
                var g = null, m = x.bind(this);
                c.default.install(), f.addEventListener("message", function(L) {
                  switch (L.data.cmd) {
                    case "init":
                      g = new d.default(L.data.param[0], L.data.param[1]), g.on(h.default.IO_ERROR, P.bind(this)), g.on(h.default.DEMUX_ERROR, C.bind(this)), g.on(h.default.INIT_SEGMENT, v.bind(this)), g.on(h.default.MEDIA_SEGMENT, E.bind(this)), g.on(h.default.LOADING_COMPLETE, A.bind(this)), g.on(h.default.RECOVERED_EARLY_EOF, _.bind(this)), g.on(h.default.MEDIA_INFO, y.bind(this)), g.on(h.default.METADATA_ARRIVED, S.bind(this)), g.on(h.default.SCRIPTDATA_ARRIVED, b.bind(this)), g.on(h.default.STATISTICS_INFO, w.bind(this)), g.on(h.default.RECOMMEND_SEEKPOINT, T.bind(this));
                      break;
                    case "destroy":
                      g && (g.destroy(), g = null), f.postMessage({ msg: "destroyed" });
                      break;
                    case "start":
                      g.start();
                      break;
                    case "stop":
                      g.stop();
                      break;
                    case "seek":
                      g.seek(L.data.param);
                      break;
                    case "pause":
                      g.pause();
                      break;
                    case "resume":
                      g.resume();
                      break;
                    case "logging_config": {
                      var I = L.data.param;
                      u.default.applyConfig(I), I.enableCallback === !0 ? u.default.addLogListener(m) : u.default.removeLogListener(m);
                      break;
                    }
                  }
                });
                function v(L, I) {
                  var R = {
                    msg: h.default.INIT_SEGMENT,
                    data: {
                      type: L,
                      data: I
                    }
                  };
                  f.postMessage(R, [I.data]);
                }
                function E(L, I) {
                  var R = {
                    msg: h.default.MEDIA_SEGMENT,
                    data: {
                      type: L,
                      data: I
                    }
                  };
                  f.postMessage(R, [I.data]);
                }
                function A() {
                  var L = {
                    msg: h.default.LOADING_COMPLETE
                  };
                  f.postMessage(L);
                }
                function _() {
                  var L = {
                    msg: h.default.RECOVERED_EARLY_EOF
                  };
                  f.postMessage(L);
                }
                function y(L) {
                  var I = {
                    msg: h.default.MEDIA_INFO,
                    data: L
                  };
                  f.postMessage(I);
                }
                function S(L) {
                  var I = {
                    msg: h.default.METADATA_ARRIVED,
                    data: L
                  };
                  f.postMessage(I);
                }
                function b(L) {
                  var I = {
                    msg: h.default.SCRIPTDATA_ARRIVED,
                    data: L
                  };
                  f.postMessage(I);
                }
                function w(L) {
                  var I = {
                    msg: h.default.STATISTICS_INFO,
                    data: L
                  };
                  f.postMessage(I);
                }
                function P(L, I) {
                  f.postMessage({
                    msg: h.default.IO_ERROR,
                    data: {
                      type: L,
                      info: I
                    }
                  });
                }
                function C(L, I) {
                  f.postMessage({
                    msg: h.default.DEMUX_ERROR,
                    data: {
                      type: L,
                      info: I
                    }
                  });
                }
                function T(L) {
                  f.postMessage({
                    msg: h.default.RECOMMEND_SEEKPOINT,
                    data: L
                  });
                }
                function x(L, I) {
                  f.postMessage({
                    msg: "logcat_callback",
                    data: {
                      type: L,
                      logcat: I
                    }
                  });
                }
              };
              a.default = p;
            }
          ),
          /***/
          "./src/demux/amf-parser.js": (
            /*!*********************************!*\
              !*** ./src/demux/amf-parser.js ***!
              \*********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), c = l(
                /*! ../utils/utf8-conv.js */
                "./src/utils/utf8-conv.js"
              ), d = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), h = function() {
                var f = new ArrayBuffer(2);
                return new DataView(f).setInt16(0, 256, !0), new Int16Array(f)[0] === 256;
              }(), p = (
                /** @class */
                function() {
                  function f() {
                  }
                  return f.parseScriptData = function(g, m, v) {
                    var E = {};
                    try {
                      var A = f.parseValue(g, m, v), _ = f.parseValue(g, m + A.size, v - A.size);
                      E[A.data] = _.data;
                    } catch (y) {
                      u.default.e("AMF", y.toString());
                    }
                    return E;
                  }, f.parseObject = function(g, m, v) {
                    if (v < 3)
                      throw new d.IllegalStateException("Data not enough when parse ScriptDataObject");
                    var E = f.parseString(g, m, v), A = f.parseValue(g, m + E.size, v - E.size), _ = A.objectEnd;
                    return {
                      data: {
                        name: E.data,
                        value: A.data
                      },
                      size: E.size + A.size,
                      objectEnd: _
                    };
                  }, f.parseVariable = function(g, m, v) {
                    return f.parseObject(g, m, v);
                  }, f.parseString = function(g, m, v) {
                    if (v < 2)
                      throw new d.IllegalStateException("Data not enough when parse String");
                    var E = new DataView(g, m, v), A = E.getUint16(0, !h), _;
                    return A > 0 ? _ = (0, c.default)(new Uint8Array(g, m + 2, A)) : _ = "", {
                      data: _,
                      size: 2 + A
                    };
                  }, f.parseLongString = function(g, m, v) {
                    if (v < 4)
                      throw new d.IllegalStateException("Data not enough when parse LongString");
                    var E = new DataView(g, m, v), A = E.getUint32(0, !h), _;
                    return A > 0 ? _ = (0, c.default)(new Uint8Array(g, m + 4, A)) : _ = "", {
                      data: _,
                      size: 4 + A
                    };
                  }, f.parseDate = function(g, m, v) {
                    if (v < 10)
                      throw new d.IllegalStateException("Data size invalid when parse Date");
                    var E = new DataView(g, m, v), A = E.getFloat64(0, !h), _ = E.getInt16(8, !h);
                    return A += _ * 60 * 1e3, {
                      data: new Date(A),
                      size: 8 + 2
                    };
                  }, f.parseValue = function(g, m, v) {
                    if (v < 1)
                      throw new d.IllegalStateException("Data not enough when parse Value");
                    var E = new DataView(g, m, v), A = 1, _ = E.getUint8(0), y, S = !1;
                    try {
                      switch (_) {
                        case 0:
                          y = E.getFloat64(1, !h), A += 8;
                          break;
                        case 1: {
                          var b = E.getUint8(1);
                          y = !!b, A += 1;
                          break;
                        }
                        case 2: {
                          var w = f.parseString(g, m + 1, v - 1);
                          y = w.data, A += w.size;
                          break;
                        }
                        case 3: {
                          y = {};
                          var P = 0;
                          for ((E.getUint32(v - 4, !h) & 16777215) === 9 && (P = 3); A < v - 4; ) {
                            var C = f.parseObject(g, m + A, v - A - P);
                            if (C.objectEnd)
                              break;
                            y[C.data.name] = C.data.value, A += C.size;
                          }
                          if (A <= v - 3) {
                            var T = E.getUint32(A - 1, !h) & 16777215;
                            T === 9 && (A += 3);
                          }
                          break;
                        }
                        case 8: {
                          y = {}, A += 4;
                          var P = 0;
                          for ((E.getUint32(v - 4, !h) & 16777215) === 9 && (P = 3); A < v - 8; ) {
                            var x = f.parseVariable(g, m + A, v - A - P);
                            if (x.objectEnd)
                              break;
                            y[x.data.name] = x.data.value, A += x.size;
                          }
                          if (A <= v - 3) {
                            var T = E.getUint32(A - 1, !h) & 16777215;
                            T === 9 && (A += 3);
                          }
                          break;
                        }
                        case 9:
                          y = void 0, A = 1, S = !0;
                          break;
                        case 10: {
                          y = [];
                          var L = E.getUint32(1, !h);
                          A += 4;
                          for (var I = 0; I < L; I++) {
                            var R = f.parseValue(g, m + A, v - A);
                            y.push(R.data), A += R.size;
                          }
                          break;
                        }
                        case 11: {
                          var B = f.parseDate(g, m + 1, v - 1);
                          y = B.data, A += B.size;
                          break;
                        }
                        case 12: {
                          var D = f.parseString(g, m + 1, v - 1);
                          y = D.data, A += D.size;
                          break;
                        }
                        default:
                          A = v, u.default.w("AMF", "Unsupported AMF value type " + _);
                      }
                    } catch (k) {
                      u.default.e("AMF", k.toString());
                    }
                    return {
                      data: y,
                      size: A,
                      objectEnd: S
                    };
                  }, f;
                }()
              );
              a.default = p;
            }
          ),
          /***/
          "./src/demux/demux-errors.js": (
            /*!***********************************!*\
              !*** ./src/demux/demux-errors.js ***!
              \***********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = {
                OK: "OK",
                FORMAT_ERROR: "FormatError",
                FORMAT_UNSUPPORTED: "FormatUnsupported",
                CODEC_UNSUPPORTED: "CodecUnsupported"
              };
              a.default = u;
            }
          ),
          /***/
          "./src/demux/exp-golomb.js": (
            /*!*********************************!*\
              !*** ./src/demux/exp-golomb.js ***!
              \*********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), c = (
                /** @class */
                function() {
                  function d(h) {
                    this.TAG = "ExpGolomb", this._buffer = h, this._buffer_index = 0, this._total_bytes = h.byteLength, this._total_bits = h.byteLength * 8, this._current_word = 0, this._current_word_bits_left = 0;
                  }
                  return d.prototype.destroy = function() {
                    this._buffer = null;
                  }, d.prototype._fillCurrentWord = function() {
                    var h = this._total_bytes - this._buffer_index;
                    if (h <= 0)
                      throw new u.IllegalStateException("ExpGolomb: _fillCurrentWord() but no bytes available");
                    var p = Math.min(4, h), f = new Uint8Array(4);
                    f.set(this._buffer.subarray(this._buffer_index, this._buffer_index + p)), this._current_word = new DataView(f.buffer).getUint32(0, !1), this._buffer_index += p, this._current_word_bits_left = p * 8;
                  }, d.prototype.readBits = function(h) {
                    if (h > 32)
                      throw new u.InvalidArgumentException("ExpGolomb: readBits() bits exceeded max 32bits!");
                    if (h <= this._current_word_bits_left) {
                      var p = this._current_word >>> 32 - h;
                      return this._current_word <<= h, this._current_word_bits_left -= h, p;
                    }
                    var f = this._current_word_bits_left ? this._current_word : 0;
                    f = f >>> 32 - this._current_word_bits_left;
                    var g = h - this._current_word_bits_left;
                    this._fillCurrentWord();
                    var m = Math.min(g, this._current_word_bits_left), v = this._current_word >>> 32 - m;
                    return this._current_word <<= m, this._current_word_bits_left -= m, f = f << m | v, f;
                  }, d.prototype.readBool = function() {
                    return this.readBits(1) === 1;
                  }, d.prototype.readByte = function() {
                    return this.readBits(8);
                  }, d.prototype._skipLeadingZero = function() {
                    var h;
                    for (h = 0; h < this._current_word_bits_left; h++)
                      if (this._current_word & 2147483648 >>> h)
                        return this._current_word <<= h, this._current_word_bits_left -= h, h;
                    return this._fillCurrentWord(), h + this._skipLeadingZero();
                  }, d.prototype.readUEG = function() {
                    var h = this._skipLeadingZero();
                    return this.readBits(h + 1) - 1;
                  }, d.prototype.readSEG = function() {
                    var h = this.readUEG();
                    return h & 1 ? h + 1 >>> 1 : -1 * (h >>> 1);
                  }, d;
                }()
              );
              a.default = c;
            }
          ),
          /***/
          "./src/demux/flv-demuxer.js": (
            /*!**********************************!*\
              !*** ./src/demux/flv-demuxer.js ***!
              \**********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), c = l(
                /*! ./amf-parser.js */
                "./src/demux/amf-parser.js"
              ), d = l(
                /*! ./sps-parser.js */
                "./src/demux/sps-parser.js"
              ), h = l(
                /*! ./demux-errors.js */
                "./src/demux/demux-errors.js"
              ), p = l(
                /*! ../core/media-info.js */
                "./src/core/media-info.js"
              ), f = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              function g(v, E) {
                return v[E] << 24 | v[E + 1] << 16 | v[E + 2] << 8 | v[E + 3];
              }
              var m = (
                /** @class */
                function() {
                  function v(E, A) {
                    this.TAG = "FLVDemuxer", this._config = A, this._onError = null, this._onMediaInfo = null, this._onMetaDataArrived = null, this._onScriptDataArrived = null, this._onTrackMetadata = null, this._onDataAvailable = null, this._dataOffset = E.dataOffset, this._firstParse = !0, this._dispatch = !1, this._hasAudio = E.hasAudioTrack, this._hasVideo = E.hasVideoTrack, this._hasAudioFlagOverrided = !1, this._hasVideoFlagOverrided = !1, this._audioInitialMetadataDispatched = !1, this._videoInitialMetadataDispatched = !1, this._mediaInfo = new p.default(), this._mediaInfo.hasAudio = this._hasAudio, this._mediaInfo.hasVideo = this._hasVideo, this._metadata = null, this._audioMetadata = null, this._videoMetadata = null, this._naluLengthSize = 4, this._timestampBase = 0, this._timescale = 1e3, this._duration = 0, this._durationOverrided = !1, this._referenceFrameRate = {
                      fixed: !0,
                      fps: 23.976,
                      fps_num: 23976,
                      fps_den: 1e3
                    }, this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48e3], this._mpegSamplingRates = [
                      96e3,
                      88200,
                      64e3,
                      48e3,
                      44100,
                      32e3,
                      24e3,
                      22050,
                      16e3,
                      12e3,
                      11025,
                      8e3,
                      7350
                    ], this._mpegAudioV10SampleRateTable = [44100, 48e3, 32e3, 0], this._mpegAudioV20SampleRateTable = [22050, 24e3, 16e3, 0], this._mpegAudioV25SampleRateTable = [11025, 12e3, 8e3, 0], this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1], this._mpegAudioL2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1], this._mpegAudioL3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1], this._videoTrack = { type: "video", id: 1, sequenceNumber: 0, samples: [], length: 0 }, this._audioTrack = { type: "audio", id: 2, sequenceNumber: 0, samples: [], length: 0 }, this._littleEndian = function() {
                      var _ = new ArrayBuffer(2);
                      return new DataView(_).setInt16(0, 256, !0), new Int16Array(_)[0] === 256;
                    }();
                  }
                  return v.prototype.destroy = function() {
                    this._mediaInfo = null, this._metadata = null, this._audioMetadata = null, this._videoMetadata = null, this._videoTrack = null, this._audioTrack = null, this._onError = null, this._onMediaInfo = null, this._onMetaDataArrived = null, this._onScriptDataArrived = null, this._onTrackMetadata = null, this._onDataAvailable = null;
                  }, v.probe = function(E) {
                    var A = new Uint8Array(E), _ = { match: !1 };
                    if (A[0] !== 70 || A[1] !== 76 || A[2] !== 86 || A[3] !== 1)
                      return _;
                    var y = (A[4] & 4) >>> 2 !== 0, S = (A[4] & 1) !== 0, b = g(A, 5);
                    return b < 9 ? _ : {
                      match: !0,
                      consumed: b,
                      dataOffset: b,
                      hasAudioTrack: y,
                      hasVideoTrack: S
                    };
                  }, v.prototype.bindDataSource = function(E) {
                    return E.onDataArrival = this.parseChunks.bind(this), this;
                  }, Object.defineProperty(v.prototype, "onTrackMetadata", {
                    // prototype: function(type: string, metadata: any): void
                    get: function() {
                      return this._onTrackMetadata;
                    },
                    set: function(E) {
                      this._onTrackMetadata = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "onMediaInfo", {
                    // prototype: function(mediaInfo: MediaInfo): void
                    get: function() {
                      return this._onMediaInfo;
                    },
                    set: function(E) {
                      this._onMediaInfo = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "onMetaDataArrived", {
                    get: function() {
                      return this._onMetaDataArrived;
                    },
                    set: function(E) {
                      this._onMetaDataArrived = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "onScriptDataArrived", {
                    get: function() {
                      return this._onScriptDataArrived;
                    },
                    set: function(E) {
                      this._onScriptDataArrived = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "onError", {
                    // prototype: function(type: number, info: string): void
                    get: function() {
                      return this._onError;
                    },
                    set: function(E) {
                      this._onError = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "onDataAvailable", {
                    // prototype: function(videoTrack: any, audioTrack: any): void
                    get: function() {
                      return this._onDataAvailable;
                    },
                    set: function(E) {
                      this._onDataAvailable = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "timestampBase", {
                    // timestamp base for output samples, must be in milliseconds
                    get: function() {
                      return this._timestampBase;
                    },
                    set: function(E) {
                      this._timestampBase = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "overridedDuration", {
                    get: function() {
                      return this._duration;
                    },
                    // Force-override media duration. Must be in milliseconds, int32
                    set: function(E) {
                      this._durationOverrided = !0, this._duration = E, this._mediaInfo.duration = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "overridedHasAudio", {
                    // Force-override audio track present flag, boolean
                    set: function(E) {
                      this._hasAudioFlagOverrided = !0, this._hasAudio = E, this._mediaInfo.hasAudio = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(v.prototype, "overridedHasVideo", {
                    // Force-override video track present flag, boolean
                    set: function(E) {
                      this._hasVideoFlagOverrided = !0, this._hasVideo = E, this._mediaInfo.hasVideo = E;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), v.prototype.resetMediaInfo = function() {
                    this._mediaInfo = new p.default();
                  }, v.prototype._isInitialMetadataDispatched = function() {
                    return this._hasAudio && this._hasVideo ? this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched : this._hasAudio && !this._hasVideo ? this._audioInitialMetadataDispatched : !this._hasAudio && this._hasVideo ? this._videoInitialMetadataDispatched : !1;
                  }, v.prototype.parseChunks = function(E, A) {
                    if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable)
                      throw new f.IllegalStateException("Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified");
                    var _ = 0, y = this._littleEndian;
                    if (A === 0)
                      if (E.byteLength > 13) {
                        var S = v.probe(E);
                        _ = S.dataOffset;
                      } else
                        return 0;
                    if (this._firstParse) {
                      this._firstParse = !1, A + _ !== this._dataOffset && u.default.w(this.TAG, "First time parsing but chunk byteStart invalid!");
                      var b = new DataView(E, _), w = b.getUint32(0, !y);
                      w !== 0 && u.default.w(this.TAG, "PrevTagSize0 !== 0 !!!"), _ += 4;
                    }
                    for (; _ < E.byteLength; ) {
                      this._dispatch = !0;
                      var b = new DataView(E, _);
                      if (_ + 11 + 4 > E.byteLength)
                        break;
                      var P = b.getUint8(0), C = b.getUint32(0, !y) & 16777215;
                      if (_ + 11 + C + 4 > E.byteLength)
                        break;
                      if (P !== 8 && P !== 9 && P !== 18) {
                        u.default.w(this.TAG, "Unsupported tag type " + P + ", skipped"), _ += 11 + C + 4;
                        continue;
                      }
                      var T = b.getUint8(4), x = b.getUint8(5), L = b.getUint8(6), I = b.getUint8(7), R = L | x << 8 | T << 16 | I << 24, B = b.getUint32(7, !y) & 16777215;
                      B !== 0 && u.default.w(this.TAG, "Meet tag which has StreamID != 0!");
                      var D = _ + 11;
                      switch (P) {
                        case 8:
                          this._parseAudioData(E, D, C, R);
                          break;
                        case 9:
                          this._parseVideoData(E, D, C, R, A + _);
                          break;
                        case 18:
                          this._parseScriptData(E, D, C);
                          break;
                      }
                      var k = b.getUint32(11 + C, !y);
                      k !== 11 + C && u.default.w(this.TAG, "Invalid PrevTagSize " + k), _ += 11 + C + 4;
                    }
                    return this._isInitialMetadataDispatched() && this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack), _;
                  }, v.prototype._parseScriptData = function(E, A, _) {
                    var y = c.default.parseScriptData(E, A, _);
                    if (y.hasOwnProperty("onMetaData")) {
                      if (y.onMetaData == null || typeof y.onMetaData != "object") {
                        u.default.w(this.TAG, "Invalid onMetaData structure!");
                        return;
                      }
                      this._metadata && u.default.w(this.TAG, "Found another onMetaData tag!"), this._metadata = y;
                      var S = this._metadata.onMetaData;
                      if (this._onMetaDataArrived && this._onMetaDataArrived(Object.assign({}, S)), typeof S.hasAudio == "boolean" && this._hasAudioFlagOverrided === !1 && (this._hasAudio = S.hasAudio, this._mediaInfo.hasAudio = this._hasAudio), typeof S.hasVideo == "boolean" && this._hasVideoFlagOverrided === !1 && (this._hasVideo = S.hasVideo, this._mediaInfo.hasVideo = this._hasVideo), typeof S.audiodatarate == "number" && (this._mediaInfo.audioDataRate = S.audiodatarate), typeof S.videodatarate == "number" && (this._mediaInfo.videoDataRate = S.videodatarate), typeof S.width == "number" && (this._mediaInfo.width = S.width), typeof S.height == "number" && (this._mediaInfo.height = S.height), typeof S.duration == "number") {
                        if (!this._durationOverrided) {
                          var b = Math.floor(S.duration * this._timescale);
                          this._duration = b, this._mediaInfo.duration = b;
                        }
                      } else
                        this._mediaInfo.duration = 0;
                      if (typeof S.framerate == "number") {
                        var w = Math.floor(S.framerate * 1e3);
                        if (w > 0) {
                          var P = w / 1e3;
                          this._referenceFrameRate.fixed = !0, this._referenceFrameRate.fps = P, this._referenceFrameRate.fps_num = w, this._referenceFrameRate.fps_den = 1e3, this._mediaInfo.fps = P;
                        }
                      }
                      if (typeof S.keyframes == "object") {
                        this._mediaInfo.hasKeyframesIndex = !0;
                        var C = S.keyframes;
                        this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(C), S.keyframes = null;
                      } else
                        this._mediaInfo.hasKeyframesIndex = !1;
                      this._dispatch = !1, this._mediaInfo.metadata = S, u.default.v(this.TAG, "Parsed onMetaData"), this._mediaInfo.isComplete() && this._onMediaInfo(this._mediaInfo);
                    }
                    Object.keys(y).length > 0 && this._onScriptDataArrived && this._onScriptDataArrived(Object.assign({}, y));
                  }, v.prototype._parseKeyframesIndex = function(E) {
                    for (var A = [], _ = [], y = 1; y < E.times.length; y++) {
                      var S = this._timestampBase + Math.floor(E.times[y] * 1e3);
                      A.push(S), _.push(E.filepositions[y]);
                    }
                    return {
                      times: A,
                      filepositions: _
                    };
                  }, v.prototype._parseAudioData = function(E, A, _, y) {
                    if (_ <= 1) {
                      u.default.w(this.TAG, "Flv: Invalid audio packet, missing SoundData payload!");
                      return;
                    }
                    if (!(this._hasAudioFlagOverrided === !0 && this._hasAudio === !1)) {
                      this._littleEndian;
                      var S = new DataView(E, A, _), b = S.getUint8(0), w = b >>> 4;
                      if (w !== 2 && w !== 10) {
                        this._onError(h.default.CODEC_UNSUPPORTED, "Flv: Unsupported audio codec idx: " + w);
                        return;
                      }
                      var P = 0, C = (b & 12) >>> 2;
                      if (C >= 0 && C <= 4)
                        P = this._flvSoundRateTable[C];
                      else {
                        this._onError(h.default.FORMAT_ERROR, "Flv: Invalid audio sample rate idx: " + C);
                        return;
                      }
                      var T = b & 1, x = this._audioMetadata, L = this._audioTrack;
                      if (x || (this._hasAudio === !1 && this._hasAudioFlagOverrided === !1 && (this._hasAudio = !0, this._mediaInfo.hasAudio = !0), x = this._audioMetadata = {}, x.type = "audio", x.id = L.id, x.timescale = this._timescale, x.duration = this._duration, x.audioSampleRate = P, x.channelCount = T === 0 ? 1 : 2), w === 10) {
                        var I = this._parseAACAudioData(E, A + 1, _ - 1);
                        if (I == null)
                          return;
                        if (I.packetType === 0) {
                          x.config && u.default.w(this.TAG, "Found another AudioSpecificConfig!");
                          var R = I.data;
                          x.audioSampleRate = R.samplingRate, x.channelCount = R.channelCount, x.codec = R.codec, x.originalCodec = R.originalCodec, x.config = R.config, x.refSampleDuration = 1024 / x.audioSampleRate * x.timescale, u.default.v(this.TAG, "Parsed AudioSpecificConfig"), this._isInitialMetadataDispatched() ? this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack) : this._audioInitialMetadataDispatched = !0, this._dispatch = !1, this._onTrackMetadata("audio", x);
                          var B = this._mediaInfo;
                          B.audioCodec = x.originalCodec, B.audioSampleRate = x.audioSampleRate, B.audioChannelCount = x.channelCount, B.hasVideo ? B.videoCodec != null && (B.mimeType = 'video/x-flv; codecs="' + B.videoCodec + "," + B.audioCodec + '"') : B.mimeType = 'video/x-flv; codecs="' + B.audioCodec + '"', B.isComplete() && this._onMediaInfo(B);
                        } else if (I.packetType === 1) {
                          var D = this._timestampBase + y, k = { unit: I.data, length: I.data.byteLength, dts: D, pts: D };
                          L.samples.push(k), L.length += I.data.length;
                        } else
                          u.default.e(this.TAG, "Flv: Unsupported AAC data type " + I.packetType);
                      } else if (w === 2) {
                        if (!x.codec) {
                          var R = this._parseMP3AudioData(E, A + 1, _ - 1, !0);
                          if (R == null)
                            return;
                          x.audioSampleRate = R.samplingRate, x.channelCount = R.channelCount, x.codec = R.codec, x.originalCodec = R.originalCodec, x.refSampleDuration = 1152 / x.audioSampleRate * x.timescale, u.default.v(this.TAG, "Parsed MPEG Audio Frame Header"), this._audioInitialMetadataDispatched = !0, this._onTrackMetadata("audio", x);
                          var B = this._mediaInfo;
                          B.audioCodec = x.codec, B.audioSampleRate = x.audioSampleRate, B.audioChannelCount = x.channelCount, B.audioDataRate = R.bitRate, B.hasVideo ? B.videoCodec != null && (B.mimeType = 'video/x-flv; codecs="' + B.videoCodec + "," + B.audioCodec + '"') : B.mimeType = 'video/x-flv; codecs="' + B.audioCodec + '"', B.isComplete() && this._onMediaInfo(B);
                        }
                        var F = this._parseMP3AudioData(E, A + 1, _ - 1, !1);
                        if (F == null)
                          return;
                        var D = this._timestampBase + y, U = { unit: F, length: F.byteLength, dts: D, pts: D };
                        L.samples.push(U), L.length += F.length;
                      }
                    }
                  }, v.prototype._parseAACAudioData = function(E, A, _) {
                    if (_ <= 1) {
                      u.default.w(this.TAG, "Flv: Invalid AAC packet, missing AACPacketType or/and Data!");
                      return;
                    }
                    var y = {}, S = new Uint8Array(E, A, _);
                    return y.packetType = S[0], S[0] === 0 ? y.data = this._parseAACAudioSpecificConfig(E, A + 1, _ - 1) : y.data = S.subarray(1), y;
                  }, v.prototype._parseAACAudioSpecificConfig = function(E, A, _) {
                    var y = new Uint8Array(E, A, _), S = null, b = 0, w = 0, P = 0, C = null;
                    if (b = w = y[0] >>> 3, P = (y[0] & 7) << 1 | y[1] >>> 7, P < 0 || P >= this._mpegSamplingRates.length) {
                      this._onError(h.default.FORMAT_ERROR, "Flv: AAC invalid sampling frequency index!");
                      return;
                    }
                    var T = this._mpegSamplingRates[P], x = (y[1] & 120) >>> 3;
                    if (x < 0 || x >= 8) {
                      this._onError(h.default.FORMAT_ERROR, "Flv: AAC invalid channel configuration");
                      return;
                    }
                    b === 5 && (C = (y[1] & 7) << 1 | y[2] >>> 7, (y[2] & 124) >>> 2);
                    var L = self.navigator.userAgent.toLowerCase();
                    return L.indexOf("firefox") !== -1 ? P >= 6 ? (b = 5, S = new Array(4), C = P - 3) : (b = 2, S = new Array(2), C = P) : L.indexOf("android") !== -1 ? (b = 2, S = new Array(2), C = P) : (b = 5, C = P, S = new Array(4), P >= 6 ? C = P - 3 : x === 1 && (b = 2, S = new Array(2), C = P)), S[0] = b << 3, S[0] |= (P & 15) >>> 1, S[1] = (P & 15) << 7, S[1] |= (x & 15) << 3, b === 5 && (S[1] |= (C & 15) >>> 1, S[2] = (C & 1) << 7, S[2] |= 8, S[3] = 0), {
                      config: S,
                      samplingRate: T,
                      channelCount: x,
                      codec: "mp4a.40." + b,
                      originalCodec: "mp4a.40." + w
                    };
                  }, v.prototype._parseMP3AudioData = function(E, A, _, y) {
                    if (_ < 4) {
                      u.default.w(this.TAG, "Flv: Invalid MP3 packet, header missing!");
                      return;
                    }
                    this._littleEndian;
                    var S = new Uint8Array(E, A, _), b = null;
                    if (y) {
                      if (S[0] !== 255)
                        return;
                      var w = S[1] >>> 3 & 3, P = (S[1] & 6) >> 1, C = (S[2] & 240) >>> 4, T = (S[2] & 12) >>> 2, x = S[3] >>> 6 & 3, L = x !== 3 ? 2 : 1, I = 0, R = 0, B = "mp3";
                      switch (w) {
                        case 0:
                          I = this._mpegAudioV25SampleRateTable[T];
                          break;
                        case 2:
                          I = this._mpegAudioV20SampleRateTable[T];
                          break;
                        case 3:
                          I = this._mpegAudioV10SampleRateTable[T];
                          break;
                      }
                      switch (P) {
                        case 1:
                          C < this._mpegAudioL3BitRateTable.length && (R = this._mpegAudioL3BitRateTable[C]);
                          break;
                        case 2:
                          C < this._mpegAudioL2BitRateTable.length && (R = this._mpegAudioL2BitRateTable[C]);
                          break;
                        case 3:
                          C < this._mpegAudioL1BitRateTable.length && (R = this._mpegAudioL1BitRateTable[C]);
                          break;
                      }
                      b = {
                        bitRate: R,
                        samplingRate: I,
                        channelCount: L,
                        codec: B,
                        originalCodec: B
                      };
                    } else
                      b = S;
                    return b;
                  }, v.prototype._parseVideoData = function(E, A, _, y, S) {
                    if (_ <= 1) {
                      u.default.w(this.TAG, "Flv: Invalid video packet, missing VideoData payload!");
                      return;
                    }
                    if (!(this._hasVideoFlagOverrided === !0 && this._hasVideo === !1)) {
                      var b = new Uint8Array(E, A, _)[0], w = (b & 240) >>> 4, P = b & 15;
                      if (P !== 7) {
                        this._onError(h.default.CODEC_UNSUPPORTED, "Flv: Unsupported codec in video frame: " + P);
                        return;
                      }
                      this._parseAVCVideoPacket(E, A + 1, _ - 1, y, S, w);
                    }
                  }, v.prototype._parseAVCVideoPacket = function(E, A, _, y, S, b) {
                    if (_ < 4) {
                      u.default.w(this.TAG, "Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime");
                      return;
                    }
                    var w = this._littleEndian, P = new DataView(E, A, _), C = P.getUint8(0), T = P.getUint32(0, !w) & 16777215, x = T << 8 >> 8;
                    if (C === 0)
                      this._parseAVCDecoderConfigurationRecord(E, A + 4, _ - 4);
                    else if (C === 1)
                      this._parseAVCVideoData(E, A + 4, _ - 4, y, S, b, x);
                    else if (C !== 2) {
                      this._onError(h.default.FORMAT_ERROR, "Flv: Invalid video packet type " + C);
                      return;
                    }
                  }, v.prototype._parseAVCDecoderConfigurationRecord = function(E, A, _) {
                    if (_ < 7) {
                      u.default.w(this.TAG, "Flv: Invalid AVCDecoderConfigurationRecord, lack of data!");
                      return;
                    }
                    var y = this._videoMetadata, S = this._videoTrack, b = this._littleEndian, w = new DataView(E, A, _);
                    y ? typeof y.avcc < "u" && u.default.w(this.TAG, "Found another AVCDecoderConfigurationRecord!") : (this._hasVideo === !1 && this._hasVideoFlagOverrided === !1 && (this._hasVideo = !0, this._mediaInfo.hasVideo = !0), y = this._videoMetadata = {}, y.type = "video", y.id = S.id, y.timescale = this._timescale, y.duration = this._duration);
                    var P = w.getUint8(0), C = w.getUint8(1);
                    if (w.getUint8(2), w.getUint8(3), P !== 1 || C === 0) {
                      this._onError(h.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord");
                      return;
                    }
                    if (this._naluLengthSize = (w.getUint8(4) & 3) + 1, this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {
                      this._onError(h.default.FORMAT_ERROR, "Flv: Strange NaluLengthSizeMinusOne: " + (this._naluLengthSize - 1));
                      return;
                    }
                    var T = w.getUint8(5) & 31;
                    if (T === 0) {
                      this._onError(h.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord: No SPS");
                      return;
                    } else
                      T > 1 && u.default.w(this.TAG, "Flv: Strange AVCDecoderConfigurationRecord: SPS Count = " + T);
                    for (var x = 6, L = 0; L < T; L++) {
                      var I = w.getUint16(x, !b);
                      if (x += 2, I !== 0) {
                        var R = new Uint8Array(E, A + x, I);
                        x += I;
                        var B = d.default.parseSPS(R);
                        if (L === 0) {
                          y.codecWidth = B.codec_size.width, y.codecHeight = B.codec_size.height, y.presentWidth = B.present_size.width, y.presentHeight = B.present_size.height, y.profile = B.profile_string, y.level = B.level_string, y.bitDepth = B.bit_depth, y.chromaFormat = B.chroma_format, y.sarRatio = B.sar_ratio, y.frameRate = B.frame_rate, (B.frame_rate.fixed === !1 || B.frame_rate.fps_num === 0 || B.frame_rate.fps_den === 0) && (y.frameRate = this._referenceFrameRate);
                          var D = y.frameRate.fps_den, k = y.frameRate.fps_num;
                          y.refSampleDuration = y.timescale * (D / k);
                          for (var F = R.subarray(1, 4), U = "avc1.", G = 0; G < 3; G++) {
                            var N = F[G].toString(16);
                            N.length < 2 && (N = "0" + N), U += N;
                          }
                          y.codec = U;
                          var V = this._mediaInfo;
                          V.width = y.codecWidth, V.height = y.codecHeight, V.fps = y.frameRate.fps, V.profile = y.profile, V.level = y.level, V.refFrames = B.ref_frames, V.chromaFormat = B.chroma_format_string, V.sarNum = y.sarRatio.width, V.sarDen = y.sarRatio.height, V.videoCodec = U, V.hasAudio ? V.audioCodec != null && (V.mimeType = 'video/x-flv; codecs="' + V.videoCodec + "," + V.audioCodec + '"') : V.mimeType = 'video/x-flv; codecs="' + V.videoCodec + '"', V.isComplete() && this._onMediaInfo(V);
                        }
                      }
                    }
                    var j = w.getUint8(x);
                    if (j === 0) {
                      this._onError(h.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord: No PPS");
                      return;
                    } else
                      j > 1 && u.default.w(this.TAG, "Flv: Strange AVCDecoderConfigurationRecord: PPS Count = " + j);
                    x++;
                    for (var L = 0; L < j; L++) {
                      var I = w.getUint16(x, !b);
                      x += 2, I !== 0 && (x += I);
                    }
                    y.avcc = new Uint8Array(_), y.avcc.set(new Uint8Array(E, A, _), 0), u.default.v(this.TAG, "Parsed AVCDecoderConfigurationRecord"), this._isInitialMetadataDispatched() ? this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack) : this._videoInitialMetadataDispatched = !0, this._dispatch = !1, this._onTrackMetadata("video", y);
                  }, v.prototype._parseAVCVideoData = function(E, A, _, y, S, b, w) {
                    for (var P = this._littleEndian, C = new DataView(E, A, _), T = [], x = 0, L = 0, I = this._naluLengthSize, R = this._timestampBase + y, B = b === 1; L < _; ) {
                      if (L + 4 >= _) {
                        u.default.w(this.TAG, "Malformed Nalu near timestamp " + R + ", offset = " + L + ", dataSize = " + _);
                        break;
                      }
                      var D = C.getUint32(L, !P);
                      if (I === 3 && (D >>>= 8), D > _ - I) {
                        u.default.w(this.TAG, "Malformed Nalus near timestamp " + R + ", NaluSize > DataSize!");
                        return;
                      }
                      var k = C.getUint8(L + I) & 31;
                      k === 5 && (B = !0);
                      var F = new Uint8Array(E, A + L, I + D), U = { type: k, data: F };
                      T.push(U), x += F.byteLength, L += I + D;
                    }
                    if (T.length) {
                      var G = this._videoTrack, N = {
                        units: T,
                        length: x,
                        isKeyframe: B,
                        dts: R,
                        cts: w,
                        pts: R + w
                      };
                      B && (N.fileposition = S), G.samples.push(N), G.length += x;
                    }
                  }, v;
                }()
              );
              a.default = m;
            }
          ),
          /***/
          "./src/demux/sps-parser.js": (
            /*!*********************************!*\
              !*** ./src/demux/sps-parser.js ***!
              \*********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ./exp-golomb.js */
                "./src/demux/exp-golomb.js"
              ), c = (
                /** @class */
                function() {
                  function d() {
                  }
                  return d._ebsp2rbsp = function(h) {
                    for (var p = h, f = p.byteLength, g = new Uint8Array(f), m = 0, v = 0; v < f; v++)
                      v >= 2 && p[v] === 3 && p[v - 1] === 0 && p[v - 2] === 0 || (g[m] = p[v], m++);
                    return new Uint8Array(g.buffer, 0, m);
                  }, d.parseSPS = function(h) {
                    var p = d._ebsp2rbsp(h), f = new u.default(p);
                    f.readByte();
                    var g = f.readByte();
                    f.readByte();
                    var m = f.readByte();
                    f.readUEG();
                    var v = d.getProfileString(g), E = d.getLevelString(m), A = 1, _ = 420, y = [0, 420, 422, 444], S = 8;
                    if ((g === 100 || g === 110 || g === 122 || g === 244 || g === 44 || g === 83 || g === 86 || g === 118 || g === 128 || g === 138 || g === 144) && (A = f.readUEG(), A === 3 && f.readBits(1), A <= 3 && (_ = y[A]), S = f.readUEG() + 8, f.readUEG(), f.readBits(1), f.readBool()))
                      for (var b = A !== 3 ? 8 : 12, w = 0; w < b; w++)
                        f.readBool() && (w < 6 ? d._skipScalingList(f, 16) : d._skipScalingList(f, 64));
                    f.readUEG();
                    var P = f.readUEG();
                    if (P === 0)
                      f.readUEG();
                    else if (P === 1) {
                      f.readBits(1), f.readSEG(), f.readSEG();
                      for (var C = f.readUEG(), w = 0; w < C; w++)
                        f.readSEG();
                    }
                    var T = f.readUEG();
                    f.readBits(1);
                    var x = f.readUEG(), L = f.readUEG(), I = f.readBits(1);
                    I === 0 && f.readBits(1), f.readBits(1);
                    var R = 0, B = 0, D = 0, k = 0, F = f.readBool();
                    F && (R = f.readUEG(), B = f.readUEG(), D = f.readUEG(), k = f.readUEG());
                    var U = 1, G = 1, N = 0, V = !0, j = 0, ee = 0, Y = f.readBool();
                    if (Y) {
                      if (f.readBool()) {
                        var te = f.readByte(), oe = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2], pe = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
                        te > 0 && te < 16 ? (U = oe[te - 1], G = pe[te - 1]) : te === 255 && (U = f.readByte() << 8 | f.readByte(), G = f.readByte() << 8 | f.readByte());
                      }
                      if (f.readBool() && f.readBool(), f.readBool() && (f.readBits(4), f.readBool() && f.readBits(24)), f.readBool() && (f.readUEG(), f.readUEG()), f.readBool()) {
                        var ae = f.readBits(32), Ie = f.readBits(32);
                        V = f.readBool(), j = Ie, ee = ae * 2, N = j / ee;
                      }
                    }
                    var ce = 1;
                    (U !== 1 || G !== 1) && (ce = U / G);
                    var ie = 0, Ae = 0;
                    if (A === 0)
                      ie = 1, Ae = 2 - I;
                    else {
                      var we = A === 3 ? 1 : 2, Ve = A === 1 ? 2 : 1;
                      ie = we, Ae = Ve * (2 - I);
                    }
                    var He = (x + 1) * 16, Ge = (2 - I) * ((L + 1) * 16);
                    He -= (R + B) * ie, Ge -= (D + k) * Ae;
                    var Me = Math.ceil(He * ce);
                    return f.destroy(), f = null, {
                      profile_string: v,
                      level_string: E,
                      bit_depth: S,
                      ref_frames: T,
                      chroma_format: _,
                      chroma_format_string: d.getChromaFormatString(_),
                      frame_rate: {
                        fixed: V,
                        fps: N,
                        fps_den: ee,
                        fps_num: j
                      },
                      sar_ratio: {
                        width: U,
                        height: G
                      },
                      codec_size: {
                        width: He,
                        height: Ge
                      },
                      present_size: {
                        width: Me,
                        height: Ge
                      }
                    };
                  }, d._skipScalingList = function(h, p) {
                    for (var f = 8, g = 8, m = 0, v = 0; v < p; v++)
                      g !== 0 && (m = h.readSEG(), g = (f + m + 256) % 256), f = g === 0 ? f : g;
                  }, d.getProfileString = function(h) {
                    switch (h) {
                      case 66:
                        return "Baseline";
                      case 77:
                        return "Main";
                      case 88:
                        return "Extended";
                      case 100:
                        return "High";
                      case 110:
                        return "High10";
                      case 122:
                        return "High422";
                      case 244:
                        return "High444";
                      default:
                        return "Unknown";
                    }
                  }, d.getLevelString = function(h) {
                    return (h / 10).toFixed(1);
                  }, d.getChromaFormatString = function(h) {
                    switch (h) {
                      case 420:
                        return "4:2:0";
                      case 422:
                        return "4:2:2";
                      case 444:
                        return "4:4:4";
                      default:
                        return "Unknown";
                    }
                  }, d;
                }()
              );
              a.default = c;
            }
          ),
          /***/
          "./src/flv.js": (
            /*!********************!*\
              !*** ./src/flv.js ***!
              \********************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ./utils/polyfill.js */
                "./src/utils/polyfill.js"
              ), c = l(
                /*! ./core/features.js */
                "./src/core/features.js"
              ), d = l(
                /*! ./io/loader.js */
                "./src/io/loader.js"
              ), h = l(
                /*! ./player/flv-player.js */
                "./src/player/flv-player.js"
              ), p = l(
                /*! ./player/native-player.js */
                "./src/player/native-player.js"
              ), f = l(
                /*! ./player/player-events.js */
                "./src/player/player-events.js"
              ), g = l(
                /*! ./player/player-errors.js */
                "./src/player/player-errors.js"
              ), m = l(
                /*! ./utils/logging-control.js */
                "./src/utils/logging-control.js"
              ), v = l(
                /*! ./utils/exception.js */
                "./src/utils/exception.js"
              );
              u.default.install();
              function E(S, b) {
                var w = S;
                if (w == null || typeof w != "object")
                  throw new v.InvalidArgumentException("MediaDataSource must be an javascript object!");
                if (!w.hasOwnProperty("type"))
                  throw new v.InvalidArgumentException("MediaDataSource must has type field to indicate video file type!");
                switch (w.type) {
                  case "flv":
                    return new h.default(w, b);
                  default:
                    return new p.default(w, b);
                }
              }
              function A() {
                return c.default.supportMSEH264Playback();
              }
              function _() {
                return c.default.getFeatureList();
              }
              var y = {};
              y.createPlayer = E, y.isSupported = A, y.getFeatureList = _, y.BaseLoader = d.BaseLoader, y.LoaderStatus = d.LoaderStatus, y.LoaderErrors = d.LoaderErrors, y.Events = f.default, y.ErrorTypes = g.ErrorTypes, y.ErrorDetails = g.ErrorDetails, y.FlvPlayer = h.default, y.NativePlayer = p.default, y.LoggingControl = m.default, Object.defineProperty(y, "version", {
                enumerable: !0,
                get: function() {
                  return "1.6.2";
                }
              }), a.default = y;
            }
          ),
          /***/
          "./src/index.js": (
            /*!**********************!*\
              !*** ./src/index.js ***!
              \**********************/
            /***/
            function(o, a, l) {
              o.exports = l(
                /*! ./flv.js */
                "./src/flv.js"
              ).default;
            }
          ),
          /***/
          "./src/io/fetch-stream-loader.js": (
            /*!***************************************!*\
              !*** ./src/io/fetch-stream-loader.js ***!
              \***************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              ), c = l(
                /*! ./loader.js */
                "./src/io/loader.js"
              ), d = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), h = function() {
                var f = function(g, m) {
                  return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, E) {
                    v.__proto__ = E;
                  } || function(v, E) {
                    for (var A in E)
                      Object.prototype.hasOwnProperty.call(E, A) && (v[A] = E[A]);
                  }, f(g, m);
                };
                return function(g, m) {
                  if (typeof m != "function" && m !== null)
                    throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
                  f(g, m);
                  function v() {
                    this.constructor = g;
                  }
                  g.prototype = m === null ? Object.create(m) : (v.prototype = m.prototype, new v());
                };
              }(), p = (
                /** @class */
                function(f) {
                  h(g, f);
                  function g(m, v) {
                    var E = f.call(this, "fetch-stream-loader") || this;
                    return E.TAG = "FetchStreamLoader", E._seekHandler = m, E._config = v, E._needStash = !0, E._requestAbort = !1, E._contentLength = null, E._receivedLength = 0, E;
                  }
                  return g.isSupported = function() {
                    try {
                      var m = u.default.msedge && u.default.version.minor >= 15048, v = u.default.msedge ? m : !0;
                      return self.fetch && self.ReadableStream && v;
                    } catch {
                      return !1;
                    }
                  }, g.prototype.destroy = function() {
                    this.isWorking() && this.abort(), f.prototype.destroy.call(this);
                  }, g.prototype.open = function(m, v) {
                    var E = this;
                    this._dataSource = m, this._range = v;
                    var A = m.url;
                    this._config.reuseRedirectedURL && m.redirectedURL != null && (A = m.redirectedURL);
                    var _ = this._seekHandler.getConfig(A, v), y = new self.Headers();
                    if (typeof _.headers == "object") {
                      var S = _.headers;
                      for (var b in S)
                        S.hasOwnProperty(b) && y.append(b, S[b]);
                    }
                    var w = {
                      method: "GET",
                      headers: y,
                      mode: "cors",
                      cache: "default",
                      // The default policy of Fetch API in the whatwg standard
                      // Safari incorrectly indicates 'no-referrer' as default policy, fuck it
                      referrerPolicy: "no-referrer-when-downgrade"
                    };
                    if (typeof this._config.headers == "object")
                      for (var b in this._config.headers)
                        y.append(b, this._config.headers[b]);
                    m.cors === !1 && (w.mode = "same-origin"), m.withCredentials && (w.credentials = "include"), m.referrerPolicy && (w.referrerPolicy = m.referrerPolicy), self.AbortController && (this._abortController = new self.AbortController(), w.signal = this._abortController.signal), this._status = c.LoaderStatus.kConnecting, self.fetch(_.url, w).then(function(P) {
                      if (E._requestAbort) {
                        E._status = c.LoaderStatus.kIdle, P.body.cancel();
                        return;
                      }
                      if (P.ok && P.status >= 200 && P.status <= 299) {
                        if (P.url !== _.url && E._onURLRedirect) {
                          var C = E._seekHandler.removeURLParameters(P.url);
                          E._onURLRedirect(C);
                        }
                        var T = P.headers.get("Content-Length");
                        return T != null && (E._contentLength = parseInt(T), E._contentLength !== 0 && E._onContentLengthKnown && E._onContentLengthKnown(E._contentLength)), E._pump.call(E, P.body.getReader());
                      } else if (E._status = c.LoaderStatus.kError, E._onError)
                        E._onError(c.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: P.status, msg: P.statusText });
                      else
                        throw new d.RuntimeException("FetchStreamLoader: Http code invalid, " + P.status + " " + P.statusText);
                    }).catch(function(P) {
                      if (!(E._abortController && E._abortController.signal.aborted))
                        if (E._status = c.LoaderStatus.kError, E._onError)
                          E._onError(c.LoaderErrors.EXCEPTION, { code: -1, msg: P.message });
                        else
                          throw P;
                    });
                  }, g.prototype.abort = function() {
                    if (this._requestAbort = !0, (this._status !== c.LoaderStatus.kBuffering || !u.default.chrome) && this._abortController)
                      try {
                        this._abortController.abort();
                      } catch {
                      }
                  }, g.prototype._pump = function(m) {
                    var v = this;
                    return m.read().then(function(E) {
                      if (E.done)
                        if (v._contentLength !== null && v._receivedLength < v._contentLength) {
                          v._status = c.LoaderStatus.kError;
                          var A = c.LoaderErrors.EARLY_EOF, _ = { code: -1, msg: "Fetch stream meet Early-EOF" };
                          if (v._onError)
                            v._onError(A, _);
                          else
                            throw new d.RuntimeException(_.msg);
                        } else
                          v._status = c.LoaderStatus.kComplete, v._onComplete && v._onComplete(v._range.from, v._range.from + v._receivedLength - 1);
                      else {
                        if (v._abortController && v._abortController.signal.aborted) {
                          v._status = c.LoaderStatus.kComplete;
                          return;
                        } else if (v._requestAbort === !0)
                          return v._status = c.LoaderStatus.kComplete, m.cancel();
                        v._status = c.LoaderStatus.kBuffering;
                        var y = E.value.buffer, S = v._range.from + v._receivedLength;
                        v._receivedLength += y.byteLength, v._onDataArrival && v._onDataArrival(y, S, v._receivedLength), v._pump(m);
                      }
                    }).catch(function(E) {
                      if (v._abortController && v._abortController.signal.aborted) {
                        v._status = c.LoaderStatus.kComplete;
                        return;
                      }
                      if (!(E.code === 11 && u.default.msedge)) {
                        v._status = c.LoaderStatus.kError;
                        var A = 0, _ = null;
                        if ((E.code === 19 || E.message === "network error") && // NETWORK_ERR
                        (v._contentLength === null || v._contentLength !== null && v._receivedLength < v._contentLength) ? (A = c.LoaderErrors.EARLY_EOF, _ = { code: E.code, msg: "Fetch stream meet Early-EOF" }) : (A = c.LoaderErrors.EXCEPTION, _ = { code: E.code, msg: E.message }), v._onError)
                          v._onError(A, _);
                        else
                          throw new d.RuntimeException(_.msg);
                      }
                    });
                  }, g;
                }(c.BaseLoader)
              );
              a.default = p;
            }
          ),
          /***/
          "./src/io/io-controller.js": (
            /*!*********************************!*\
              !*** ./src/io/io-controller.js ***!
              \*********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), c = l(
                /*! ./speed-sampler.js */
                "./src/io/speed-sampler.js"
              ), d = l(
                /*! ./loader.js */
                "./src/io/loader.js"
              ), h = l(
                /*! ./fetch-stream-loader.js */
                "./src/io/fetch-stream-loader.js"
              ), p = l(
                /*! ./xhr-moz-chunked-loader.js */
                "./src/io/xhr-moz-chunked-loader.js"
              ), f = l(
                /*! ./xhr-range-loader.js */
                "./src/io/xhr-range-loader.js"
              ), g = l(
                /*! ./websocket-loader.js */
                "./src/io/websocket-loader.js"
              ), m = l(
                /*! ./range-seek-handler.js */
                "./src/io/range-seek-handler.js"
              ), v = l(
                /*! ./param-seek-handler.js */
                "./src/io/param-seek-handler.js"
              ), E = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), A = (
                /** @class */
                function() {
                  function _(y, S, b) {
                    this.TAG = "IOController", this._config = S, this._extraData = b, this._stashInitialSize = 1024 * 384, S.stashInitialSize != null && S.stashInitialSize > 0 && (this._stashInitialSize = S.stashInitialSize), this._stashUsed = 0, this._stashSize = this._stashInitialSize, this._bufferSize = 1024 * 1024 * 3, this._stashBuffer = new ArrayBuffer(this._bufferSize), this._stashByteStart = 0, this._enableStash = !0, S.enableStashBuffer === !1 && (this._enableStash = !1), this._loader = null, this._loaderClass = null, this._seekHandler = null, this._dataSource = y, this._isWebSocketURL = /wss?:\/\/(.+?)/.test(y.url), this._refTotalLength = y.filesize ? y.filesize : null, this._totalLength = this._refTotalLength, this._fullRequestFlag = !1, this._currentRange = null, this._redirectedURL = null, this._speedNormalized = 0, this._speedSampler = new c.default(), this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096], this._isEarlyEofReconnecting = !1, this._paused = !1, this._resumeFrom = 0, this._onDataArrival = null, this._onSeeked = null, this._onError = null, this._onComplete = null, this._onRedirect = null, this._onRecoveredEarlyEof = null, this._selectSeekHandler(), this._selectLoader(), this._createLoader();
                  }
                  return _.prototype.destroy = function() {
                    this._loader.isWorking() && this._loader.abort(), this._loader.destroy(), this._loader = null, this._loaderClass = null, this._dataSource = null, this._stashBuffer = null, this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0, this._currentRange = null, this._speedSampler = null, this._isEarlyEofReconnecting = !1, this._onDataArrival = null, this._onSeeked = null, this._onError = null, this._onComplete = null, this._onRedirect = null, this._onRecoveredEarlyEof = null, this._extraData = null;
                  }, _.prototype.isWorking = function() {
                    return this._loader && this._loader.isWorking() && !this._paused;
                  }, _.prototype.isPaused = function() {
                    return this._paused;
                  }, Object.defineProperty(_.prototype, "status", {
                    get: function() {
                      return this._loader.status;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "extraData", {
                    get: function() {
                      return this._extraData;
                    },
                    set: function(y) {
                      this._extraData = y;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "onDataArrival", {
                    // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number
                    get: function() {
                      return this._onDataArrival;
                    },
                    set: function(y) {
                      this._onDataArrival = y;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "onSeeked", {
                    get: function() {
                      return this._onSeeked;
                    },
                    set: function(y) {
                      this._onSeeked = y;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "onError", {
                    // prototype: function onError(type: number, info: {code: number, msg: string}): void
                    get: function() {
                      return this._onError;
                    },
                    set: function(y) {
                      this._onError = y;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "onComplete", {
                    get: function() {
                      return this._onComplete;
                    },
                    set: function(y) {
                      this._onComplete = y;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "onRedirect", {
                    get: function() {
                      return this._onRedirect;
                    },
                    set: function(y) {
                      this._onRedirect = y;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "onRecoveredEarlyEof", {
                    get: function() {
                      return this._onRecoveredEarlyEof;
                    },
                    set: function(y) {
                      this._onRecoveredEarlyEof = y;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "currentURL", {
                    get: function() {
                      return this._dataSource.url;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "hasRedirect", {
                    get: function() {
                      return this._redirectedURL != null || this._dataSource.redirectedURL != null;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "currentRedirectedURL", {
                    get: function() {
                      return this._redirectedURL || this._dataSource.redirectedURL;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "currentSpeed", {
                    // in KB/s
                    get: function() {
                      return this._loaderClass === f.default ? this._loader.currentSpeed : this._speedSampler.lastSecondKBps;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(_.prototype, "loaderType", {
                    get: function() {
                      return this._loader.type;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), _.prototype._selectSeekHandler = function() {
                    var y = this._config;
                    if (y.seekType === "range")
                      this._seekHandler = new m.default(this._config.rangeLoadZeroStart);
                    else if (y.seekType === "param") {
                      var S = y.seekParamStart || "bstart", b = y.seekParamEnd || "bend";
                      this._seekHandler = new v.default(S, b);
                    } else if (y.seekType === "custom") {
                      if (typeof y.customSeekHandler != "function")
                        throw new E.InvalidArgumentException("Custom seekType specified in config but invalid customSeekHandler!");
                      this._seekHandler = new y.customSeekHandler();
                    } else
                      throw new E.InvalidArgumentException("Invalid seekType in config: " + y.seekType);
                  }, _.prototype._selectLoader = function() {
                    if (this._config.customLoader != null)
                      this._loaderClass = this._config.customLoader;
                    else if (this._isWebSocketURL)
                      this._loaderClass = g.default;
                    else if (h.default.isSupported())
                      this._loaderClass = h.default;
                    else if (p.default.isSupported())
                      this._loaderClass = p.default;
                    else if (f.default.isSupported())
                      this._loaderClass = f.default;
                    else
                      throw new E.RuntimeException("Your browser doesn't support xhr with arraybuffer responseType!");
                  }, _.prototype._createLoader = function() {
                    this._loader = new this._loaderClass(this._seekHandler, this._config), this._loader.needStashBuffer === !1 && (this._enableStash = !1), this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this), this._loader.onURLRedirect = this._onURLRedirect.bind(this), this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this), this._loader.onComplete = this._onLoaderComplete.bind(this), this._loader.onError = this._onLoaderError.bind(this);
                  }, _.prototype.open = function(y) {
                    this._currentRange = { from: 0, to: -1 }, y && (this._currentRange.from = y), this._speedSampler.reset(), y || (this._fullRequestFlag = !0), this._loader.open(this._dataSource, Object.assign({}, this._currentRange));
                  }, _.prototype.abort = function() {
                    this._loader.abort(), this._paused && (this._paused = !1, this._resumeFrom = 0);
                  }, _.prototype.pause = function() {
                    this.isWorking() && (this._loader.abort(), this._stashUsed !== 0 ? (this._resumeFrom = this._stashByteStart, this._currentRange.to = this._stashByteStart - 1) : this._resumeFrom = this._currentRange.to + 1, this._stashUsed = 0, this._stashByteStart = 0, this._paused = !0);
                  }, _.prototype.resume = function() {
                    if (this._paused) {
                      this._paused = !1;
                      var y = this._resumeFrom;
                      this._resumeFrom = 0, this._internalSeek(y, !0);
                    }
                  }, _.prototype.seek = function(y) {
                    this._paused = !1, this._stashUsed = 0, this._stashByteStart = 0, this._internalSeek(y, !0);
                  }, _.prototype._internalSeek = function(y, S) {
                    this._loader.isWorking() && this._loader.abort(), this._flushStashBuffer(S), this._loader.destroy(), this._loader = null;
                    var b = { from: y, to: -1 };
                    this._currentRange = { from: b.from, to: -1 }, this._speedSampler.reset(), this._stashSize = this._stashInitialSize, this._createLoader(), this._loader.open(this._dataSource, b), this._onSeeked && this._onSeeked();
                  }, _.prototype.updateUrl = function(y) {
                    if (!y || typeof y != "string" || y.length === 0)
                      throw new E.InvalidArgumentException("Url must be a non-empty string!");
                    this._dataSource.url = y;
                  }, _.prototype._expandBuffer = function(y) {
                    for (var S = this._stashSize; S + 1024 * 1024 * 1 < y; )
                      S *= 2;
                    if (S += 1024 * 1024 * 1, S !== this._bufferSize) {
                      var b = new ArrayBuffer(S);
                      if (this._stashUsed > 0) {
                        var w = new Uint8Array(this._stashBuffer, 0, this._stashUsed), P = new Uint8Array(b, 0, S);
                        P.set(w, 0);
                      }
                      this._stashBuffer = b, this._bufferSize = S;
                    }
                  }, _.prototype._normalizeSpeed = function(y) {
                    var S = this._speedNormalizeList, b = S.length - 1, w = 0, P = 0, C = b;
                    if (y < S[0])
                      return S[0];
                    for (; P <= C; ) {
                      if (w = P + Math.floor((C - P) / 2), w === b || y >= S[w] && y < S[w + 1])
                        return S[w];
                      S[w] < y ? P = w + 1 : C = w - 1;
                    }
                  }, _.prototype._adjustStashSize = function(y) {
                    var S = 0;
                    this._config.isLive || y < 512 ? S = y : y >= 512 && y <= 1024 ? S = Math.floor(y * 1.5) : S = y * 2, S > 8192 && (S = 8192);
                    var b = S * 1024 + 1024 * 1024 * 1;
                    this._bufferSize < b && this._expandBuffer(b), this._stashSize = S * 1024;
                  }, _.prototype._dispatchChunks = function(y, S) {
                    return this._currentRange.to = S + y.byteLength - 1, this._onDataArrival(y, S);
                  }, _.prototype._onURLRedirect = function(y) {
                    this._redirectedURL = y, this._onRedirect && this._onRedirect(y);
                  }, _.prototype._onContentLengthKnown = function(y) {
                    y && this._fullRequestFlag && (this._totalLength = y, this._fullRequestFlag = !1);
                  }, _.prototype._onLoaderChunkArrival = function(y, S, b) {
                    if (!this._onDataArrival)
                      throw new E.IllegalStateException("IOController: No existing consumer (onDataArrival) callback!");
                    if (!this._paused) {
                      this._isEarlyEofReconnecting && (this._isEarlyEofReconnecting = !1, this._onRecoveredEarlyEof && this._onRecoveredEarlyEof()), this._speedSampler.addBytes(y.byteLength);
                      var w = this._speedSampler.lastSecondKBps;
                      if (w !== 0) {
                        var P = this._normalizeSpeed(w);
                        this._speedNormalized !== P && (this._speedNormalized = P, this._adjustStashSize(P));
                      }
                      if (this._enableStash)
                        if (this._stashUsed === 0 && this._stashByteStart === 0 && (this._stashByteStart = S), this._stashUsed + y.byteLength <= this._stashSize) {
                          var x = new Uint8Array(this._stashBuffer, 0, this._stashSize);
                          x.set(new Uint8Array(y), this._stashUsed), this._stashUsed += y.byteLength;
                        } else {
                          var x = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                          if (this._stashUsed > 0) {
                            var I = this._stashBuffer.slice(0, this._stashUsed), C = this._dispatchChunks(I, this._stashByteStart);
                            if (C < I.byteLength) {
                              if (C > 0) {
                                var L = new Uint8Array(I, C);
                                x.set(L, 0), this._stashUsed = L.byteLength, this._stashByteStart += C;
                              }
                            } else
                              this._stashUsed = 0, this._stashByteStart += C;
                            this._stashUsed + y.byteLength > this._bufferSize && (this._expandBuffer(this._stashUsed + y.byteLength), x = new Uint8Array(this._stashBuffer, 0, this._bufferSize)), x.set(new Uint8Array(y), this._stashUsed), this._stashUsed += y.byteLength;
                          } else {
                            var C = this._dispatchChunks(y, S);
                            if (C < y.byteLength) {
                              var T = y.byteLength - C;
                              T > this._bufferSize && (this._expandBuffer(T), x = new Uint8Array(this._stashBuffer, 0, this._bufferSize)), x.set(new Uint8Array(y, C), 0), this._stashUsed += T, this._stashByteStart = S + C;
                            }
                          }
                        }
                      else if (this._stashUsed === 0) {
                        var C = this._dispatchChunks(y, S);
                        if (C < y.byteLength) {
                          var T = y.byteLength - C;
                          T > this._bufferSize && this._expandBuffer(T);
                          var x = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                          x.set(new Uint8Array(y, C), 0), this._stashUsed += T, this._stashByteStart = S + C;
                        }
                      } else {
                        this._stashUsed + y.byteLength > this._bufferSize && this._expandBuffer(this._stashUsed + y.byteLength);
                        var x = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                        x.set(new Uint8Array(y), this._stashUsed), this._stashUsed += y.byteLength;
                        var C = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);
                        if (C < this._stashUsed && C > 0) {
                          var L = new Uint8Array(this._stashBuffer, C);
                          x.set(L, 0);
                        }
                        this._stashUsed -= C, this._stashByteStart += C;
                      }
                    }
                  }, _.prototype._flushStashBuffer = function(y) {
                    if (this._stashUsed > 0) {
                      var S = this._stashBuffer.slice(0, this._stashUsed), b = this._dispatchChunks(S, this._stashByteStart), w = S.byteLength - b;
                      if (b < S.byteLength)
                        if (y)
                          u.default.w(this.TAG, w + " bytes unconsumed data remain when flush buffer, dropped");
                        else {
                          if (b > 0) {
                            var P = new Uint8Array(this._stashBuffer, 0, this._bufferSize), C = new Uint8Array(S, b);
                            P.set(C, 0), this._stashUsed = C.byteLength, this._stashByteStart += b;
                          }
                          return 0;
                        }
                      return this._stashUsed = 0, this._stashByteStart = 0, w;
                    }
                    return 0;
                  }, _.prototype._onLoaderComplete = function(y, S) {
                    this._flushStashBuffer(!0), this._onComplete && this._onComplete(this._extraData);
                  }, _.prototype._onLoaderError = function(y, S) {
                    switch (u.default.e(this.TAG, "Loader error, code = " + S.code + ", msg = " + S.msg), this._flushStashBuffer(!1), this._isEarlyEofReconnecting && (this._isEarlyEofReconnecting = !1, y = d.LoaderErrors.UNRECOVERABLE_EARLY_EOF), y) {
                      case d.LoaderErrors.EARLY_EOF: {
                        if (!this._config.isLive && this._totalLength) {
                          var b = this._currentRange.to + 1;
                          b < this._totalLength && (u.default.w(this.TAG, "Connection lost, trying reconnect..."), this._isEarlyEofReconnecting = !0, this._internalSeek(b, !1));
                          return;
                        }
                        y = d.LoaderErrors.UNRECOVERABLE_EARLY_EOF;
                        break;
                      }
                      case d.LoaderErrors.UNRECOVERABLE_EARLY_EOF:
                      case d.LoaderErrors.CONNECTING_TIMEOUT:
                      case d.LoaderErrors.HTTP_STATUS_CODE_INVALID:
                      case d.LoaderErrors.EXCEPTION:
                        break;
                    }
                    if (this._onError)
                      this._onError(y, S);
                    else
                      throw new E.RuntimeException("IOException: " + S.msg);
                  }, _;
                }()
              );
              a.default = A;
            }
          ),
          /***/
          "./src/io/loader.js": (
            /*!**************************!*\
              !*** ./src/io/loader.js ***!
              \**************************/
            /***/
            function(o, a, l) {
              l.r(a), l.d(a, {
                /* harmony export */
                LoaderStatus: function() {
                  return (
                    /* binding */
                    c
                  );
                },
                /* harmony export */
                LoaderErrors: function() {
                  return (
                    /* binding */
                    d
                  );
                },
                /* harmony export */
                BaseLoader: function() {
                  return (
                    /* binding */
                    h
                  );
                }
                /* harmony export */
              });
              var u = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), c = {
                kIdle: 0,
                kConnecting: 1,
                kBuffering: 2,
                kError: 3,
                kComplete: 4
              }, d = {
                OK: "OK",
                EXCEPTION: "Exception",
                HTTP_STATUS_CODE_INVALID: "HttpStatusCodeInvalid",
                CONNECTING_TIMEOUT: "ConnectingTimeout",
                EARLY_EOF: "EarlyEof",
                UNRECOVERABLE_EARLY_EOF: "UnrecoverableEarlyEof"
              }, h = (
                /** @class */
                function() {
                  function p(f) {
                    this._type = f || "undefined", this._status = c.kIdle, this._needStash = !1, this._onContentLengthKnown = null, this._onURLRedirect = null, this._onDataArrival = null, this._onError = null, this._onComplete = null;
                  }
                  return p.prototype.destroy = function() {
                    this._status = c.kIdle, this._onContentLengthKnown = null, this._onURLRedirect = null, this._onDataArrival = null, this._onError = null, this._onComplete = null;
                  }, p.prototype.isWorking = function() {
                    return this._status === c.kConnecting || this._status === c.kBuffering;
                  }, Object.defineProperty(p.prototype, "type", {
                    get: function() {
                      return this._type;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "status", {
                    get: function() {
                      return this._status;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "needStashBuffer", {
                    get: function() {
                      return this._needStash;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "onContentLengthKnown", {
                    get: function() {
                      return this._onContentLengthKnown;
                    },
                    set: function(f) {
                      this._onContentLengthKnown = f;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "onURLRedirect", {
                    get: function() {
                      return this._onURLRedirect;
                    },
                    set: function(f) {
                      this._onURLRedirect = f;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "onDataArrival", {
                    get: function() {
                      return this._onDataArrival;
                    },
                    set: function(f) {
                      this._onDataArrival = f;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "onError", {
                    get: function() {
                      return this._onError;
                    },
                    set: function(f) {
                      this._onError = f;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "onComplete", {
                    get: function() {
                      return this._onComplete;
                    },
                    set: function(f) {
                      this._onComplete = f;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), p.prototype.open = function(f, g) {
                    throw new u.NotImplementedException("Unimplemented abstract function!");
                  }, p.prototype.abort = function() {
                    throw new u.NotImplementedException("Unimplemented abstract function!");
                  }, p;
                }()
              );
            }
          ),
          /***/
          "./src/io/param-seek-handler.js": (
            /*!**************************************!*\
              !*** ./src/io/param-seek-handler.js ***!
              \**************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = (
                /** @class */
                function() {
                  function c(d, h) {
                    this._startName = d, this._endName = h;
                  }
                  return c.prototype.getConfig = function(d, h) {
                    var p = d;
                    if (h.from !== 0 || h.to !== -1) {
                      var f = !0;
                      p.indexOf("?") === -1 && (p += "?", f = !1), f && (p += "&"), p += this._startName + "=" + h.from.toString(), h.to !== -1 && (p += "&" + this._endName + "=" + h.to.toString());
                    }
                    return {
                      url: p,
                      headers: {}
                    };
                  }, c.prototype.removeURLParameters = function(d) {
                    var h = d.split("?")[0], p = void 0, f = d.indexOf("?");
                    f !== -1 && (p = d.substring(f + 1));
                    var g = "";
                    if (p != null && p.length > 0)
                      for (var m = p.split("&"), v = 0; v < m.length; v++) {
                        var E = m[v].split("="), A = v > 0;
                        E[0] !== this._startName && E[0] !== this._endName && (A && (g += "&"), g += m[v]);
                      }
                    return g.length === 0 ? h : h + "?" + g;
                  }, c;
                }()
              );
              a.default = u;
            }
          ),
          /***/
          "./src/io/range-seek-handler.js": (
            /*!**************************************!*\
              !*** ./src/io/range-seek-handler.js ***!
              \**************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = (
                /** @class */
                function() {
                  function c(d) {
                    this._zeroStart = d || !1;
                  }
                  return c.prototype.getConfig = function(d, h) {
                    var p = {};
                    if (h.from !== 0 || h.to !== -1) {
                      var f = void 0;
                      h.to !== -1 ? f = "bytes=" + h.from.toString() + "-" + h.to.toString() : f = "bytes=" + h.from.toString() + "-", p.Range = f;
                    } else
                      this._zeroStart && (p.Range = "bytes=0-");
                    return {
                      url: d,
                      headers: p
                    };
                  }, c.prototype.removeURLParameters = function(d) {
                    return d;
                  }, c;
                }()
              );
              a.default = u;
            }
          ),
          /***/
          "./src/io/speed-sampler.js": (
            /*!*********************************!*\
              !*** ./src/io/speed-sampler.js ***!
              \*********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = (
                /** @class */
                function() {
                  function c() {
                    this._firstCheckpoint = 0, this._lastCheckpoint = 0, this._intervalBytes = 0, this._totalBytes = 0, this._lastSecondBytes = 0, self.performance && self.performance.now ? this._now = self.performance.now.bind(self.performance) : this._now = Date.now;
                  }
                  return c.prototype.reset = function() {
                    this._firstCheckpoint = this._lastCheckpoint = 0, this._totalBytes = this._intervalBytes = 0, this._lastSecondBytes = 0;
                  }, c.prototype.addBytes = function(d) {
                    this._firstCheckpoint === 0 ? (this._firstCheckpoint = this._now(), this._lastCheckpoint = this._firstCheckpoint, this._intervalBytes += d, this._totalBytes += d) : this._now() - this._lastCheckpoint < 1e3 ? (this._intervalBytes += d, this._totalBytes += d) : (this._lastSecondBytes = this._intervalBytes, this._intervalBytes = d, this._totalBytes += d, this._lastCheckpoint = this._now());
                  }, Object.defineProperty(c.prototype, "currentKBps", {
                    get: function() {
                      this.addBytes(0);
                      var d = (this._now() - this._lastCheckpoint) / 1e3;
                      return d == 0 && (d = 1), this._intervalBytes / d / 1024;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(c.prototype, "lastSecondKBps", {
                    get: function() {
                      return this.addBytes(0), this._lastSecondBytes !== 0 ? this._lastSecondBytes / 1024 : this._now() - this._lastCheckpoint >= 500 ? this.currentKBps : 0;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(c.prototype, "averageKBps", {
                    get: function() {
                      var d = (this._now() - this._firstCheckpoint) / 1e3;
                      return this._totalBytes / d / 1024;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), c;
                }()
              );
              a.default = u;
            }
          ),
          /***/
          "./src/io/websocket-loader.js": (
            /*!************************************!*\
              !*** ./src/io/websocket-loader.js ***!
              \************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ./loader.js */
                "./src/io/loader.js"
              ), c = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), d = function() {
                var p = function(f, g) {
                  return p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(m, v) {
                    m.__proto__ = v;
                  } || function(m, v) {
                    for (var E in v)
                      Object.prototype.hasOwnProperty.call(v, E) && (m[E] = v[E]);
                  }, p(f, g);
                };
                return function(f, g) {
                  if (typeof g != "function" && g !== null)
                    throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                  p(f, g);
                  function m() {
                    this.constructor = f;
                  }
                  f.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
                };
              }(), h = (
                /** @class */
                function(p) {
                  d(f, p);
                  function f() {
                    var g = p.call(this, "websocket-loader") || this;
                    return g.TAG = "WebSocketLoader", g._needStash = !0, g._ws = null, g._requestAbort = !1, g._receivedLength = 0, g;
                  }
                  return f.isSupported = function() {
                    try {
                      return typeof self.WebSocket < "u";
                    } catch {
                      return !1;
                    }
                  }, f.prototype.destroy = function() {
                    this._ws && this.abort(), p.prototype.destroy.call(this);
                  }, f.prototype.open = function(g) {
                    try {
                      var m = this._ws = new self.WebSocket(g.url);
                      m.binaryType = "arraybuffer", m.onopen = this._onWebSocketOpen.bind(this), m.onclose = this._onWebSocketClose.bind(this), m.onmessage = this._onWebSocketMessage.bind(this), m.onerror = this._onWebSocketError.bind(this), this._status = u.LoaderStatus.kConnecting;
                    } catch (E) {
                      this._status = u.LoaderStatus.kError;
                      var v = { code: E.code, msg: E.message };
                      if (this._onError)
                        this._onError(u.LoaderErrors.EXCEPTION, v);
                      else
                        throw new c.RuntimeException(v.msg);
                    }
                  }, f.prototype.abort = function() {
                    var g = this._ws;
                    g && (g.readyState === 0 || g.readyState === 1) && (this._requestAbort = !0, g.close()), this._ws = null, this._status = u.LoaderStatus.kComplete;
                  }, f.prototype._onWebSocketOpen = function(g) {
                    this._status = u.LoaderStatus.kBuffering;
                  }, f.prototype._onWebSocketClose = function(g) {
                    if (this._requestAbort === !0) {
                      this._requestAbort = !1;
                      return;
                    }
                    this._status = u.LoaderStatus.kComplete, this._onComplete && this._onComplete(0, this._receivedLength - 1);
                  }, f.prototype._onWebSocketMessage = function(g) {
                    var m = this;
                    if (g.data instanceof ArrayBuffer)
                      this._dispatchArrayBuffer(g.data);
                    else if (g.data instanceof Blob) {
                      var v = new FileReader();
                      v.onload = function() {
                        m._dispatchArrayBuffer(v.result);
                      }, v.readAsArrayBuffer(g.data);
                    } else {
                      this._status = u.LoaderStatus.kError;
                      var E = { code: -1, msg: "Unsupported WebSocket message type: " + g.data.constructor.name };
                      if (this._onError)
                        this._onError(u.LoaderErrors.EXCEPTION, E);
                      else
                        throw new c.RuntimeException(E.msg);
                    }
                  }, f.prototype._dispatchArrayBuffer = function(g) {
                    var m = g, v = this._receivedLength;
                    this._receivedLength += m.byteLength, this._onDataArrival && this._onDataArrival(m, v, this._receivedLength);
                  }, f.prototype._onWebSocketError = function(g) {
                    this._status = u.LoaderStatus.kError;
                    var m = {
                      code: g.code,
                      msg: g.message
                    };
                    if (this._onError)
                      this._onError(u.LoaderErrors.EXCEPTION, m);
                    else
                      throw new c.RuntimeException(m.msg);
                  }, f;
                }(u.BaseLoader)
              );
              a.default = h;
            }
          ),
          /***/
          "./src/io/xhr-moz-chunked-loader.js": (
            /*!******************************************!*\
              !*** ./src/io/xhr-moz-chunked-loader.js ***!
              \******************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), c = l(
                /*! ./loader.js */
                "./src/io/loader.js"
              ), d = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), h = function() {
                var f = function(g, m) {
                  return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, E) {
                    v.__proto__ = E;
                  } || function(v, E) {
                    for (var A in E)
                      Object.prototype.hasOwnProperty.call(E, A) && (v[A] = E[A]);
                  }, f(g, m);
                };
                return function(g, m) {
                  if (typeof m != "function" && m !== null)
                    throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
                  f(g, m);
                  function v() {
                    this.constructor = g;
                  }
                  g.prototype = m === null ? Object.create(m) : (v.prototype = m.prototype, new v());
                };
              }(), p = (
                /** @class */
                function(f) {
                  h(g, f);
                  function g(m, v) {
                    var E = f.call(this, "xhr-moz-chunked-loader") || this;
                    return E.TAG = "MozChunkedLoader", E._seekHandler = m, E._config = v, E._needStash = !0, E._xhr = null, E._requestAbort = !1, E._contentLength = null, E._receivedLength = 0, E;
                  }
                  return g.isSupported = function() {
                    try {
                      var m = new XMLHttpRequest();
                      return m.open("GET", "https://example.com", !0), m.responseType = "moz-chunked-arraybuffer", m.responseType === "moz-chunked-arraybuffer";
                    } catch (v) {
                      return u.default.w("MozChunkedLoader", v.message), !1;
                    }
                  }, g.prototype.destroy = function() {
                    this.isWorking() && this.abort(), this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onloadend = null, this._xhr.onerror = null, this._xhr = null), f.prototype.destroy.call(this);
                  }, g.prototype.open = function(m, v) {
                    this._dataSource = m, this._range = v;
                    var E = m.url;
                    this._config.reuseRedirectedURL && m.redirectedURL != null && (E = m.redirectedURL);
                    var A = this._seekHandler.getConfig(E, v);
                    this._requestURL = A.url;
                    var _ = this._xhr = new XMLHttpRequest();
                    if (_.open("GET", A.url, !0), _.responseType = "moz-chunked-arraybuffer", _.onreadystatechange = this._onReadyStateChange.bind(this), _.onprogress = this._onProgress.bind(this), _.onloadend = this._onLoadEnd.bind(this), _.onerror = this._onXhrError.bind(this), m.withCredentials && (_.withCredentials = !0), typeof A.headers == "object") {
                      var y = A.headers;
                      for (var S in y)
                        y.hasOwnProperty(S) && _.setRequestHeader(S, y[S]);
                    }
                    if (typeof this._config.headers == "object") {
                      var y = this._config.headers;
                      for (var S in y)
                        y.hasOwnProperty(S) && _.setRequestHeader(S, y[S]);
                    }
                    this._status = c.LoaderStatus.kConnecting, _.send();
                  }, g.prototype.abort = function() {
                    this._requestAbort = !0, this._xhr && this._xhr.abort(), this._status = c.LoaderStatus.kComplete;
                  }, g.prototype._onReadyStateChange = function(m) {
                    var v = m.target;
                    if (v.readyState === 2) {
                      if (v.responseURL != null && v.responseURL !== this._requestURL && this._onURLRedirect) {
                        var E = this._seekHandler.removeURLParameters(v.responseURL);
                        this._onURLRedirect(E);
                      }
                      if (v.status !== 0 && (v.status < 200 || v.status > 299))
                        if (this._status = c.LoaderStatus.kError, this._onError)
                          this._onError(c.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: v.status, msg: v.statusText });
                        else
                          throw new d.RuntimeException("MozChunkedLoader: Http code invalid, " + v.status + " " + v.statusText);
                      else
                        this._status = c.LoaderStatus.kBuffering;
                    }
                  }, g.prototype._onProgress = function(m) {
                    if (this._status !== c.LoaderStatus.kError) {
                      this._contentLength === null && m.total !== null && m.total !== 0 && (this._contentLength = m.total, this._onContentLengthKnown && this._onContentLengthKnown(this._contentLength));
                      var v = m.target.response, E = this._range.from + this._receivedLength;
                      this._receivedLength += v.byteLength, this._onDataArrival && this._onDataArrival(v, E, this._receivedLength);
                    }
                  }, g.prototype._onLoadEnd = function(m) {
                    if (this._requestAbort === !0) {
                      this._requestAbort = !1;
                      return;
                    } else if (this._status === c.LoaderStatus.kError)
                      return;
                    this._status = c.LoaderStatus.kComplete, this._onComplete && this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);
                  }, g.prototype._onXhrError = function(m) {
                    this._status = c.LoaderStatus.kError;
                    var v = 0, E = null;
                    if (this._contentLength && m.loaded < this._contentLength ? (v = c.LoaderErrors.EARLY_EOF, E = { code: -1, msg: "Moz-Chunked stream meet Early-Eof" }) : (v = c.LoaderErrors.EXCEPTION, E = { code: -1, msg: m.constructor.name + " " + m.type }), this._onError)
                      this._onError(v, E);
                    else
                      throw new d.RuntimeException(E.msg);
                  }, g;
                }(c.BaseLoader)
              );
              a.default = p;
            }
          ),
          /***/
          "./src/io/xhr-range-loader.js": (
            /*!************************************!*\
              !*** ./src/io/xhr-range-loader.js ***!
              \************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), c = l(
                /*! ./speed-sampler.js */
                "./src/io/speed-sampler.js"
              ), d = l(
                /*! ./loader.js */
                "./src/io/loader.js"
              ), h = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), p = function() {
                var g = function(m, v) {
                  return g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(E, A) {
                    E.__proto__ = A;
                  } || function(E, A) {
                    for (var _ in A)
                      Object.prototype.hasOwnProperty.call(A, _) && (E[_] = A[_]);
                  }, g(m, v);
                };
                return function(m, v) {
                  if (typeof v != "function" && v !== null)
                    throw new TypeError("Class extends value " + String(v) + " is not a constructor or null");
                  g(m, v);
                  function E() {
                    this.constructor = m;
                  }
                  m.prototype = v === null ? Object.create(v) : (E.prototype = v.prototype, new E());
                };
              }(), f = (
                /** @class */
                function(g) {
                  p(m, g);
                  function m(v, E) {
                    var A = g.call(this, "xhr-range-loader") || this;
                    return A.TAG = "RangeLoader", A._seekHandler = v, A._config = E, A._needStash = !1, A._chunkSizeKBList = [
                      128,
                      256,
                      384,
                      512,
                      768,
                      1024,
                      1536,
                      2048,
                      3072,
                      4096,
                      5120,
                      6144,
                      7168,
                      8192
                    ], A._currentChunkSizeKB = 384, A._currentSpeedNormalized = 0, A._zeroSpeedChunkCount = 0, A._xhr = null, A._speedSampler = new c.default(), A._requestAbort = !1, A._waitForTotalLength = !1, A._totalLengthReceived = !1, A._currentRequestURL = null, A._currentRedirectedURL = null, A._currentRequestRange = null, A._totalLength = null, A._contentLength = null, A._receivedLength = 0, A._lastTimeLoaded = 0, A;
                  }
                  return m.isSupported = function() {
                    try {
                      var v = new XMLHttpRequest();
                      return v.open("GET", "https://example.com", !0), v.responseType = "arraybuffer", v.responseType === "arraybuffer";
                    } catch (E) {
                      return u.default.w("RangeLoader", E.message), !1;
                    }
                  }, m.prototype.destroy = function() {
                    this.isWorking() && this.abort(), this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onload = null, this._xhr.onerror = null, this._xhr = null), g.prototype.destroy.call(this);
                  }, Object.defineProperty(m.prototype, "currentSpeed", {
                    get: function() {
                      return this._speedSampler.lastSecondKBps;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), m.prototype.open = function(v, E) {
                    this._dataSource = v, this._range = E, this._status = d.LoaderStatus.kConnecting;
                    var A = !1;
                    this._dataSource.filesize != null && this._dataSource.filesize !== 0 && (A = !0, this._totalLength = this._dataSource.filesize), !this._totalLengthReceived && !A ? (this._waitForTotalLength = !0, this._internalOpen(this._dataSource, { from: 0, to: -1 })) : this._openSubRange();
                  }, m.prototype._openSubRange = function() {
                    var v = this._currentChunkSizeKB * 1024, E = this._range.from + this._receivedLength, A = E + v;
                    this._contentLength != null && A - this._range.from >= this._contentLength && (A = this._range.from + this._contentLength - 1), this._currentRequestRange = { from: E, to: A }, this._internalOpen(this._dataSource, this._currentRequestRange);
                  }, m.prototype._internalOpen = function(v, E) {
                    this._lastTimeLoaded = 0;
                    var A = v.url;
                    this._config.reuseRedirectedURL && (this._currentRedirectedURL != null ? A = this._currentRedirectedURL : v.redirectedURL != null && (A = v.redirectedURL));
                    var _ = this._seekHandler.getConfig(A, E);
                    this._currentRequestURL = _.url;
                    var y = this._xhr = new XMLHttpRequest();
                    if (y.open("GET", _.url, !0), y.responseType = "arraybuffer", y.onreadystatechange = this._onReadyStateChange.bind(this), y.onprogress = this._onProgress.bind(this), y.onload = this._onLoad.bind(this), y.onerror = this._onXhrError.bind(this), v.withCredentials && (y.withCredentials = !0), typeof _.headers == "object") {
                      var S = _.headers;
                      for (var b in S)
                        S.hasOwnProperty(b) && y.setRequestHeader(b, S[b]);
                    }
                    if (typeof this._config.headers == "object") {
                      var S = this._config.headers;
                      for (var b in S)
                        S.hasOwnProperty(b) && y.setRequestHeader(b, S[b]);
                    }
                    y.send();
                  }, m.prototype.abort = function() {
                    this._requestAbort = !0, this._internalAbort(), this._status = d.LoaderStatus.kComplete;
                  }, m.prototype._internalAbort = function() {
                    this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onload = null, this._xhr.onerror = null, this._xhr.abort(), this._xhr = null);
                  }, m.prototype._onReadyStateChange = function(v) {
                    var E = v.target;
                    if (E.readyState === 2) {
                      if (E.responseURL != null) {
                        var A = this._seekHandler.removeURLParameters(E.responseURL);
                        E.responseURL !== this._currentRequestURL && A !== this._currentRedirectedURL && (this._currentRedirectedURL = A, this._onURLRedirect && this._onURLRedirect(A));
                      }
                      if (E.status >= 200 && E.status <= 299) {
                        if (this._waitForTotalLength)
                          return;
                        this._status = d.LoaderStatus.kBuffering;
                      } else if (this._status = d.LoaderStatus.kError, this._onError)
                        this._onError(d.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: E.status, msg: E.statusText });
                      else
                        throw new h.RuntimeException("RangeLoader: Http code invalid, " + E.status + " " + E.statusText);
                    }
                  }, m.prototype._onProgress = function(v) {
                    if (this._status !== d.LoaderStatus.kError) {
                      if (this._contentLength === null) {
                        var E = !1;
                        if (this._waitForTotalLength) {
                          this._waitForTotalLength = !1, this._totalLengthReceived = !0, E = !0;
                          var A = v.total;
                          this._internalAbort(), A != null & A !== 0 && (this._totalLength = A);
                        }
                        if (this._range.to === -1 ? this._contentLength = this._totalLength - this._range.from : this._contentLength = this._range.to - this._range.from + 1, E) {
                          this._openSubRange();
                          return;
                        }
                        this._onContentLengthKnown && this._onContentLengthKnown(this._contentLength);
                      }
                      var _ = v.loaded - this._lastTimeLoaded;
                      this._lastTimeLoaded = v.loaded, this._speedSampler.addBytes(_);
                    }
                  }, m.prototype._normalizeSpeed = function(v) {
                    var E = this._chunkSizeKBList, A = E.length - 1, _ = 0, y = 0, S = A;
                    if (v < E[0])
                      return E[0];
                    for (; y <= S; ) {
                      if (_ = y + Math.floor((S - y) / 2), _ === A || v >= E[_] && v < E[_ + 1])
                        return E[_];
                      E[_] < v ? y = _ + 1 : S = _ - 1;
                    }
                  }, m.prototype._onLoad = function(v) {
                    if (this._status !== d.LoaderStatus.kError) {
                      if (this._waitForTotalLength) {
                        this._waitForTotalLength = !1;
                        return;
                      }
                      this._lastTimeLoaded = 0;
                      var E = this._speedSampler.lastSecondKBps;
                      if (E === 0 && (this._zeroSpeedChunkCount++, this._zeroSpeedChunkCount >= 3 && (E = this._speedSampler.currentKBps)), E !== 0) {
                        var A = this._normalizeSpeed(E);
                        this._currentSpeedNormalized !== A && (this._currentSpeedNormalized = A, this._currentChunkSizeKB = A);
                      }
                      var _ = v.target.response, y = this._range.from + this._receivedLength;
                      this._receivedLength += _.byteLength;
                      var S = !1;
                      this._contentLength != null && this._receivedLength < this._contentLength ? this._openSubRange() : S = !0, this._onDataArrival && this._onDataArrival(_, y, this._receivedLength), S && (this._status = d.LoaderStatus.kComplete, this._onComplete && this._onComplete(this._range.from, this._range.from + this._receivedLength - 1));
                    }
                  }, m.prototype._onXhrError = function(v) {
                    this._status = d.LoaderStatus.kError;
                    var E = 0, A = null;
                    if (this._contentLength && this._receivedLength > 0 && this._receivedLength < this._contentLength ? (E = d.LoaderErrors.EARLY_EOF, A = { code: -1, msg: "RangeLoader meet Early-Eof" }) : (E = d.LoaderErrors.EXCEPTION, A = { code: -1, msg: v.constructor.name + " " + v.type }), this._onError)
                      this._onError(E, A);
                    else
                      throw new h.RuntimeException(A.msg);
                  }, m;
                }(d.BaseLoader)
              );
              a.default = f;
            }
          ),
          /***/
          "./src/player/flv-player.js": (
            /*!**********************************!*\
              !*** ./src/player/flv-player.js ***!
              \**********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! events */
                "./node_modules/events/events.js"
              ), c = /* @__PURE__ */ l.n(u), d = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), h = l(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              ), p = l(
                /*! ./player-events.js */
                "./src/player/player-events.js"
              ), f = l(
                /*! ../core/transmuxer.js */
                "./src/core/transmuxer.js"
              ), g = l(
                /*! ../core/transmuxing-events.js */
                "./src/core/transmuxing-events.js"
              ), m = l(
                /*! ../core/mse-controller.js */
                "./src/core/mse-controller.js"
              ), v = l(
                /*! ../core/mse-events.js */
                "./src/core/mse-events.js"
              ), E = l(
                /*! ./player-errors.js */
                "./src/player/player-errors.js"
              ), A = l(
                /*! ../config.js */
                "./src/config.js"
              ), _ = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), y = (
                /** @class */
                function() {
                  function S(b, w) {
                    if (this.TAG = "FlvPlayer", this._type = "FlvPlayer", this._emitter = new (c())(), this._config = (0, A.createDefaultConfig)(), typeof w == "object" && Object.assign(this._config, w), b.type.toLowerCase() !== "flv")
                      throw new _.InvalidArgumentException("FlvPlayer requires an flv MediaDataSource input!");
                    b.isLive === !0 && (this._config.isLive = !0), this.e = {
                      onvLoadedMetadata: this._onvLoadedMetadata.bind(this),
                      onvSeeking: this._onvSeeking.bind(this),
                      onvCanPlay: this._onvCanPlay.bind(this),
                      onvStalled: this._onvStalled.bind(this),
                      onvProgress: this._onvProgress.bind(this)
                    }, self.performance && self.performance.now ? this._now = self.performance.now.bind(self.performance) : this._now = Date.now, this._pendingSeekTime = null, this._requestSetTime = !1, this._seekpointRecord = null, this._progressChecker = null, this._mediaDataSource = b, this._mediaElement = null, this._msectl = null, this._transmuxer = null, this._mseSourceOpened = !1, this._hasPendingLoad = !1, this._receivedCanPlay = !1, this._mediaInfo = null, this._statisticsInfo = null;
                    var P = h.default.chrome && (h.default.version.major < 50 || h.default.version.major === 50 && h.default.version.build < 2661);
                    this._alwaysSeekKeyframe = !!(P || h.default.msedge || h.default.msie), this._alwaysSeekKeyframe && (this._config.accurateSeek = !1);
                  }
                  return S.prototype.destroy = function() {
                    this._progressChecker != null && (window.clearInterval(this._progressChecker), this._progressChecker = null), this._transmuxer && this.unload(), this._mediaElement && this.detachMediaElement(), this.e = null, this._mediaDataSource = null, this._emitter.removeAllListeners(), this._emitter = null;
                  }, S.prototype.on = function(b, w) {
                    var P = this;
                    b === p.default.MEDIA_INFO ? this._mediaInfo != null && Promise.resolve().then(function() {
                      P._emitter.emit(p.default.MEDIA_INFO, P.mediaInfo);
                    }) : b === p.default.STATISTICS_INFO && this._statisticsInfo != null && Promise.resolve().then(function() {
                      P._emitter.emit(p.default.STATISTICS_INFO, P.statisticsInfo);
                    }), this._emitter.addListener(b, w);
                  }, S.prototype.off = function(b, w) {
                    this._emitter.removeListener(b, w);
                  }, S.prototype.attachMediaElement = function(b) {
                    var w = this;
                    if (this._mediaElement = b, b.addEventListener("loadedmetadata", this.e.onvLoadedMetadata), b.addEventListener("seeking", this.e.onvSeeking), b.addEventListener("canplay", this.e.onvCanPlay), b.addEventListener("stalled", this.e.onvStalled), b.addEventListener("progress", this.e.onvProgress), this._msectl = new m.default(this._config), this._msectl.on(v.default.UPDATE_END, this._onmseUpdateEnd.bind(this)), this._msectl.on(v.default.BUFFER_FULL, this._onmseBufferFull.bind(this)), this._msectl.on(v.default.SOURCE_OPEN, function() {
                      w._mseSourceOpened = !0, w._hasPendingLoad && (w._hasPendingLoad = !1, w.load());
                    }), this._msectl.on(v.default.ERROR, function(P) {
                      w._emitter.emit(p.default.ERROR, E.ErrorTypes.MEDIA_ERROR, E.ErrorDetails.MEDIA_MSE_ERROR, P);
                    }), this._msectl.attachMediaElement(b), this._pendingSeekTime != null)
                      try {
                        b.currentTime = this._pendingSeekTime, this._pendingSeekTime = null;
                      } catch {
                      }
                  }, S.prototype.detachMediaElement = function() {
                    this._mediaElement && (this._msectl.detachMediaElement(), this._mediaElement.removeEventListener("loadedmetadata", this.e.onvLoadedMetadata), this._mediaElement.removeEventListener("seeking", this.e.onvSeeking), this._mediaElement.removeEventListener("canplay", this.e.onvCanPlay), this._mediaElement.removeEventListener("stalled", this.e.onvStalled), this._mediaElement.removeEventListener("progress", this.e.onvProgress), this._mediaElement = null), this._msectl && (this._msectl.destroy(), this._msectl = null);
                  }, S.prototype.load = function() {
                    var b = this;
                    if (!this._mediaElement)
                      throw new _.IllegalStateException("HTMLMediaElement must be attached before load()!");
                    if (this._transmuxer)
                      throw new _.IllegalStateException("FlvPlayer.load() has been called, please call unload() first!");
                    if (!this._hasPendingLoad) {
                      if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === !1) {
                        this._hasPendingLoad = !0;
                        return;
                      }
                      this._mediaElement.readyState > 0 && (this._requestSetTime = !0, this._mediaElement.currentTime = 0), this._transmuxer = new f.default(this._mediaDataSource, this._config), this._transmuxer.on(g.default.INIT_SEGMENT, function(w, P) {
                        b._msectl.appendInitSegment(P);
                      }), this._transmuxer.on(g.default.MEDIA_SEGMENT, function(w, P) {
                        if (b._msectl.appendMediaSegment(P), b._config.lazyLoad && !b._config.isLive) {
                          var C = b._mediaElement.currentTime;
                          P.info.endDts >= (C + b._config.lazyLoadMaxDuration) * 1e3 && b._progressChecker == null && (d.default.v(b.TAG, "Maximum buffering duration exceeded, suspend transmuxing task"), b._suspendTransmuxer());
                        }
                      }), this._transmuxer.on(g.default.LOADING_COMPLETE, function() {
                        b._msectl.endOfStream(), b._emitter.emit(p.default.LOADING_COMPLETE);
                      }), this._transmuxer.on(g.default.RECOVERED_EARLY_EOF, function() {
                        b._emitter.emit(p.default.RECOVERED_EARLY_EOF);
                      }), this._transmuxer.on(g.default.IO_ERROR, function(w, P) {
                        b._emitter.emit(p.default.ERROR, E.ErrorTypes.NETWORK_ERROR, w, P);
                      }), this._transmuxer.on(g.default.DEMUX_ERROR, function(w, P) {
                        b._emitter.emit(p.default.ERROR, E.ErrorTypes.MEDIA_ERROR, w, { code: -1, msg: P });
                      }), this._transmuxer.on(g.default.MEDIA_INFO, function(w) {
                        b._mediaInfo = w, b._emitter.emit(p.default.MEDIA_INFO, Object.assign({}, w));
                      }), this._transmuxer.on(g.default.METADATA_ARRIVED, function(w) {
                        b._emitter.emit(p.default.METADATA_ARRIVED, w);
                      }), this._transmuxer.on(g.default.SCRIPTDATA_ARRIVED, function(w) {
                        b._emitter.emit(p.default.SCRIPTDATA_ARRIVED, w);
                      }), this._transmuxer.on(g.default.STATISTICS_INFO, function(w) {
                        b._statisticsInfo = b._fillStatisticsInfo(w), b._emitter.emit(p.default.STATISTICS_INFO, Object.assign({}, b._statisticsInfo));
                      }), this._transmuxer.on(g.default.RECOMMEND_SEEKPOINT, function(w) {
                        b._mediaElement && !b._config.accurateSeek && (b._requestSetTime = !0, b._mediaElement.currentTime = w / 1e3);
                      }), this._transmuxer.open();
                    }
                  }, S.prototype.unload = function() {
                    this._mediaElement && this._mediaElement.pause(), this._msectl && this._msectl.seek(0), this._transmuxer && (this._transmuxer.close(), this._transmuxer.destroy(), this._transmuxer = null);
                  }, S.prototype.play = function() {
                    return this._mediaElement.play();
                  }, S.prototype.pause = function() {
                    this._mediaElement.pause();
                  }, Object.defineProperty(S.prototype, "type", {
                    get: function() {
                      return this._type;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(S.prototype, "buffered", {
                    get: function() {
                      return this._mediaElement.buffered;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(S.prototype, "duration", {
                    get: function() {
                      return this._mediaElement.duration;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(S.prototype, "volume", {
                    get: function() {
                      return this._mediaElement.volume;
                    },
                    set: function(b) {
                      this._mediaElement.volume = b;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(S.prototype, "muted", {
                    get: function() {
                      return this._mediaElement.muted;
                    },
                    set: function(b) {
                      this._mediaElement.muted = b;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(S.prototype, "currentTime", {
                    get: function() {
                      return this._mediaElement ? this._mediaElement.currentTime : 0;
                    },
                    set: function(b) {
                      this._mediaElement ? this._internalSeek(b) : this._pendingSeekTime = b;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(S.prototype, "mediaInfo", {
                    get: function() {
                      return Object.assign({}, this._mediaInfo);
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(S.prototype, "statisticsInfo", {
                    get: function() {
                      return this._statisticsInfo == null && (this._statisticsInfo = {}), this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo), Object.assign({}, this._statisticsInfo);
                    },
                    enumerable: !1,
                    configurable: !0
                  }), S.prototype._fillStatisticsInfo = function(b) {
                    if (b.playerType = this._type, !(this._mediaElement instanceof HTMLVideoElement))
                      return b;
                    var w = !0, P = 0, C = 0;
                    if (this._mediaElement.getVideoPlaybackQuality) {
                      var T = this._mediaElement.getVideoPlaybackQuality();
                      P = T.totalVideoFrames, C = T.droppedVideoFrames;
                    } else
                      this._mediaElement.webkitDecodedFrameCount != null ? (P = this._mediaElement.webkitDecodedFrameCount, C = this._mediaElement.webkitDroppedFrameCount) : w = !1;
                    return w && (b.decodedFrames = P, b.droppedFrames = C), b;
                  }, S.prototype._onmseUpdateEnd = function() {
                    if (!(!this._config.lazyLoad || this._config.isLive)) {
                      for (var b = this._mediaElement.buffered, w = this._mediaElement.currentTime, P = 0, C = 0; C < b.length; C++) {
                        var T = b.start(C), x = b.end(C);
                        if (T <= w && w < x) {
                          P = x;
                          break;
                        }
                      }
                      P >= w + this._config.lazyLoadMaxDuration && this._progressChecker == null && (d.default.v(this.TAG, "Maximum buffering duration exceeded, suspend transmuxing task"), this._suspendTransmuxer());
                    }
                  }, S.prototype._onmseBufferFull = function() {
                    d.default.v(this.TAG, "MSE SourceBuffer is full, suspend transmuxing task"), this._progressChecker == null && this._suspendTransmuxer();
                  }, S.prototype._suspendTransmuxer = function() {
                    this._transmuxer && (this._transmuxer.pause(), this._progressChecker == null && (this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1e3)));
                  }, S.prototype._checkProgressAndResume = function() {
                    for (var b = this._mediaElement.currentTime, w = this._mediaElement.buffered, P = !1, C = 0; C < w.length; C++) {
                      var T = w.start(C), x = w.end(C);
                      if (b >= T && b < x) {
                        b >= x - this._config.lazyLoadRecoverDuration && (P = !0);
                        break;
                      }
                    }
                    P && (window.clearInterval(this._progressChecker), this._progressChecker = null, P && (d.default.v(this.TAG, "Continue loading from paused position"), this._transmuxer.resume()));
                  }, S.prototype._isTimepointBuffered = function(b) {
                    for (var w = this._mediaElement.buffered, P = 0; P < w.length; P++) {
                      var C = w.start(P), T = w.end(P);
                      if (b >= C && b < T)
                        return !0;
                    }
                    return !1;
                  }, S.prototype._internalSeek = function(b) {
                    var w = this._isTimepointBuffered(b), P = !1, C = 0;
                    if (b < 1 && this._mediaElement.buffered.length > 0) {
                      var T = this._mediaElement.buffered.start(0);
                      (T < 1 && b < T || h.default.safari) && (P = !0, C = h.default.safari ? 0.1 : T);
                    }
                    if (P)
                      this._requestSetTime = !0, this._mediaElement.currentTime = C;
                    else if (w) {
                      if (!this._alwaysSeekKeyframe)
                        this._requestSetTime = !0, this._mediaElement.currentTime = b;
                      else {
                        var x = this._msectl.getNearestKeyframe(Math.floor(b * 1e3));
                        this._requestSetTime = !0, x != null ? this._mediaElement.currentTime = x.dts / 1e3 : this._mediaElement.currentTime = b;
                      }
                      this._progressChecker != null && this._checkProgressAndResume();
                    } else
                      this._progressChecker != null && (window.clearInterval(this._progressChecker), this._progressChecker = null), this._msectl.seek(b), this._transmuxer.seek(Math.floor(b * 1e3)), this._config.accurateSeek && (this._requestSetTime = !0, this._mediaElement.currentTime = b);
                  }, S.prototype._checkAndApplyUnbufferedSeekpoint = function() {
                    if (this._seekpointRecord)
                      if (this._seekpointRecord.recordTime <= this._now() - 100) {
                        var b = this._mediaElement.currentTime;
                        this._seekpointRecord = null, this._isTimepointBuffered(b) || (this._progressChecker != null && (window.clearTimeout(this._progressChecker), this._progressChecker = null), this._msectl.seek(b), this._transmuxer.seek(Math.floor(b * 1e3)), this._config.accurateSeek && (this._requestSetTime = !0, this._mediaElement.currentTime = b));
                      } else
                        window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);
                  }, S.prototype._checkAndResumeStuckPlayback = function(b) {
                    var w = this._mediaElement;
                    if (b || !this._receivedCanPlay || w.readyState < 2) {
                      var P = w.buffered;
                      P.length > 0 && w.currentTime < P.start(0) && (d.default.w(this.TAG, "Playback seems stuck at " + w.currentTime + ", seek to " + P.start(0)), this._requestSetTime = !0, this._mediaElement.currentTime = P.start(0), this._mediaElement.removeEventListener("progress", this.e.onvProgress));
                    } else
                      this._mediaElement.removeEventListener("progress", this.e.onvProgress);
                  }, S.prototype._onvLoadedMetadata = function(b) {
                    this._pendingSeekTime != null && (this._mediaElement.currentTime = this._pendingSeekTime, this._pendingSeekTime = null);
                  }, S.prototype._onvSeeking = function(b) {
                    var w = this._mediaElement.currentTime, P = this._mediaElement.buffered;
                    if (this._requestSetTime) {
                      this._requestSetTime = !1;
                      return;
                    }
                    if (w < 1 && P.length > 0) {
                      var C = P.start(0);
                      if (C < 1 && w < C || h.default.safari) {
                        this._requestSetTime = !0, this._mediaElement.currentTime = h.default.safari ? 0.1 : C;
                        return;
                      }
                    }
                    if (this._isTimepointBuffered(w)) {
                      if (this._alwaysSeekKeyframe) {
                        var T = this._msectl.getNearestKeyframe(Math.floor(w * 1e3));
                        T != null && (this._requestSetTime = !0, this._mediaElement.currentTime = T.dts / 1e3);
                      }
                      this._progressChecker != null && this._checkProgressAndResume();
                      return;
                    }
                    this._seekpointRecord = {
                      seekPoint: w,
                      recordTime: this._now()
                    }, window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);
                  }, S.prototype._onvCanPlay = function(b) {
                    this._receivedCanPlay = !0, this._mediaElement.removeEventListener("canplay", this.e.onvCanPlay);
                  }, S.prototype._onvStalled = function(b) {
                    this._checkAndResumeStuckPlayback(!0);
                  }, S.prototype._onvProgress = function(b) {
                    this._checkAndResumeStuckPlayback();
                  }, S;
                }()
              );
              a.default = y;
            }
          ),
          /***/
          "./src/player/native-player.js": (
            /*!*************************************!*\
              !*** ./src/player/native-player.js ***!
              \*************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! events */
                "./node_modules/events/events.js"
              ), c = /* @__PURE__ */ l.n(u), d = l(
                /*! ./player-events.js */
                "./src/player/player-events.js"
              ), h = l(
                /*! ../config.js */
                "./src/config.js"
              ), p = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), f = (
                /** @class */
                function() {
                  function g(m, v) {
                    if (this.TAG = "NativePlayer", this._type = "NativePlayer", this._emitter = new (c())(), this._config = (0, h.createDefaultConfig)(), typeof v == "object" && Object.assign(this._config, v), m.type.toLowerCase() === "flv")
                      throw new p.InvalidArgumentException("NativePlayer does't support flv MediaDataSource input!");
                    if (m.hasOwnProperty("segments"))
                      throw new p.InvalidArgumentException("NativePlayer(" + m.type + ") doesn't support multipart playback!");
                    this.e = {
                      onvLoadedMetadata: this._onvLoadedMetadata.bind(this)
                    }, this._pendingSeekTime = null, this._statisticsReporter = null, this._mediaDataSource = m, this._mediaElement = null;
                  }
                  return g.prototype.destroy = function() {
                    this._mediaElement && (this.unload(), this.detachMediaElement()), this.e = null, this._mediaDataSource = null, this._emitter.removeAllListeners(), this._emitter = null;
                  }, g.prototype.on = function(m, v) {
                    var E = this;
                    m === d.default.MEDIA_INFO ? this._mediaElement != null && this._mediaElement.readyState !== 0 && Promise.resolve().then(function() {
                      E._emitter.emit(d.default.MEDIA_INFO, E.mediaInfo);
                    }) : m === d.default.STATISTICS_INFO && this._mediaElement != null && this._mediaElement.readyState !== 0 && Promise.resolve().then(function() {
                      E._emitter.emit(d.default.STATISTICS_INFO, E.statisticsInfo);
                    }), this._emitter.addListener(m, v);
                  }, g.prototype.off = function(m, v) {
                    this._emitter.removeListener(m, v);
                  }, g.prototype.attachMediaElement = function(m) {
                    if (this._mediaElement = m, m.addEventListener("loadedmetadata", this.e.onvLoadedMetadata), this._pendingSeekTime != null)
                      try {
                        m.currentTime = this._pendingSeekTime, this._pendingSeekTime = null;
                      } catch {
                      }
                  }, g.prototype.detachMediaElement = function() {
                    this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src"), this._mediaElement.removeEventListener("loadedmetadata", this.e.onvLoadedMetadata), this._mediaElement = null), this._statisticsReporter != null && (window.clearInterval(this._statisticsReporter), this._statisticsReporter = null);
                  }, g.prototype.load = function() {
                    if (!this._mediaElement)
                      throw new p.IllegalStateException("HTMLMediaElement must be attached before load()!");
                    this._mediaElement.src = this._mediaDataSource.url, this._mediaElement.readyState > 0 && (this._mediaElement.currentTime = 0), this._mediaElement.preload = "auto", this._mediaElement.load(), this._statisticsReporter = window.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval);
                  }, g.prototype.unload = function() {
                    this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src")), this._statisticsReporter != null && (window.clearInterval(this._statisticsReporter), this._statisticsReporter = null);
                  }, g.prototype.play = function() {
                    return this._mediaElement.play();
                  }, g.prototype.pause = function() {
                    this._mediaElement.pause();
                  }, Object.defineProperty(g.prototype, "type", {
                    get: function() {
                      return this._type;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(g.prototype, "buffered", {
                    get: function() {
                      return this._mediaElement.buffered;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(g.prototype, "duration", {
                    get: function() {
                      return this._mediaElement.duration;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(g.prototype, "volume", {
                    get: function() {
                      return this._mediaElement.volume;
                    },
                    set: function(m) {
                      this._mediaElement.volume = m;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(g.prototype, "muted", {
                    get: function() {
                      return this._mediaElement.muted;
                    },
                    set: function(m) {
                      this._mediaElement.muted = m;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(g.prototype, "currentTime", {
                    get: function() {
                      return this._mediaElement ? this._mediaElement.currentTime : 0;
                    },
                    set: function(m) {
                      this._mediaElement ? this._mediaElement.currentTime = m : this._pendingSeekTime = m;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(g.prototype, "mediaInfo", {
                    get: function() {
                      var m = this._mediaElement instanceof HTMLAudioElement ? "audio/" : "video/", v = {
                        mimeType: m + this._mediaDataSource.type
                      };
                      return this._mediaElement && (v.duration = Math.floor(this._mediaElement.duration * 1e3), this._mediaElement instanceof HTMLVideoElement && (v.width = this._mediaElement.videoWidth, v.height = this._mediaElement.videoHeight)), v;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(g.prototype, "statisticsInfo", {
                    get: function() {
                      var m = {
                        playerType: this._type,
                        url: this._mediaDataSource.url
                      };
                      if (!(this._mediaElement instanceof HTMLVideoElement))
                        return m;
                      var v = !0, E = 0, A = 0;
                      if (this._mediaElement.getVideoPlaybackQuality) {
                        var _ = this._mediaElement.getVideoPlaybackQuality();
                        E = _.totalVideoFrames, A = _.droppedVideoFrames;
                      } else
                        this._mediaElement.webkitDecodedFrameCount != null ? (E = this._mediaElement.webkitDecodedFrameCount, A = this._mediaElement.webkitDroppedFrameCount) : v = !1;
                      return v && (m.decodedFrames = E, m.droppedFrames = A), m;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), g.prototype._onvLoadedMetadata = function(m) {
                    this._pendingSeekTime != null && (this._mediaElement.currentTime = this._pendingSeekTime, this._pendingSeekTime = null), this._emitter.emit(d.default.MEDIA_INFO, this.mediaInfo);
                  }, g.prototype._reportStatisticsInfo = function() {
                    this._emitter.emit(d.default.STATISTICS_INFO, this.statisticsInfo);
                  }, g;
                }()
              );
              a.default = f;
            }
          ),
          /***/
          "./src/player/player-errors.js": (
            /*!*************************************!*\
              !*** ./src/player/player-errors.js ***!
              \*************************************/
            /***/
            function(o, a, l) {
              l.r(a), l.d(a, {
                /* harmony export */
                ErrorTypes: function() {
                  return (
                    /* binding */
                    d
                  );
                },
                /* harmony export */
                ErrorDetails: function() {
                  return (
                    /* binding */
                    h
                  );
                }
                /* harmony export */
              });
              var u = l(
                /*! ../io/loader.js */
                "./src/io/loader.js"
              ), c = l(
                /*! ../demux/demux-errors.js */
                "./src/demux/demux-errors.js"
              ), d = {
                NETWORK_ERROR: "NetworkError",
                MEDIA_ERROR: "MediaError",
                OTHER_ERROR: "OtherError"
              }, h = {
                NETWORK_EXCEPTION: u.LoaderErrors.EXCEPTION,
                NETWORK_STATUS_CODE_INVALID: u.LoaderErrors.HTTP_STATUS_CODE_INVALID,
                NETWORK_TIMEOUT: u.LoaderErrors.CONNECTING_TIMEOUT,
                NETWORK_UNRECOVERABLE_EARLY_EOF: u.LoaderErrors.UNRECOVERABLE_EARLY_EOF,
                MEDIA_MSE_ERROR: "MediaMSEError",
                MEDIA_FORMAT_ERROR: c.default.FORMAT_ERROR,
                MEDIA_FORMAT_UNSUPPORTED: c.default.FORMAT_UNSUPPORTED,
                MEDIA_CODEC_UNSUPPORTED: c.default.CODEC_UNSUPPORTED
              };
            }
          ),
          /***/
          "./src/player/player-events.js": (
            /*!*************************************!*\
              !*** ./src/player/player-events.js ***!
              \*************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = {
                ERROR: "error",
                LOADING_COMPLETE: "loading_complete",
                RECOVERED_EARLY_EOF: "recovered_early_eof",
                MEDIA_INFO: "media_info",
                METADATA_ARRIVED: "metadata_arrived",
                SCRIPTDATA_ARRIVED: "scriptdata_arrived",
                STATISTICS_INFO: "statistics_info"
              };
              a.default = u;
            }
          ),
          /***/
          "./src/remux/aac-silent.js": (
            /*!*********************************!*\
              !*** ./src/remux/aac-silent.js ***!
              \*********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = (
                /** @class */
                function() {
                  function c() {
                  }
                  return c.getSilentFrame = function(d, h) {
                    if (d === "mp4a.40.2") {
                      if (h === 1)
                        return new Uint8Array([0, 200, 0, 128, 35, 128]);
                      if (h === 2)
                        return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                      if (h === 3)
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                      if (h === 4)
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                      if (h === 5)
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                      if (h === 6)
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                    } else {
                      if (h === 1)
                        return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                      if (h === 2)
                        return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                      if (h === 3)
                        return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                    }
                    return null;
                  }, c;
                }()
              );
              a.default = u;
            }
          ),
          /***/
          "./src/remux/mp4-generator.js": (
            /*!************************************!*\
              !*** ./src/remux/mp4-generator.js ***!
              \************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = (
                /** @class */
                function() {
                  function c() {
                  }
                  return c.init = function() {
                    c.types = {
                      avc1: [],
                      avcC: [],
                      btrt: [],
                      dinf: [],
                      dref: [],
                      esds: [],
                      ftyp: [],
                      hdlr: [],
                      mdat: [],
                      mdhd: [],
                      mdia: [],
                      mfhd: [],
                      minf: [],
                      moof: [],
                      moov: [],
                      mp4a: [],
                      mvex: [],
                      mvhd: [],
                      sdtp: [],
                      stbl: [],
                      stco: [],
                      stsc: [],
                      stsd: [],
                      stsz: [],
                      stts: [],
                      tfdt: [],
                      tfhd: [],
                      traf: [],
                      trak: [],
                      trun: [],
                      trex: [],
                      tkhd: [],
                      vmhd: [],
                      smhd: [],
                      ".mp3": []
                    };
                    for (var d in c.types)
                      c.types.hasOwnProperty(d) && (c.types[d] = [
                        d.charCodeAt(0),
                        d.charCodeAt(1),
                        d.charCodeAt(2),
                        d.charCodeAt(3)
                      ]);
                    var h = c.constants = {};
                    h.FTYP = new Uint8Array([
                      105,
                      115,
                      111,
                      109,
                      0,
                      0,
                      0,
                      1,
                      105,
                      115,
                      111,
                      109,
                      97,
                      118,
                      99,
                      49
                      // avc1
                    ]), h.STSD_PREFIX = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1
                      // entry_count
                    ]), h.STTS = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                      // entry_count
                    ]), h.STSC = h.STCO = h.STTS, h.STSZ = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                      // sample_count
                    ]), h.HDLR_VIDEO = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      118,
                      105,
                      100,
                      101,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      86,
                      105,
                      100,
                      101,
                      111,
                      72,
                      97,
                      110,
                      100,
                      108,
                      101,
                      114,
                      0
                      // name: VideoHandler
                    ]), h.HDLR_AUDIO = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      115,
                      111,
                      117,
                      110,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      83,
                      111,
                      117,
                      110,
                      100,
                      72,
                      97,
                      110,
                      100,
                      108,
                      101,
                      114,
                      0
                      // name: SoundHandler
                    ]), h.DREF = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      12,
                      117,
                      114,
                      108,
                      32,
                      0,
                      0,
                      0,
                      1
                      // version(0) + flags
                    ]), h.SMHD = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                      // balance(2) + reserved(2)
                    ]), h.VMHD = new Uint8Array([
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                    ]);
                  }, c.box = function(d) {
                    for (var h = 8, p = null, f = Array.prototype.slice.call(arguments, 1), g = f.length, m = 0; m < g; m++)
                      h += f[m].byteLength;
                    p = new Uint8Array(h), p[0] = h >>> 24 & 255, p[1] = h >>> 16 & 255, p[2] = h >>> 8 & 255, p[3] = h & 255, p.set(d, 4);
                    for (var v = 8, m = 0; m < g; m++)
                      p.set(f[m], v), v += f[m].byteLength;
                    return p;
                  }, c.generateInitSegment = function(d) {
                    var h = c.box(c.types.ftyp, c.constants.FTYP), p = c.moov(d), f = new Uint8Array(h.byteLength + p.byteLength);
                    return f.set(h, 0), f.set(p, h.byteLength), f;
                  }, c.moov = function(d) {
                    var h = c.mvhd(d.timescale, d.duration), p = c.trak(d), f = c.mvex(d);
                    return c.box(c.types.moov, h, p, f);
                  }, c.mvhd = function(d, h) {
                    return c.box(c.types.mvhd, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      d >>> 24 & 255,
                      d >>> 16 & 255,
                      d >>> 8 & 255,
                      d & 255,
                      h >>> 24 & 255,
                      h >>> 16 & 255,
                      h >>> 8 & 255,
                      h & 255,
                      0,
                      1,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      64,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      255,
                      255,
                      255,
                      255
                      // next_track_ID
                    ]));
                  }, c.trak = function(d) {
                    return c.box(c.types.trak, c.tkhd(d), c.mdia(d));
                  }, c.tkhd = function(d) {
                    var h = d.id, p = d.duration, f = d.presentWidth, g = d.presentHeight;
                    return c.box(c.types.tkhd, new Uint8Array([
                      0,
                      0,
                      0,
                      7,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      h >>> 24 & 255,
                      h >>> 16 & 255,
                      h >>> 8 & 255,
                      h & 255,
                      0,
                      0,
                      0,
                      0,
                      p >>> 24 & 255,
                      p >>> 16 & 255,
                      p >>> 8 & 255,
                      p & 255,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      64,
                      0,
                      0,
                      0,
                      f >>> 8 & 255,
                      f & 255,
                      0,
                      0,
                      g >>> 8 & 255,
                      g & 255,
                      0,
                      0
                    ]));
                  }, c.mdia = function(d) {
                    return c.box(c.types.mdia, c.mdhd(d), c.hdlr(d), c.minf(d));
                  }, c.mdhd = function(d) {
                    var h = d.timescale, p = d.duration;
                    return c.box(c.types.mdhd, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      h >>> 24 & 255,
                      h >>> 16 & 255,
                      h >>> 8 & 255,
                      h & 255,
                      p >>> 24 & 255,
                      p >>> 16 & 255,
                      p >>> 8 & 255,
                      p & 255,
                      85,
                      196,
                      0,
                      0
                      // pre_defined = 0
                    ]));
                  }, c.hdlr = function(d) {
                    var h = null;
                    return d.type === "audio" ? h = c.constants.HDLR_AUDIO : h = c.constants.HDLR_VIDEO, c.box(c.types.hdlr, h);
                  }, c.minf = function(d) {
                    var h = null;
                    return d.type === "audio" ? h = c.box(c.types.smhd, c.constants.SMHD) : h = c.box(c.types.vmhd, c.constants.VMHD), c.box(c.types.minf, h, c.dinf(), c.stbl(d));
                  }, c.dinf = function() {
                    var d = c.box(c.types.dinf, c.box(c.types.dref, c.constants.DREF));
                    return d;
                  }, c.stbl = function(d) {
                    var h = c.box(
                      c.types.stbl,
                      // type: stbl
                      c.stsd(d),
                      // Sample Description Table
                      c.box(c.types.stts, c.constants.STTS),
                      // Time-To-Sample
                      c.box(c.types.stsc, c.constants.STSC),
                      // Sample-To-Chunk
                      c.box(c.types.stsz, c.constants.STSZ),
                      // Sample size
                      c.box(c.types.stco, c.constants.STCO)
                      // Chunk offset
                    );
                    return h;
                  }, c.stsd = function(d) {
                    return d.type === "audio" ? d.codec === "mp3" ? c.box(c.types.stsd, c.constants.STSD_PREFIX, c.mp3(d)) : c.box(c.types.stsd, c.constants.STSD_PREFIX, c.mp4a(d)) : c.box(c.types.stsd, c.constants.STSD_PREFIX, c.avc1(d));
                  }, c.mp3 = function(d) {
                    var h = d.channelCount, p = d.audioSampleRate, f = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      h,
                      0,
                      16,
                      0,
                      0,
                      0,
                      0,
                      p >>> 8 & 255,
                      p & 255,
                      0,
                      0
                    ]);
                    return c.box(c.types[".mp3"], f);
                  }, c.mp4a = function(d) {
                    var h = d.channelCount, p = d.audioSampleRate, f = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      h,
                      0,
                      16,
                      0,
                      0,
                      0,
                      0,
                      p >>> 8 & 255,
                      p & 255,
                      0,
                      0
                    ]);
                    return c.box(c.types.mp4a, f, c.esds(d));
                  }, c.esds = function(d) {
                    var h = d.config || [], p = h.length, f = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      3,
                      23 + p,
                      0,
                      1,
                      0,
                      4,
                      15 + p,
                      64,
                      21,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      5
                      // descriptor_type
                    ].concat([
                      p
                    ]).concat(h).concat([
                      6,
                      1,
                      2
                      // GASpecificConfig
                    ]));
                    return c.box(c.types.esds, f);
                  }, c.avc1 = function(d) {
                    var h = d.avcc, p = d.codecWidth, f = d.codecHeight, g = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      p >>> 8 & 255,
                      p & 255,
                      f >>> 8 & 255,
                      f & 255,
                      0,
                      72,
                      0,
                      0,
                      0,
                      72,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      10,
                      120,
                      113,
                      113,
                      47,
                      102,
                      108,
                      118,
                      46,
                      106,
                      115,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      24,
                      255,
                      255
                      // pre_defined = -1
                    ]);
                    return c.box(c.types.avc1, g, c.box(c.types.avcC, h));
                  }, c.mvex = function(d) {
                    return c.box(c.types.mvex, c.trex(d));
                  }, c.trex = function(d) {
                    var h = d.id, p = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      h >>> 24 & 255,
                      h >>> 16 & 255,
                      h >>> 8 & 255,
                      h & 255,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      1
                      // default_sample_flags
                    ]);
                    return c.box(c.types.trex, p);
                  }, c.moof = function(d, h) {
                    return c.box(c.types.moof, c.mfhd(d.sequenceNumber), c.traf(d, h));
                  }, c.mfhd = function(d) {
                    var h = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      d >>> 24 & 255,
                      d >>> 16 & 255,
                      d >>> 8 & 255,
                      d & 255
                    ]);
                    return c.box(c.types.mfhd, h);
                  }, c.traf = function(d, h) {
                    var p = d.id, f = c.box(c.types.tfhd, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      p >>> 24 & 255,
                      p >>> 16 & 255,
                      p >>> 8 & 255,
                      p & 255
                    ])), g = c.box(c.types.tfdt, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      h >>> 24 & 255,
                      h >>> 16 & 255,
                      h >>> 8 & 255,
                      h & 255
                    ])), m = c.sdtp(d), v = c.trun(d, m.byteLength + 16 + 16 + 8 + 16 + 8 + 8);
                    return c.box(c.types.traf, f, g, v, m);
                  }, c.sdtp = function(d) {
                    for (var h = d.samples || [], p = h.length, f = new Uint8Array(4 + p), g = 0; g < p; g++) {
                      var m = h[g].flags;
                      f[g + 4] = m.isLeading << 6 | m.dependsOn << 4 | m.isDependedOn << 2 | m.hasRedundancy;
                    }
                    return c.box(c.types.sdtp, f);
                  }, c.trun = function(d, h) {
                    var p = d.samples || [], f = p.length, g = 12 + 16 * f, m = new Uint8Array(g);
                    h += 8 + g, m.set([
                      0,
                      0,
                      15,
                      1,
                      f >>> 24 & 255,
                      f >>> 16 & 255,
                      f >>> 8 & 255,
                      f & 255,
                      h >>> 24 & 255,
                      h >>> 16 & 255,
                      h >>> 8 & 255,
                      h & 255
                    ], 0);
                    for (var v = 0; v < f; v++) {
                      var E = p[v].duration, A = p[v].size, _ = p[v].flags, y = p[v].cts;
                      m.set([
                        E >>> 24 & 255,
                        E >>> 16 & 255,
                        E >>> 8 & 255,
                        E & 255,
                        A >>> 24 & 255,
                        A >>> 16 & 255,
                        A >>> 8 & 255,
                        A & 255,
                        _.isLeading << 2 | _.dependsOn,
                        _.isDependedOn << 6 | _.hasRedundancy << 4 | _.isNonSync,
                        0,
                        0,
                        y >>> 24 & 255,
                        y >>> 16 & 255,
                        y >>> 8 & 255,
                        y & 255
                      ], 12 + 16 * v);
                    }
                    return c.box(c.types.trun, m);
                  }, c.mdat = function(d) {
                    return c.box(c.types.mdat, d);
                  }, c;
                }()
              );
              u.init(), a.default = u;
            }
          ),
          /***/
          "./src/remux/mp4-remuxer.js": (
            /*!**********************************!*\
              !*** ./src/remux/mp4-remuxer.js ***!
              \**********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              ), c = l(
                /*! ./mp4-generator.js */
                "./src/remux/mp4-generator.js"
              ), d = l(
                /*! ./aac-silent.js */
                "./src/remux/aac-silent.js"
              ), h = l(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              ), p = l(
                /*! ../core/media-segment-info.js */
                "./src/core/media-segment-info.js"
              ), f = l(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              ), g = (
                /** @class */
                function() {
                  function m(v) {
                    this.TAG = "MP4Remuxer", this._config = v, this._isLive = v.isLive === !0, this._dtsBase = -1, this._dtsBaseInited = !1, this._audioDtsBase = 1 / 0, this._videoDtsBase = 1 / 0, this._audioNextDts = void 0, this._videoNextDts = void 0, this._audioStashedLastSample = null, this._videoStashedLastSample = null, this._audioMeta = null, this._videoMeta = null, this._audioSegmentInfoList = new p.MediaSegmentInfoList("audio"), this._videoSegmentInfoList = new p.MediaSegmentInfoList("video"), this._onInitSegment = null, this._onMediaSegment = null, this._forceFirstIDR = !!(h.default.chrome && (h.default.version.major < 50 || h.default.version.major === 50 && h.default.version.build < 2661)), this._fillSilentAfterSeek = h.default.msedge || h.default.msie, this._mp3UseMpegAudio = !h.default.firefox, this._fillAudioTimestampGap = this._config.fixAudioTimestampGap;
                  }
                  return m.prototype.destroy = function() {
                    this._dtsBase = -1, this._dtsBaseInited = !1, this._audioMeta = null, this._videoMeta = null, this._audioSegmentInfoList.clear(), this._audioSegmentInfoList = null, this._videoSegmentInfoList.clear(), this._videoSegmentInfoList = null, this._onInitSegment = null, this._onMediaSegment = null;
                  }, m.prototype.bindDataSource = function(v) {
                    return v.onDataAvailable = this.remux.bind(this), v.onTrackMetadata = this._onTrackMetadataReceived.bind(this), this;
                  }, Object.defineProperty(m.prototype, "onInitSegment", {
                    /* prototype: function onInitSegment(type: string, initSegment: ArrayBuffer): void
                       InitSegment: {
                           type: string,
                           data: ArrayBuffer,
                           codec: string,
                           container: string
                       }
                    */
                    get: function() {
                      return this._onInitSegment;
                    },
                    set: function(v) {
                      this._onInitSegment = v;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(m.prototype, "onMediaSegment", {
                    /* prototype: function onMediaSegment(type: string, mediaSegment: MediaSegment): void
                       MediaSegment: {
                           type: string,
                           data: ArrayBuffer,
                           sampleCount: int32
                           info: MediaSegmentInfo
                       }
                    */
                    get: function() {
                      return this._onMediaSegment;
                    },
                    set: function(v) {
                      this._onMediaSegment = v;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), m.prototype.insertDiscontinuity = function() {
                    this._audioNextDts = this._videoNextDts = void 0;
                  }, m.prototype.seek = function(v) {
                    this._audioStashedLastSample = null, this._videoStashedLastSample = null, this._videoSegmentInfoList.clear(), this._audioSegmentInfoList.clear();
                  }, m.prototype.remux = function(v, E) {
                    if (!this._onMediaSegment)
                      throw new f.IllegalStateException("MP4Remuxer: onMediaSegment callback must be specificed!");
                    this._dtsBaseInited || this._calculateDtsBase(v, E), this._remuxVideo(E), this._remuxAudio(v);
                  }, m.prototype._onTrackMetadataReceived = function(v, E) {
                    var A = null, _ = "mp4", y = E.codec;
                    if (v === "audio")
                      this._audioMeta = E, E.codec === "mp3" && this._mp3UseMpegAudio ? (_ = "mpeg", y = "", A = new Uint8Array()) : A = c.default.generateInitSegment(E);
                    else if (v === "video")
                      this._videoMeta = E, A = c.default.generateInitSegment(E);
                    else
                      return;
                    if (!this._onInitSegment)
                      throw new f.IllegalStateException("MP4Remuxer: onInitSegment callback must be specified!");
                    this._onInitSegment(v, {
                      type: v,
                      data: A.buffer,
                      codec: y,
                      container: v + "/" + _,
                      mediaDuration: E.duration
                      // in timescale 1000 (milliseconds)
                    });
                  }, m.prototype._calculateDtsBase = function(v, E) {
                    this._dtsBaseInited || (v.samples && v.samples.length && (this._audioDtsBase = v.samples[0].dts), E.samples && E.samples.length && (this._videoDtsBase = E.samples[0].dts), this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase), this._dtsBaseInited = !0);
                  }, m.prototype.flushStashedSamples = function() {
                    var v = this._videoStashedLastSample, E = this._audioStashedLastSample, A = {
                      type: "video",
                      id: 1,
                      sequenceNumber: 0,
                      samples: [],
                      length: 0
                    };
                    v != null && (A.samples.push(v), A.length = v.length);
                    var _ = {
                      type: "audio",
                      id: 2,
                      sequenceNumber: 0,
                      samples: [],
                      length: 0
                    };
                    E != null && (_.samples.push(E), _.length = E.length), this._videoStashedLastSample = null, this._audioStashedLastSample = null, this._remuxVideo(A, !0), this._remuxAudio(_, !0);
                  }, m.prototype._remuxAudio = function(v, E) {
                    if (this._audioMeta != null) {
                      var A = v, _ = A.samples, y = void 0, S = -1, b = -1, w = this._audioMeta.refSampleDuration, P = this._audioMeta.codec === "mp3" && this._mp3UseMpegAudio, C = this._dtsBaseInited && this._audioNextDts === void 0, T = !1;
                      if (!(!_ || _.length === 0) && !(_.length === 1 && !E)) {
                        var x = 0, L = null, I = 0;
                        P ? (x = 0, I = A.length) : (x = 8, I = 8 + A.length);
                        var R = null;
                        if (_.length > 1 && (R = _.pop(), I -= R.length), this._audioStashedLastSample != null) {
                          var B = this._audioStashedLastSample;
                          this._audioStashedLastSample = null, _.unshift(B), I += B.length;
                        }
                        R != null && (this._audioStashedLastSample = R);
                        var D = _[0].dts - this._dtsBase;
                        if (this._audioNextDts)
                          y = D - this._audioNextDts;
                        else if (this._audioSegmentInfoList.isEmpty())
                          y = 0, this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty() && this._audioMeta.originalCodec !== "mp3" && (T = !0);
                        else {
                          var k = this._audioSegmentInfoList.getLastSampleBefore(D);
                          if (k != null) {
                            var F = D - (k.originalDts + k.duration);
                            F <= 3 && (F = 0);
                            var U = k.dts + k.duration + F;
                            y = D - U;
                          } else
                            y = 0;
                        }
                        if (T) {
                          var G = D - y, N = this._videoSegmentInfoList.getLastSegmentBefore(D);
                          if (N != null && N.beginDts < G) {
                            var V = d.default.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);
                            if (V) {
                              var j = N.beginDts, ee = G - N.beginDts;
                              u.default.v(this.TAG, "InsertPrefixSilentAudio: dts: " + j + ", duration: " + ee), _.unshift({ unit: V, dts: j, pts: j }), I += V.byteLength;
                            }
                          } else
                            T = !1;
                        }
                        for (var Y = [], te = 0; te < _.length; te++) {
                          var B = _[te], oe = B.unit, pe = B.dts - this._dtsBase, j = pe, ae = !1, Ie = null, ce = 0;
                          if (!(pe < -1e-3)) {
                            if (this._audioMeta.codec !== "mp3") {
                              var ie = pe, Ae = 3;
                              if (this._audioNextDts && (ie = this._audioNextDts), y = pe - ie, y <= -Ae * w) {
                                u.default.w(this.TAG, "Dropping 1 audio frame (originalDts: " + pe + " ms ,curRefDts: " + ie + " ms)  due to dtsCorrection: " + y + " ms overlap.");
                                continue;
                              } else if (y >= Ae * w && this._fillAudioTimestampGap && !h.default.safari) {
                                ae = !0;
                                var we = Math.floor(y / w);
                                u.default.w(this.TAG, `Large audio timestamp gap detected, may cause AV sync to drift. Silent frames will be generated to avoid unsync.
` + ("originalDts: " + pe + " ms, curRefDts: " + ie + " ms, ") + ("dtsCorrection: " + Math.round(y) + " ms, generate: " + we + " frames")), j = Math.floor(ie), ce = Math.floor(ie + w) - j;
                                var V = d.default.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);
                                V == null && (u.default.w(this.TAG, "Unable to generate silent frame for " + (this._audioMeta.originalCodec + " with " + this._audioMeta.channelCount + " channels, repeat last frame")), V = oe), Ie = [];
                                for (var Ve = 0; Ve < we; Ve++) {
                                  ie = ie + w;
                                  var He = Math.floor(ie), Ge = Math.floor(ie + w) - He, Me = {
                                    dts: He,
                                    pts: He,
                                    cts: 0,
                                    unit: V,
                                    size: V.byteLength,
                                    duration: Ge,
                                    originalDts: pe,
                                    flags: {
                                      isLeading: 0,
                                      dependsOn: 1,
                                      isDependedOn: 0,
                                      hasRedundancy: 0
                                    }
                                  };
                                  Ie.push(Me), I += Me.size;
                                }
                                this._audioNextDts = ie + w;
                              } else
                                j = Math.floor(ie), ce = Math.floor(ie + w) - j, this._audioNextDts = ie + w;
                            } else {
                              if (j = pe - y, te !== _.length - 1) {
                                var be = _[te + 1].dts - this._dtsBase - y;
                                ce = be - j;
                              } else if (R != null) {
                                var be = R.dts - this._dtsBase - y;
                                ce = be - j;
                              } else
                                Y.length >= 1 ? ce = Y[Y.length - 1].duration : ce = Math.floor(w);
                              this._audioNextDts = j + ce;
                            }
                            S === -1 && (S = j), Y.push({
                              dts: j,
                              pts: j,
                              cts: 0,
                              unit: B.unit,
                              size: B.unit.byteLength,
                              duration: ce,
                              originalDts: pe,
                              flags: {
                                isLeading: 0,
                                dependsOn: 1,
                                isDependedOn: 0,
                                hasRedundancy: 0
                              }
                            }), ae && Y.push.apply(Y, Ie);
                          }
                        }
                        if (Y.length === 0) {
                          A.samples = [], A.length = 0;
                          return;
                        }
                        P ? L = new Uint8Array(I) : (L = new Uint8Array(I), L[0] = I >>> 24 & 255, L[1] = I >>> 16 & 255, L[2] = I >>> 8 & 255, L[3] = I & 255, L.set(c.default.types.mdat, 4));
                        for (var te = 0; te < Y.length; te++) {
                          var oe = Y[te].unit;
                          L.set(oe, x), x += oe.byteLength;
                        }
                        var Ne = Y[Y.length - 1];
                        b = Ne.dts + Ne.duration;
                        var Ue = new p.MediaSegmentInfo();
                        Ue.beginDts = S, Ue.endDts = b, Ue.beginPts = S, Ue.endPts = b, Ue.originalBeginDts = Y[0].originalDts, Ue.originalEndDts = Ne.originalDts + Ne.duration, Ue.firstSample = new p.SampleInfo(Y[0].dts, Y[0].pts, Y[0].duration, Y[0].originalDts, !1), Ue.lastSample = new p.SampleInfo(Ne.dts, Ne.pts, Ne.duration, Ne.originalDts, !1), this._isLive || this._audioSegmentInfoList.append(Ue), A.samples = Y, A.sequenceNumber++;
                        var tt = null;
                        P ? tt = new Uint8Array() : tt = c.default.moof(A, S), A.samples = [], A.length = 0;
                        var Z = {
                          type: "audio",
                          data: this._mergeBoxes(tt, L).buffer,
                          sampleCount: Y.length,
                          info: Ue
                        };
                        P && C && (Z.timestampOffset = S), this._onMediaSegment("audio", Z);
                      }
                    }
                  }, m.prototype._remuxVideo = function(v, E) {
                    if (this._videoMeta != null) {
                      var A = v, _ = A.samples, y = void 0, S = -1, b = -1, w = -1, P = -1;
                      if (!(!_ || _.length === 0) && !(_.length === 1 && !E)) {
                        var C = 8, T = null, x = 8 + v.length, L = null;
                        if (_.length > 1 && (L = _.pop(), x -= L.length), this._videoStashedLastSample != null) {
                          var I = this._videoStashedLastSample;
                          this._videoStashedLastSample = null, _.unshift(I), x += I.length;
                        }
                        L != null && (this._videoStashedLastSample = L);
                        var R = _[0].dts - this._dtsBase;
                        if (this._videoNextDts)
                          y = R - this._videoNextDts;
                        else if (this._videoSegmentInfoList.isEmpty())
                          y = 0;
                        else {
                          var B = this._videoSegmentInfoList.getLastSampleBefore(R);
                          if (B != null) {
                            var D = R - (B.originalDts + B.duration);
                            D <= 3 && (D = 0);
                            var k = B.dts + B.duration + D;
                            y = R - k;
                          } else
                            y = 0;
                        }
                        for (var F = new p.MediaSegmentInfo(), U = [], G = 0; G < _.length; G++) {
                          var I = _[G], N = I.dts - this._dtsBase, V = I.isKeyframe, j = N - y, ee = I.cts, Y = j + ee;
                          S === -1 && (S = j, w = Y);
                          var te = 0;
                          if (G !== _.length - 1) {
                            var oe = _[G + 1].dts - this._dtsBase - y;
                            te = oe - j;
                          } else if (L != null) {
                            var oe = L.dts - this._dtsBase - y;
                            te = oe - j;
                          } else
                            U.length >= 1 ? te = U[U.length - 1].duration : te = Math.floor(this._videoMeta.refSampleDuration);
                          if (V) {
                            var pe = new p.SampleInfo(j, Y, te, I.dts, !0);
                            pe.fileposition = I.fileposition, F.appendSyncPoint(pe);
                          }
                          U.push({
                            dts: j,
                            pts: Y,
                            cts: ee,
                            units: I.units,
                            size: I.length,
                            isKeyframe: V,
                            duration: te,
                            originalDts: N,
                            flags: {
                              isLeading: 0,
                              dependsOn: V ? 2 : 1,
                              isDependedOn: V ? 1 : 0,
                              hasRedundancy: 0,
                              isNonSync: V ? 0 : 1
                            }
                          });
                        }
                        T = new Uint8Array(x), T[0] = x >>> 24 & 255, T[1] = x >>> 16 & 255, T[2] = x >>> 8 & 255, T[3] = x & 255, T.set(c.default.types.mdat, 4);
                        for (var G = 0; G < U.length; G++)
                          for (var ae = U[G].units; ae.length; ) {
                            var Ie = ae.shift(), ce = Ie.data;
                            T.set(ce, C), C += ce.byteLength;
                          }
                        var ie = U[U.length - 1];
                        if (b = ie.dts + ie.duration, P = ie.pts + ie.duration, this._videoNextDts = b, F.beginDts = S, F.endDts = b, F.beginPts = w, F.endPts = P, F.originalBeginDts = U[0].originalDts, F.originalEndDts = ie.originalDts + ie.duration, F.firstSample = new p.SampleInfo(U[0].dts, U[0].pts, U[0].duration, U[0].originalDts, U[0].isKeyframe), F.lastSample = new p.SampleInfo(ie.dts, ie.pts, ie.duration, ie.originalDts, ie.isKeyframe), this._isLive || this._videoSegmentInfoList.append(F), A.samples = U, A.sequenceNumber++, this._forceFirstIDR) {
                          var Ae = U[0].flags;
                          Ae.dependsOn = 2, Ae.isNonSync = 0;
                        }
                        var we = c.default.moof(A, S);
                        A.samples = [], A.length = 0, this._onMediaSegment("video", {
                          type: "video",
                          data: this._mergeBoxes(we, T).buffer,
                          sampleCount: U.length,
                          info: F
                        });
                      }
                    }
                  }, m.prototype._mergeBoxes = function(v, E) {
                    var A = new Uint8Array(v.byteLength + E.byteLength);
                    return A.set(v, 0), A.set(E, v.byteLength), A;
                  }, m;
                }()
              );
              a.default = g;
            }
          ),
          /***/
          "./src/utils/browser.js": (
            /*!******************************!*\
              !*** ./src/utils/browser.js ***!
              \******************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = {};
              function c() {
                var d = self.navigator.userAgent.toLowerCase(), h = /(edge)\/([\w.]+)/.exec(d) || /(opr)[\/]([\w.]+)/.exec(d) || /(chrome)[ \/]([\w.]+)/.exec(d) || /(iemobile)[\/]([\w.]+)/.exec(d) || /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(d) || /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(d) || /(webkit)[ \/]([\w.]+)/.exec(d) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(d) || /(msie) ([\w.]+)/.exec(d) || d.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(d) || d.indexOf("compatible") < 0 && /(firefox)[ \/]([\w.]+)/.exec(d) || [], p = /(ipad)/.exec(d) || /(ipod)/.exec(d) || /(windows phone)/.exec(d) || /(iphone)/.exec(d) || /(kindle)/.exec(d) || /(android)/.exec(d) || /(windows)/.exec(d) || /(mac)/.exec(d) || /(linux)/.exec(d) || /(cros)/.exec(d) || [], f = {
                  browser: h[5] || h[3] || h[1] || "",
                  version: h[2] || h[4] || "0",
                  majorVersion: h[4] || h[2] || "0",
                  platform: p[0] || ""
                }, g = {};
                if (f.browser) {
                  g[f.browser] = !0;
                  var m = f.majorVersion.split(".");
                  g.version = {
                    major: parseInt(f.majorVersion, 10),
                    string: f.version
                  }, m.length > 1 && (g.version.minor = parseInt(m[1], 10)), m.length > 2 && (g.version.build = parseInt(m[2], 10));
                }
                if (f.platform && (g[f.platform] = !0), (g.chrome || g.opr || g.safari) && (g.webkit = !0), g.rv || g.iemobile) {
                  g.rv && delete g.rv;
                  var v = "msie";
                  f.browser = v, g[v] = !0;
                }
                if (g.edge) {
                  delete g.edge;
                  var E = "msedge";
                  f.browser = E, g[E] = !0;
                }
                if (g.opr) {
                  var A = "opera";
                  f.browser = A, g[A] = !0;
                }
                if (g.safari && g.android) {
                  var _ = "android";
                  f.browser = _, g[_] = !0;
                }
                g.name = f.browser, g.platform = f.platform;
                for (var y in u)
                  u.hasOwnProperty(y) && delete u[y];
                Object.assign(u, g);
              }
              c(), a.default = u;
            }
          ),
          /***/
          "./src/utils/exception.js": (
            /*!********************************!*\
              !*** ./src/utils/exception.js ***!
              \********************************/
            /***/
            function(o, a, l) {
              l.r(a), l.d(a, {
                /* harmony export */
                RuntimeException: function() {
                  return (
                    /* binding */
                    c
                  );
                },
                /* harmony export */
                IllegalStateException: function() {
                  return (
                    /* binding */
                    d
                  );
                },
                /* harmony export */
                InvalidArgumentException: function() {
                  return (
                    /* binding */
                    h
                  );
                },
                /* harmony export */
                NotImplementedException: function() {
                  return (
                    /* binding */
                    p
                  );
                }
                /* harmony export */
              });
              var u = function() {
                var f = function(g, m) {
                  return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, E) {
                    v.__proto__ = E;
                  } || function(v, E) {
                    for (var A in E)
                      Object.prototype.hasOwnProperty.call(E, A) && (v[A] = E[A]);
                  }, f(g, m);
                };
                return function(g, m) {
                  if (typeof m != "function" && m !== null)
                    throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
                  f(g, m);
                  function v() {
                    this.constructor = g;
                  }
                  g.prototype = m === null ? Object.create(m) : (v.prototype = m.prototype, new v());
                };
              }(), c = (
                /** @class */
                function() {
                  function f(g) {
                    this._message = g;
                  }
                  return Object.defineProperty(f.prototype, "name", {
                    get: function() {
                      return "RuntimeException";
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(f.prototype, "message", {
                    get: function() {
                      return this._message;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), f.prototype.toString = function() {
                    return this.name + ": " + this.message;
                  }, f;
                }()
              ), d = (
                /** @class */
                function(f) {
                  u(g, f);
                  function g(m) {
                    return f.call(this, m) || this;
                  }
                  return Object.defineProperty(g.prototype, "name", {
                    get: function() {
                      return "IllegalStateException";
                    },
                    enumerable: !1,
                    configurable: !0
                  }), g;
                }(c)
              ), h = (
                /** @class */
                function(f) {
                  u(g, f);
                  function g(m) {
                    return f.call(this, m) || this;
                  }
                  return Object.defineProperty(g.prototype, "name", {
                    get: function() {
                      return "InvalidArgumentException";
                    },
                    enumerable: !1,
                    configurable: !0
                  }), g;
                }(c)
              ), p = (
                /** @class */
                function(f) {
                  u(g, f);
                  function g(m) {
                    return f.call(this, m) || this;
                  }
                  return Object.defineProperty(g.prototype, "name", {
                    get: function() {
                      return "NotImplementedException";
                    },
                    enumerable: !1,
                    configurable: !0
                  }), g;
                }(c)
              );
            }
          ),
          /***/
          "./src/utils/logger.js": (
            /*!*****************************!*\
              !*** ./src/utils/logger.js ***!
              \*****************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! events */
                "./node_modules/events/events.js"
              ), c = /* @__PURE__ */ l.n(u), d = (
                /** @class */
                function() {
                  function h() {
                  }
                  return h.e = function(p, f) {
                    (!p || h.FORCE_GLOBAL_TAG) && (p = h.GLOBAL_TAG);
                    var g = "[" + p + "] > " + f;
                    h.ENABLE_CALLBACK && h.emitter.emit("log", "error", g), h.ENABLE_ERROR && (console.error ? console.error(g) : console.warn ? console.warn(g) : console.log(g));
                  }, h.i = function(p, f) {
                    (!p || h.FORCE_GLOBAL_TAG) && (p = h.GLOBAL_TAG);
                    var g = "[" + p + "] > " + f;
                    h.ENABLE_CALLBACK && h.emitter.emit("log", "info", g), h.ENABLE_INFO && (console.info ? console.info(g) : console.log(g));
                  }, h.w = function(p, f) {
                    (!p || h.FORCE_GLOBAL_TAG) && (p = h.GLOBAL_TAG);
                    var g = "[" + p + "] > " + f;
                    h.ENABLE_CALLBACK && h.emitter.emit("log", "warn", g), h.ENABLE_WARN && (console.warn ? console.warn(g) : console.log(g));
                  }, h.d = function(p, f) {
                    (!p || h.FORCE_GLOBAL_TAG) && (p = h.GLOBAL_TAG);
                    var g = "[" + p + "] > " + f;
                    h.ENABLE_CALLBACK && h.emitter.emit("log", "debug", g), h.ENABLE_DEBUG && (console.debug ? console.debug(g) : console.log(g));
                  }, h.v = function(p, f) {
                    (!p || h.FORCE_GLOBAL_TAG) && (p = h.GLOBAL_TAG);
                    var g = "[" + p + "] > " + f;
                    h.ENABLE_CALLBACK && h.emitter.emit("log", "verbose", g), h.ENABLE_VERBOSE && console.log(g);
                  }, h;
                }()
              );
              d.GLOBAL_TAG = "flv.js", d.FORCE_GLOBAL_TAG = !1, d.ENABLE_ERROR = !0, d.ENABLE_INFO = !0, d.ENABLE_WARN = !0, d.ENABLE_DEBUG = !0, d.ENABLE_VERBOSE = !0, d.ENABLE_CALLBACK = !1, d.emitter = new (c())(), a.default = d;
            }
          ),
          /***/
          "./src/utils/logging-control.js": (
            /*!**************************************!*\
              !*** ./src/utils/logging-control.js ***!
              \**************************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = l(
                /*! events */
                "./node_modules/events/events.js"
              ), c = /* @__PURE__ */ l.n(u), d = l(
                /*! ./logger.js */
                "./src/utils/logger.js"
              ), h = (
                /** @class */
                function() {
                  function p() {
                  }
                  return Object.defineProperty(p, "forceGlobalTag", {
                    get: function() {
                      return d.default.FORCE_GLOBAL_TAG;
                    },
                    set: function(f) {
                      d.default.FORCE_GLOBAL_TAG = f, p._notifyChange();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p, "globalTag", {
                    get: function() {
                      return d.default.GLOBAL_TAG;
                    },
                    set: function(f) {
                      d.default.GLOBAL_TAG = f, p._notifyChange();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p, "enableAll", {
                    get: function() {
                      return d.default.ENABLE_VERBOSE && d.default.ENABLE_DEBUG && d.default.ENABLE_INFO && d.default.ENABLE_WARN && d.default.ENABLE_ERROR;
                    },
                    set: function(f) {
                      d.default.ENABLE_VERBOSE = f, d.default.ENABLE_DEBUG = f, d.default.ENABLE_INFO = f, d.default.ENABLE_WARN = f, d.default.ENABLE_ERROR = f, p._notifyChange();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p, "enableDebug", {
                    get: function() {
                      return d.default.ENABLE_DEBUG;
                    },
                    set: function(f) {
                      d.default.ENABLE_DEBUG = f, p._notifyChange();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p, "enableVerbose", {
                    get: function() {
                      return d.default.ENABLE_VERBOSE;
                    },
                    set: function(f) {
                      d.default.ENABLE_VERBOSE = f, p._notifyChange();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p, "enableInfo", {
                    get: function() {
                      return d.default.ENABLE_INFO;
                    },
                    set: function(f) {
                      d.default.ENABLE_INFO = f, p._notifyChange();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p, "enableWarn", {
                    get: function() {
                      return d.default.ENABLE_WARN;
                    },
                    set: function(f) {
                      d.default.ENABLE_WARN = f, p._notifyChange();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p, "enableError", {
                    get: function() {
                      return d.default.ENABLE_ERROR;
                    },
                    set: function(f) {
                      d.default.ENABLE_ERROR = f, p._notifyChange();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), p.getConfig = function() {
                    return {
                      globalTag: d.default.GLOBAL_TAG,
                      forceGlobalTag: d.default.FORCE_GLOBAL_TAG,
                      enableVerbose: d.default.ENABLE_VERBOSE,
                      enableDebug: d.default.ENABLE_DEBUG,
                      enableInfo: d.default.ENABLE_INFO,
                      enableWarn: d.default.ENABLE_WARN,
                      enableError: d.default.ENABLE_ERROR,
                      enableCallback: d.default.ENABLE_CALLBACK
                    };
                  }, p.applyConfig = function(f) {
                    d.default.GLOBAL_TAG = f.globalTag, d.default.FORCE_GLOBAL_TAG = f.forceGlobalTag, d.default.ENABLE_VERBOSE = f.enableVerbose, d.default.ENABLE_DEBUG = f.enableDebug, d.default.ENABLE_INFO = f.enableInfo, d.default.ENABLE_WARN = f.enableWarn, d.default.ENABLE_ERROR = f.enableError, d.default.ENABLE_CALLBACK = f.enableCallback;
                  }, p._notifyChange = function() {
                    var f = p.emitter;
                    if (f.listenerCount("change") > 0) {
                      var g = p.getConfig();
                      f.emit("change", g);
                    }
                  }, p.registerListener = function(f) {
                    p.emitter.addListener("change", f);
                  }, p.removeListener = function(f) {
                    p.emitter.removeListener("change", f);
                  }, p.addLogListener = function(f) {
                    d.default.emitter.addListener("log", f), d.default.emitter.listenerCount("log") > 0 && (d.default.ENABLE_CALLBACK = !0, p._notifyChange());
                  }, p.removeLogListener = function(f) {
                    d.default.emitter.removeListener("log", f), d.default.emitter.listenerCount("log") === 0 && (d.default.ENABLE_CALLBACK = !1, p._notifyChange());
                  }, p;
                }()
              );
              h.emitter = new (c())(), a.default = h;
            }
          ),
          /***/
          "./src/utils/polyfill.js": (
            /*!*******************************!*\
              !*** ./src/utils/polyfill.js ***!
              \*******************************/
            /***/
            function(o, a, l) {
              l.r(a);
              var u = (
                /** @class */
                function() {
                  function c() {
                  }
                  return c.install = function() {
                    Object.setPrototypeOf = Object.setPrototypeOf || function(d, h) {
                      return d.__proto__ = h, d;
                    }, Object.assign = Object.assign || function(d) {
                      if (d == null)
                        throw new TypeError("Cannot convert undefined or null to object");
                      for (var h = Object(d), p = 1; p < arguments.length; p++) {
                        var f = arguments[p];
                        if (f != null)
                          for (var g in f)
                            f.hasOwnProperty(g) && (h[g] = f[g]);
                      }
                      return h;
                    }, typeof self.Promise != "function" && l(
                      /*! es6-promise */
                      "./node_modules/es6-promise/dist/es6-promise.js"
                    ).polyfill();
                  }, c;
                }()
              );
              u.install(), a.default = u;
            }
          ),
          /***/
          "./src/utils/utf8-conv.js": (
            /*!********************************!*\
              !*** ./src/utils/utf8-conv.js ***!
              \********************************/
            /***/
            function(o, a, l) {
              l.r(a);
              function u(d, h, p) {
                var f = d;
                if (h + p < f.length) {
                  for (; p--; )
                    if ((f[++h] & 192) !== 128)
                      return !1;
                  return !0;
                } else
                  return !1;
              }
              function c(d) {
                for (var h = [], p = d, f = 0, g = d.length; f < g; ) {
                  if (p[f] < 128) {
                    h.push(String.fromCharCode(p[f])), ++f;
                    continue;
                  } else if (!(p[f] < 192)) {
                    if (p[f] < 224) {
                      if (u(p, f, 1)) {
                        var m = (p[f] & 31) << 6 | p[f + 1] & 63;
                        if (m >= 128) {
                          h.push(String.fromCharCode(m & 65535)), f += 2;
                          continue;
                        }
                      }
                    } else if (p[f] < 240) {
                      if (u(p, f, 2)) {
                        var m = (p[f] & 15) << 12 | (p[f + 1] & 63) << 6 | p[f + 2] & 63;
                        if (m >= 2048 && (m & 63488) !== 55296) {
                          h.push(String.fromCharCode(m & 65535)), f += 3;
                          continue;
                        }
                      }
                    } else if (p[f] < 248 && u(p, f, 3)) {
                      var m = (p[f] & 7) << 18 | (p[f + 1] & 63) << 12 | (p[f + 2] & 63) << 6 | p[f + 3] & 63;
                      if (m > 65536 && m < 1114112) {
                        m -= 65536, h.push(String.fromCharCode(m >>> 10 | 55296)), h.push(String.fromCharCode(m & 1023 | 56320)), f += 4;
                        continue;
                      }
                    }
                  }
                  h.push(String.fromCharCode(65533)), ++f;
                }
                return h.join("");
              }
              a.default = c;
            }
          )
          /******/
        }, r = {};
        function n(o) {
          var a = r[o];
          if (a !== void 0)
            return a.exports;
          var l = r[o] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return t[o].call(l.exports, l, l.exports, n), l.exports;
        }
        n.m = t, function() {
          n.n = function(o) {
            var a = o && o.__esModule ? (
              /******/
              function() {
                return o.default;
              }
            ) : (
              /******/
              function() {
                return o;
              }
            );
            return n.d(a, { a }), a;
          };
        }(), function() {
          n.d = function(o, a) {
            for (var l in a)
              n.o(a, l) && !n.o(o, l) && Object.defineProperty(o, l, { enumerable: !0, get: a[l] });
          };
        }(), function() {
          n.g = function() {
            if (typeof globalThis == "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch {
              if (typeof window == "object")
                return window;
            }
          }();
        }(), function() {
          n.o = function(o, a) {
            return Object.prototype.hasOwnProperty.call(o, a);
          };
        }(), function() {
          n.r = function(o) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(o, "__esModule", { value: !0 });
          };
        }();
        var s = n("./src/index.js");
        return s;
      }()
    );
  });
})(Iu);
var lA = Iu.exports;
const Br = /* @__PURE__ */ eg(lA);
const fn = (i) => (ju("data-v-8ac92887"), i = i(), Wu(), i), uA = ["src"], cA = ["src"], dA = /* @__PURE__ */ fn(() => /* @__PURE__ */ se("div", { class: "video-control-mask" }, null, -1)), hA = { class: "video-progress" }, fA = /* @__PURE__ */ fn(() => /* @__PURE__ */ se("div", { class: "video-progress-not-yet" }, null, -1)), pA = ["src"], gA = { class: "video-action" }, mA = { class: "video-play" }, vA = { class: "video-play-icon" }, yA = {
  key: 0,
  class: "video-time"
}, EA = {
  key: 1,
  class: "video-live flex flex-row justify-center items-center"
}, AA = /* @__PURE__ */ fn(() => /* @__PURE__ */ se("div", { class: "video-space" }, null, -1)), _A = { class: "video-setting" }, xA = { class: "video-action-icon" }, SA = { class: "selection-list" }, TA = ["onClick"], IA = { class: "video-action-icon" }, bA = {
  key: 0,
  class: "multiple"
}, LA = {
  key: 1,
  class: "multiple"
}, CA = { class: "speed-list" }, RA = ["onClick"], wA = {
  key: 0,
  class: "video-action-icon"
}, kA = {
  key: 1,
  class: "video-action-icon"
}, DA = /* @__PURE__ */ fn(() => /* @__PURE__ */ se("div", { class: "video-action-icon" }, [
  /* @__PURE__ */ se("img", {
    src: Tm,
    alt: "volume"
  })
], -1)), OA = { class: "setting-list" }, PA = { class: "setting-item" }, MA = { class: "setting-item" }, BA = { class: "video-action-icon" }, FA = { class: "video-action-icon" }, NA = /* @__PURE__ */ De({
  __name: "feather-video-player",
  props: {
    url: { default: "" },
    type: { default: void 0 }
  },
  setup(i) {
    var qs;
    const e = i, t = q(), r = q(), n = q(), s = q(), o = q(), a = q(), l = q(), u = q(), c = q(), d = q(), h = q(), p = q(), f = q(), g = q(), m = q(), v = q("video"), E = q(!1), A = q(!1), _ = q(!1), y = q(!1), S = q(0), b = q(0), w = q(0), P = q(0), C = q(0), T = q(""), x = q(!1), L = [2, 1.5, 1.25, 1, 0.75, 0.5], I = q(1), R = q(!1), B = q(!1), D = q(!0), k = q(100), F = q(), U = q([]), G = q(!0), N = q(!1), V = q(!1), j = q(""), ee = q([]);
    if (typeof e.url == "string")
      j.value = e.url;
    else if (e.url.urls.length > 0) {
      j.value = e.url.urls[0];
      const ne = (qs = e.url.names) == null ? void 0 : qs.length;
      ee.value = e.url.urls.map((he, _e) => ({
        url: he,
        // @ts-ignore
        name: 1 <= ne - _e ? e.url.names[_e] : "线路" + (_e + 1)
      }));
    }
    Re(_, (ne) => {
      u.value.style.pointerEvents = ne ? "none" : "auto";
    }), Re(S, (ne) => {
    }), Re(N, (ne) => {
      r.value && (r.value.loop = ne);
    }), Re(V, (ne) => {
      r.value && (r.value.style.transform = ne ? "rotateY(180deg)" : "");
    }), ht(() => {
      console.log("onMounted"), ct(() => {
        t.value && (t.value.style.height = t.value.clientWidth * 0.5625 + "px"), Y(), te(r.value);
      });
    }), Ba(() => {
      Ie();
    });
    const Y = () => {
      window.addEventListener("resize", Ne), window.addEventListener("fullscreenchange", Ue), window.addEventListener("enterpictureinpicture", tt), window.addEventListener("leavepictureinpicture", tt), t.value.addEventListener("mouseenter", $), t.value.addEventListener("mousemove", re), t.value.addEventListener("mouseleave", ue), r.value.addEventListener("click", Z), r.value.addEventListener("loadedmetadata", Le), r.value.addEventListener("timeupdate", Je), r.value.addEventListener("progress", ft), r.value.addEventListener("ended", Ye), r.value.addEventListener("canplay", pn), r.value.addEventListener("pause", Q), c.value.addEventListener("mouseenter", Rr), c.value.addEventListener("mousedown", xe), c.value.addEventListener("mousemove", qe), c.value.addEventListener("mouseleave", wr);
    }, te = (ne, he = "normal") => {
      switch (e.type) {
        case "m3u8": {
          oe(ne, he);
          break;
        }
        case "flv": {
          pe(ne, he);
          break;
        }
        default:
          j.value.includes(".m3u8") ? oe(ne, he) : j.value.includes(".flv") ? pe(ne, he) : ae(ne, he);
      }
    }, oe = (ne, he = "normal") => {
      var _e, Fe, Oe, nt;
      he === "normal" ? rt.isSupported() ? (s.value = new rt({
        liveDurationInfinity: !0
      }), (_e = s.value) == null || _e.attachMedia(ne), (Fe = s.value) == null || Fe.on(rt.Events.MEDIA_ATTACHED, () => {
        var Se, pt, Ot;
        console.log("初始化成功"), (Se = s.value) == null || Se.loadSource(j.value), (pt = s.value) == null || pt.on(rt.Events.MANIFEST_PARSED, (Xr, st) => {
          console.log("manifest loaded, found " + st.levels.length + " quality level");
        }), (Ot = s.value) == null || Ot.on(rt.Events.ERROR, function(Xr, st) {
          let gn = st.type, mn = st.details, vn = st.fatal;
          switch (console.log("视频错误信息回调"), console.log(gn), console.log(mn), console.log(vn), st.details) {
            case rt.ErrorDetails.FRAG_LOAD_ERROR:
              break;
          }
        });
      })) : console.error("不支持M3U8") : rt.isSupported() ? (o.value = new rt({
        liveDurationInfinity: !0
      }), (Oe = o.value) == null || Oe.attachMedia(ne), (nt = o.value) == null || nt.on(rt.Events.MEDIA_ATTACHED, () => {
        var Se, pt, Ot;
        console.log("Preview初始化成功"), (Se = o.value) == null || Se.loadSource(j.value), (pt = o.value) == null || pt.on(rt.Events.MANIFEST_PARSED, (Xr, st) => {
          console.log("Preview manifest loaded, found " + st.levels.length + " quality level");
        }), (Ot = o.value) == null || Ot.on(rt.Events.ERROR, function(Xr, st) {
          let gn = st.type, mn = st.details, vn = st.fatal;
          switch (console.log("视频错误信息回调"), console.log(gn), console.log(mn), console.log(vn), st.details) {
            case rt.ErrorDetails.FRAG_LOAD_ERROR:
              break;
          }
        });
      })) : console.error("Preview 不支持M3U8");
    }, pe = (ne, he = "normal") => {
      var _e, Fe, Oe, nt, Se, pt;
      he === "normal" ? Br.isSupported() ? (a.value = Br.createPlayer({
        type: "flv",
        url: j.value
      }), (_e = a.value) == null || _e.attachMediaElement(ne), (Fe = a.value) == null || Fe.load(), (Oe = a.value) == null || Oe.on(Br.Events.ERROR, (Ot, Xr, st) => {
        console.log("视频错误信息回调"), st.code === -1 && console.log("视频不是flv格式");
      })) : console.error("不支持FLV") : Br.isSupported() ? (l.value = Br.createPlayer({
        type: "flv",
        url: j.value
      }), (nt = l.value) == null || nt.attachMediaElement(ne), (Se = l.value) == null || Se.load(), (pt = l.value) == null || pt.on(Br.Events.ERROR, (Ot, Xr, st) => {
        console.log("Preview 视频错误信息回调"), st.code === -1 && console.log("Preview 视频不是flv格式");
      })) : console.error("Preview 不支持FLV");
    }, ae = (ne, he = "normal") => {
      he === "normal" ? r.value.src = j.value : n.value.src = j.value;
    }, Ie = () => {
      var ne, he, _e, Fe;
      (ne = s.value) == null || ne.destroy(), (he = o.value) == null || he.destroy(), (_e = a.value) == null || _e.destroy(), (Fe = l.value) == null || Fe.destroy(), s.value = null, o.value = null, a.value = null, l.value = null;
    }, ce = () => {
      r.value.paused ? (r.value.play(), y.value = !0) : (r.value.pause(), y.value = !1);
    }, ie = () => {
      R.value && document.fullscreenElement ? (R.value = !1, document.exitFullscreen()) : (R.value = !0, t.value.requestFullscreen());
    }, Ae = () => {
      B.value && document.pictureInPictureElement ? (B.value = !1, document.exitPictureInPicture()) : (B.value = !0, r.value.requestPictureInPicture());
    }, we = () => {
      G.value ? (G.value = !1, F.value.hide(), F.value.pause()) : (G.value = !0, F.value.show(), F.value.play());
    }, Ve = () => {
      D.value ? (D.value = !1, r.value.muted = !0) : (D.value = !0, r.value.muted = !1);
    }, He = (ne) => {
      k.value = ne, D.value = ne !== 0, r.value && (r.value.volume = ne / 100, ne === 0 && (r.value.muted = !0));
    }, Ge = (ne) => {
      I.value = ne, r.value && (r.value.playbackRate = ne);
    }, Me = (ne) => {
      let he = Math.round(ne), _e = 0, Fe = 0;
      he > 60 && (_e = Math.floor(he / 60), he = Math.floor(he % 60), _e > 60 && (Fe = Math.floor(_e / 60), _e = Math.floor(_e % 60)));
      let Oe = "00:" + be(he);
      return _e > 0 && (Oe = be(_e) + ":" + be(he)), (Fe > 0 || C.value >= 3600) && (Oe = be(Fe) + ":" + be(_e) + ":" + be(he)), Oe;
    }, be = (ne) => {
      let he = ne.toString();
      return ne < 10 && (he = "0" + ne), he;
    }, Ne = () => {
      if (t.value && (t.value.style.height = t.value.clientWidth * 0.5625 + "px"), F.value && F.value.resize(), c.value) {
        const he = c.value.getBoundingClientRect().width;
        h.value.style.width = he * (b.value / C.value) + "px", d.value.style.width = he * (S.value / C.value) + "px", p.value.style.left = he * (S.value / C.value) - 12 + "px";
      }
    }, Ue = () => {
      R.value = document.fullscreenElement !== null;
    }, tt = () => {
      B.value = document.pictureInPictureElement !== null;
    }, Z = (ne) => {
      ne.preventDefault(), ce();
    }, Le = () => {
      const ne = r.value.duration;
      ne === 1 / 0 ? v.value = "live" : (C.value = ne, te(n.value, "preview")), F.value.play();
    }, Je = () => {
      if (v.value === "video") {
        S.value = r.value.currentTime;
        const he = c.value.getBoundingClientRect().width;
        _.value || (d.value.style.width = he * (S.value / C.value) + "px", p.value.style.left = he * (S.value / C.value) - 12 + "px");
      }
    }, ft = () => {
      if (v.value === "video") {
        const ne = r.value.buffered, _e = c.value.getBoundingClientRect().width;
        ne.length > 0 && (b.value = ne.end(ne.length - 1), h.value.style.width = _e * (b.value / C.value) + "px");
      }
    }, Ye = () => {
      y.value = !1, F.value && F.value.stop();
    }, pn = () => {
      console.log("Canplay"), r.value.paused && r.value.play(), y.value = !0;
    }, Q = () => {
      y.value = !1;
    }, $ = () => {
      E.value = !0, clearTimeout(m.value), ve();
    }, re = () => {
      E.value = !0, clearTimeout(m.value), ve();
    }, ue = () => {
      _.value || (E.value = !1);
    }, ve = () => {
      m.value = setTimeout(() => {
        E.value = !1, clearTimeout(m.value);
      }, 3200);
    }, xe = () => {
      _.value = !0, document.addEventListener("mousemove", gr), document.addEventListener("mouseup", Ys);
    }, qe = (ne) => {
      const he = c.value.getBoundingClientRect(), _e = he.left, Fe = he.right;
      let Oe = 0;
      ne.pageX >= _e && ne.pageX <= Fe ? Oe = ne.pageX - _e : ne.pageX > Fe && (Oe = Fe - _e), P.value = Oe, v.value === "video" && (zs(), Zt());
    }, Zt = () => {
      x.value = !0;
      const ne = c.value.getBoundingClientRect(), he = f.value.getBoundingClientRect(), _e = g.value.getBoundingClientRect(), Fe = ne.width, Oe = he.width, nt = _e.width;
      let Se = P.value;
      Se < Oe / 2 ? Se = 0 : Se > Fe - Oe / 2 ? Se = Fe - Oe : Se -= Oe / 2, f.value.style.left = Se + "px", g.value.style.left = Se + (Oe - nt) / 2 + "px", g.value.innerText = Me(P.value / Fe * C.value);
    }, Rr = () => {
      const ne = c.value.children[0];
      ne && (ne.style.height = "4px"), A.value = !0;
    }, wr = () => {
      const ne = c.value.children[0];
      _.value || (ne && (ne.style.height = "2px"), A.value = !1, x.value = !1);
    }, gr = (ne) => {
      if (_.value) {
        clearTimeout(m.value);
        const he = c.value.children[0];
        he && (he.style.height = "4px"), A.value = !0;
        const _e = c.value.getBoundingClientRect(), Fe = _e.left, Oe = _e.right, nt = _e.width;
        let Se = 0;
        ne.pageX >= Fe && ne.pageX <= Oe ? Se = ne.pageX - Fe : ne.pageX > Oe && (Se = Oe - Fe), P.value = Se, v.value === "video" && (zs(), Zt()), d.value.style.width = Se + "px", p.value.style.left = Se - 12 + "px", w.value = Se / nt * C.value;
      }
    }, Ys = (ne) => {
      document.removeEventListener("mousemove", gr), document.removeEventListener("mouseup", Ys), gr(ne), wr(), ve(), _.value = !1, x.value = !1, r.value && (r.value.currentTime = w.value, w.value = 0, r.value.paused && r.value.play(), y.value = !0);
    }, { run: zs } = Dm(() => {
      bu(P.value).then((ne) => {
        typeof ne == "string" && (T.value = ne);
      });
    }, 250), bu = (ne) => new Promise((he) => {
      const Fe = c.value.getBoundingClientRect().width;
      let Oe = n.value;
      Oe.currentTime = C.value * ne / Fe, Oe.addEventListener("seeked", () => {
        var Ot;
        let nt = document.createElement("canvas"), Se = Oe.width, pt = Oe.width * Oe.videoHeight / Oe.videoWidth;
        nt.width = Se, nt.height = pt, (Ot = nt.getContext("2d")) == null || Ot.drawImage(Oe, 0, 0, Se, pt), he(nt.toDataURL("image/jpeg"));
      });
    }), Lu = (ne) => {
      j.value = ee.value[ne].url, Ie(), te(r.value), te(n.value, "preview");
    };
    return (ne, he) => {
      const _e = ws, Fe = Cg, Oe = nm, nt = gm;
      return X(), le("div", {
        class: "feather-video-container",
        ref_key: "containerRef",
        ref: t
      }, [
        se("video", {
          class: "feather-video",
          ref_key: "videoRef",
          ref: r,
          src: j.value
        }, null, 8, uA),
        se("video", {
          class: "feather-video-preview",
          src: j.value,
          ref_key: "videoPreviewRef",
          ref: n,
          preload: "none",
          crossOrigin: "anonymous",
          width: "960",
          height: "540"
        }, null, 8, cA),
        Ze(M(ks), {
          class: "feather-video-danmaku",
          ref_key: "danmaku",
          ref: F,
          danmus: U.value,
          autoplay: !1,
          speeds: 120,
          randomChannel: !0,
          top: 8
        }, null, 8, ["danmus"]),
        Ze(Fa, { name: "fade" }, {
          default: Ce(() => [
            jt(se("div", {
              class: "feather-video-control",
              ref_key: "controlRef",
              ref: u
            }, [
              dA,
              jt(se("div", {
                class: "video-progress-box",
                ref_key: "progressRef",
                ref: c
              }, [
                se("div", hA, [
                  se("div", {
                    class: "video-progress-has-done",
                    ref_key: "progressDoneRef",
                    ref: d
                  }, null, 512),
                  se("div", {
                    class: "video-progress-has-buffered",
                    ref_key: "progressBufferedRef",
                    ref: h
                  }, null, 512),
                  fA,
                  jt(se("img", {
                    class: "video-progress-block",
                    src: mm,
                    ref_key: "progressBlockRef",
                    ref: p,
                    alt: "block"
                  }, null, 512), [
                    [Er, A.value]
                  ]),
                  jt(se("img", {
                    class: "video-progress-preview",
                    src: T.value,
                    ref_key: "progressPreviewRef",
                    ref: f,
                    alt: "video-progress-preview"
                  }, null, 8, pA), [
                    [Er, T.value && x.value]
                  ]),
                  jt(se("div", {
                    class: "video-progress-preview-time",
                    ref_key: "progressPreviewTimeRef",
                    ref: g
                  }, null, 512), [
                    [Er, T.value && x.value]
                  ])
                ])
              ], 512), [
                [Er, v.value === "video"]
              ]),
              se("div", gA, [
                se("div", mA, [
                  se("div", vA, [
                    y.value ? (X(), le("img", {
                      key: 0,
                      src: vm,
                      alt: "pause",
                      onClick: ce
                    })) : (X(), le("img", {
                      key: 1,
                      src: ym,
                      alt: "play",
                      onClick: ce
                    }))
                  ]),
                  v.value === "video" ? (X(), le("div", yA, gt(`${Me(S.value)} / ${Me(C.value)}`), 1)) : ye("", !0),
                  v.value === "live" ? (X(), le("div", EA, "Live")) : ye("", !0)
                ]),
                AA,
                se("div", _A, [
                  se("div", xA, [
                    G.value ? (X(), ke(_e, {
                      key: 0,
                      class: "box-item",
                      effect: "dark",
                      content: "关闭弹幕",
                      placement: "top",
                      teleported: !1
                    }, {
                      default: Ce(() => [
                        se("img", {
                          style: { width: "28px", height: "30px" },
                          src: Em,
                          alt: "danmu",
                          onClick: we
                        })
                      ]),
                      _: 1
                    })) : (X(), ke(_e, {
                      key: 1,
                      class: "box-item",
                      effect: "dark",
                      content: "打开弹幕",
                      placement: "top",
                      teleported: !1
                    }, {
                      default: Ce(() => [
                        se("img", {
                          style: { width: "28px", height: "30px" },
                          src: Am,
                          alt: "danmu",
                          onClick: we
                        })
                      ]),
                      _: 1
                    }))
                  ]),
                  ee.value && ee.value.length > 0 ? (X(), ke(Fe, {
                    key: 0,
                    width: "160px",
                    trigger: "hover",
                    effect: "dark",
                    placement: "top",
                    "show-arrow": !1,
                    teleported: !1,
                    "popper-class": "volume-popover"
                  }, {
                    reference: Ce(() => [
                      se("div", { class: "video-action-icon" }, [
                        se("img", {
                          src: _m,
                          alt: "list",
                          onClick: Ve
                        })
                      ])
                    ]),
                    default: Ce(() => [
                      se("div", SA, [
                        (X(!0), le(Wt, null, si(ee.value, (Se, pt) => (X(), le("div", {
                          class: Ee(`selection-item flex flex-row justify-center ${j.value === Se.url ? "selection-item-select" : ""}`),
                          key: pt,
                          onClick: (Ot) => Lu(pt)
                        }, gt(Se.name), 11, TA))), 128))
                      ])
                    ]),
                    _: 1
                  })) : ye("", !0),
                  Ze(Fe, {
                    width: "75px",
                    trigger: "hover",
                    effect: "dark",
                    placement: "top",
                    "show-arrow": !1,
                    teleported: !1,
                    "popper-class": "volume-popover"
                  }, {
                    reference: Ce(() => [
                      se("div", IA, [
                        I.value === 1 ? (X(), le("div", bA, "倍速")) : (X(), le("div", LA, gt(I.value) + "x", 1))
                      ])
                    ]),
                    default: Ce(() => [
                      se("div", CA, [
                        (X(), le(Wt, null, si(L, (Se) => se("div", {
                          class: "speed-item flex flex-row justify-center",
                          style: Nt({ color: I.value === Se ? "var(--el-color-primary)" : "#d8eaf5" }),
                          key: Se,
                          onClick: (pt) => Ge(Se)
                        }, gt(Se) + "x ", 13, RA)), 64))
                      ])
                    ]),
                    _: 1
                  }),
                  Ze(Fe, {
                    width: "20px",
                    trigger: "hover",
                    effect: "dark",
                    placement: "top",
                    "show-arrow": !1,
                    teleported: !1,
                    "popper-class": "volume-popover"
                  }, {
                    reference: Ce(() => [
                      D.value ? (X(), le("div", wA, [
                        se("img", {
                          src: xm,
                          alt: "volume",
                          onClick: Ve
                        })
                      ])) : (X(), le("div", kA, [
                        se("img", {
                          src: Sm,
                          alt: "volume",
                          onClick: Ve
                        })
                      ]))
                    ]),
                    default: Ce(() => [
                      Ze(Oe, {
                        modelValue: k.value,
                        "onUpdate:modelValue": he[0] || (he[0] = (Se) => k.value = Se),
                        vertical: "",
                        height: "120px",
                        size: "small",
                        onInput: He,
                        onChange: He
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  Ze(Fe, {
                    width: "120px",
                    trigger: "hover",
                    effect: "dark",
                    placement: "top",
                    "show-arrow": !1,
                    teleported: !1,
                    "popper-class": "volume-popover"
                  }, {
                    reference: Ce(() => [
                      DA
                    ]),
                    default: Ce(() => [
                      se("div", OA, [
                        se("div", PA, [
                          Ze(nt, {
                            modelValue: N.value,
                            "onUpdate:modelValue": he[1] || (he[1] = (Se) => N.value = Se),
                            "inactive-text": "洗脑循环",
                            size: "small"
                          }, null, 8, ["modelValue"])
                        ]),
                        se("div", MA, [
                          Ze(nt, {
                            modelValue: V.value,
                            "onUpdate:modelValue": he[2] || (he[2] = (Se) => V.value = Se),
                            "inactive-text": "镜像画面",
                            size: "small"
                          }, null, 8, ["modelValue"])
                        ])
                      ])
                    ]),
                    _: 1
                  }),
                  se("div", BA, [
                    B.value ? (X(), ke(_e, {
                      key: 0,
                      class: "box-item",
                      effect: "dark",
                      content: "返回原画",
                      placement: "top",
                      teleported: !1
                    }, {
                      default: Ce(() => [
                        se("img", {
                          src: Im,
                          alt: "PictureInPicture",
                          onClick: Ae
                        })
                      ]),
                      _: 1
                    })) : (X(), ke(_e, {
                      key: 1,
                      class: "box-item",
                      effect: "dark",
                      content: "开启画中画",
                      placement: "top",
                      teleported: !1
                    }, {
                      default: Ce(() => [
                        se("img", {
                          src: bm,
                          alt: "PictureInPicture",
                          onClick: Ae
                        })
                      ]),
                      _: 1
                    }))
                  ]),
                  se("div", FA, [
                    R.value ? (X(), ke(_e, {
                      key: 0,
                      class: "box-item",
                      effect: "dark",
                      content: "退出全屏",
                      placement: "top-end",
                      teleported: !1
                    }, {
                      default: Ce(() => [
                        se("img", {
                          src: Lm,
                          alt: "fullscreen",
                          onClick: ie
                        })
                      ]),
                      _: 1
                    })) : (X(), ke(_e, {
                      key: 1,
                      class: "box-item",
                      effect: "dark",
                      content: "进入全屏",
                      placement: "top-end",
                      teleported: !1
                    }, {
                      default: Ce(() => [
                        se("img", {
                          src: Cm,
                          alt: "fullscreen",
                          onClick: ie
                        })
                      ]),
                      _: 1
                    }))
                  ])
                ])
              ])
            ], 512), [
              [Er, E.value]
            ])
          ]),
          _: 1
        })
      ], 512);
    };
  }
});
const UA = (i, e) => {
  const t = i.__vccOpts || i;
  for (const [r, n] of e)
    t[r] = n;
  return t;
}, HA = /* @__PURE__ */ UA(NA, [["__scopeId", "data-v-8ac92887"]]);
export {
  HA as default
};
